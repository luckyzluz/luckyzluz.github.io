<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>原型与原型链详解</title>
    <url>/2018/10/14/dda8c81b/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>与大部分面向对象语言不同，ES6之前并没有引入类（class）的概念，JavaScript并非通过类而是直接通过构造函数来创建实例。在介绍原型和原型链之前，我们有必要先复习一下构造函数的知识。</p>
<h2 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h2><p><strong>构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例。构造函数模式中拥有了类和实例的概念，并且实例和实例之间是相互独立的，即实例识别。</strong></p>
<p>构造函数就是一个普通的函数，创建方式和普通函数没有区别，<strong>不同的是构造函数习惯上首字母大写</strong>。另外就是调用方式的不同，普通函数是直接调用，<strong>而构造函数需要使用new关键字来调用</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">	<span class="built_in">this</span>.age = age</span><br><span class="line">	<span class="built_in">this</span>.gender = gender</span><br><span class="line">	<span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">	<span class="built_in">this</span>.age = age</span><br><span class="line">	<span class="built_in">this</span>.gender = gender</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">4</span>, <span class="string">&quot;雄&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(per);<span class="comment">//当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(dog);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/15543f1ae9cfe7e95d30522f2bb5d254.png"></p>
<p>每创建一个Person构造函数，在Person构造函数中，为每一个对象都添加了一个sayName方法，也就是说构造函数每执行一次就会创建一个新的sayName方法。这样就导致了构造函数执行一次就会创建一个新的方法，执行10000次就会创建10000个新的方法，而10000个方法都是一摸一样的，为什么不把这个方法单独放到一个地方，并让所有的实例都可以访问到呢?这就需要原型(<code>prototype</code>)</p>
<h2 id="二、原型"><a href="#二、原型" class="headerlink" title="二、原型"></a>二、原型</h2><p><strong>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个<code>prototype</code>属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。</strong></p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/67e633b1b48eb146b188536fa57cbf5f.png"></p>
<p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p>
<h2 id="三、原型链"><a href="#三、原型链" class="headerlink" title="三、原型链"></a>三、原型链</h2><h3 id="1-proto-和constructor"><a href="#1-proto-和constructor" class="headerlink" title="1.__proto__和constructor"></a>1.<code>__proto__</code>和<code>constructor</code></h3><p><strong>每一个对象数据类型(普通的对象、实例、<code>prototype</code>……)也天生自带一个属性<code>__proto__</code>，属性值是当前实例所属类的原型(<code>prototype</code>)。原型对象中有一个属性<code>constructor</code>, 它指向函数对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype)<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor===Person)<span class="comment">//true</span></span><br><span class="line"><span class="comment">//顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/80a10906001b2a310b8697c821284637.png"></p>
<h3 id="2-何为原型链"><a href="#2-何为原型链" class="headerlink" title="2.何为原型链"></a>2.何为原型链</h3><p><strong>在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链</strong>。</p>
<p>举例说明:person → Person → Object ，普通人继承人类，人类继承对象类</p>
<p><strong>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。</strong></p>
<p>我们可以使用对象的<code>hasOwnProperty()</code>来检查对象自身中是否含有该属性；使用<code>in</code>检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.a = <span class="number">123</span>;</span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.a)<span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span><span class="keyword">in</span> person)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>person实例中没有a这个属性，从 person 对象中找不到 a 属性就会从 person 的原型也就是 <code>person.__proto__</code> ，也就是 Person.prototype中查找，很幸运地得到a的值为123。那假如 <code>person.__proto__</code>中也没有该属性，又该如何查找？</p>
<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层Object为止。<strong>Object是JS中所有对象数据类型的基类(最顶层的类)在Object.prototype上没有<code>__proto__</code>这个属性。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0fc9b5cc09056eb5010086ccf23f1ed2.png" alt="img"></p>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>关于响应式布局，你必须要知道的</title>
    <url>/2018/10/14/ski4s5ed/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>响应式 Web 设计可以让一个网站同时适配多种设备和多个屏幕，可以让网站的布局和功能随用户的使用环境（屏幕大小、输入方式、设备/浏览器能力）而变化。本文主要介绍一些响应式布局容易忽略但又很重要的知识点。</p>
<h2 id="二、视口"><a href="#二、视口" class="headerlink" title="二、视口"></a>二、视口</h2><p><strong>移动前端中常说的 viewport （视口）就是浏览器中用于呈现网页的区域。视口通常并不等于屏幕大小，特别是可以缩放浏览器窗口的情况下</strong>。手机端与 PC 端视口存在差异，电脑端的视口宽度等于分辨率，而移动端的视口宽度跟分辨率没有关系,宽度默认值是设备厂家指定的。iOS, Android 基本都将这个视口分辨率设置为 980px。</p>
<h4 id="1-为什么手机端视口要设为-980px"><a href="#1-为什么手机端视口要设为-980px" class="headerlink" title="1.为什么手机端视口要设为 980px?"></a>1.为什么手机端视口要设为 980px?</h4><p>当年乔布斯设想：苹果手机如果在市场上火爆了，但是各个网站还没有来得及制作手机端网页，那么用户不得不用手机访问电脑版的网页，<strong>如何用小屏幕访问大屏幕的页面也同样可读呢</strong>？乔帮主就想着为手机固定一个视口宽度，让手机的视口宽度等于世界上绝大多数 PC 网页的版心宽度，就是 980px。这样，用手机访问电脑版网页的时候，旁边刚好没有留白。不过页面缩放后文字会变得非常小，用户需要手动放大缩小才能看清楚，体验非常差。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-61b9f61766c2cfc0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PC端页面在手机上显示效果"></p>
<h4 id="2-约束视口"><a href="#2-约束视口" class="headerlink" title="2.约束视口"></a>2.约束视口</h4><p>为了解决前面的问题，可以在网页的中添加下面这行代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">width=device-width   视口为设备宽度（就是人设置的一个宽度）//不设置的话默认为980px</span><br><span class="line">initial-scale=1.0    初始化的视口大小是1.0倍</span><br><span class="line">maximum-scale=1.0    最大的倍数是1.0倍</span><br><span class="line">user-scalable=0      不允许缩放视口</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个视口的标签告诉浏览器怎么渲染网页。在这里，标签想表达的意思是：按照设备的宽度（device-width）来渲染网页内容。事实上，在支持这个标签的设备上给你看一看效果，你就明白了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-aa0a7fa4ea5860a2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="约束视口后"></p>
<p>不错呀！用户体验大大改善！！！<br>此时如果用 document.documentElement.clientWidth 来测试浏览器屏幕宽度，你会发现当前视口宽度等于手机屏幕的宽度，约数后的视口宽度都是在 320~480 之间（手机竖直使用的时候）。<br>这个视口的尺寸，是手机厂商设置的，能够保证我们的文字比如 16px，在自己的这个视口下清晰、大小刚刚合适。所以<strong>大屏幕的手机的约束视口 &gt; 小屏幕手机的约束视口。这就能够保证我们的网页可以用 px 写字号、写行高</strong>。<br><strong>需要注意的是：约束之后的视口宽度，不是自己的分辨率！！每个手机的分辨率，都要比自己的视口宽度大得多得多！</strong></p>
<p><strong>最最重要的一句话：前端开发工程师，丝毫不关心手机的分辨率，我们只关心视口。</strong></p>
<h2 id="三、图片"><a href="#三、图片" class="headerlink" title="三、图片"></a>三、图片</h2><p>人们常说说“一图胜千言”，确实如此。我们网页中关于松饼的文字介绍再多，也没有图片有吸引力。下面我们就在页面上方添加一张松饼的图片（2000 像素宽），效果类似引诱用户往下看的大题图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-ffe488f2924e7dcf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加图片后"></p>
<p>哇，真是好大一张图，它让整个网页看起来都失衡了，水平方向上图片溢出了。不行，必须解决这个问题。可以用 CSS 给图片指定固定宽度，<strong>但问题是我们想让它能在不同大小的屏幕中自动缩放</strong>。比如，我们例子中的 iPhone 屏幕宽度为 320 像素，如果我们把图片设置成 320 像素宽，那么 iPhone 屏幕旋转后又怎么办呢？这时候 320 像素变成了 480 像素。<br>解决方案很简单，只要一行 CSS 代码就可以让图片随容器宽度自动缩放:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line"> <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回到手机上，刷新页面，结果比较符合预期了。<br>这里声明 max-width 规则，就是要保证所有图片最大显示为其自身的 100%（即最大只可以显示为自身那么大）。<strong>此时，如果包含图片的元素（比如包含图片的 body 或 div）比图片固有宽度小，图片会缩放占满最大可用空间</strong>。</p>
<h4 id="为什么不用-width-100"><a href="#为什么不用-width-100" class="headerlink" title="为什么不用 width:100%?"></a>为什么不用 width:100%?</h4><p>要实现图片的自动缩放，也可以使用更通用的 width 属性，比如 width:100%。然而，这条规则在这里并不适用。因为这条规则会导致它显示得跟它的容器一样宽。<strong>在容器比图片宽得多的情况下，图片会被无谓地拉伸。</strong></p>
<h2 id="四、手机浏览器内核"><a href="#四、手机浏览器内核" class="headerlink" title="四、手机浏览器内核"></a>四、手机浏览器内核</h2><p>在移动端，仅有四个独立的浏览器内核，分别为微软的 Trident、火狐的 Gecko、开源内核 Webkit、Opera 的 Presto。<br>目前微软的 Trident 在移动终端上主要为 WP7、8 系统内置浏览器。Opera 的 Presto 内核主要为 Opera Mobile、OperaMini、欧朋浏览器以及欧朋 HD Beta 版。<strong>Webkit 内核的适用范围则较为广泛，Android 原生浏览器、苹果的 Safari、谷歌 Chrome(Android4.0 使用)都是基于 Webkit 开源内核开发的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">兼容的前缀：</span><br><span class="line">1	-ms-</span><br><span class="line">2	-moz-</span><br><span class="line">3	-o-</span><br><span class="line">4	-webkit-</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>中国用户的浏览器市场份额：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-65700ebe6311e394?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="近一年中国用户的浏览器市场份额"></p>
<p>UC、Android 内置、Chrome、Safari、QQ Browser 都是 webkit 内核，从图上看占了绝大部分的市场份额。<br>所以一定要伺候好-webkit-。 有的公司干脆只兼容-webkit-，别的兼容比如-ms-都不写。</p>
<h2 id="五、流式布局"><a href="#五、流式布局" class="headerlink" title="五、流式布局"></a>五、流式布局</h2><p><strong>百分比布局也叫作流式布局、弹性盒布局。手机网页没有版心，都左右撑满。</strong></p>
<p><strong>百分比能够设置的属性是 width、height、padding、margin。其他属性比如 border、font-size 不能用百分比设置的。</strong></p>
<ul>
<li>  如果用百分比写 width，那么指的是父元素 width 的百分之多少。</li>
<li>  如果用百分比写 height，那么指的是父元素 height 的百分之多少。</li>
<li>  如果用百分比写 padding，那么指的是父元素 width 的百分之多少，无论是水平的 padding 还是竖直的 padding。</li>
<li>  如果用百分比写 margin，那么指的是父元素 width 的百分之多少，无论是水平的 margin 还是竖直的 margin。</li>
<li>  不能用百分比写 border 的宽度</li>
</ul>
<p>接下来我们看一个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">padding</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">padding</span>:<span class="number">10%</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">/*此时p的真实宽度是多少？*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-6cd6772e448675b0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p的盒模型图"></p>
<p>此时 p 的真实宽度是 140px*190px</p>
<h2 id="六、媒体查询"><a href="#六、媒体查询" class="headerlink" title="六、媒体查询"></a>六、媒体查询</h2><h4 id="1-为什么响应式-Web-设计需要媒体查询"><a href="#1-为什么响应式-Web-设计需要媒体查询" class="headerlink" title="1.为什么响应式 Web 设计需要媒体查询"></a>1.为什么响应式 Web 设计需要媒体查询</h4><p><strong>CSS3 媒体查询可以让我们针对特定的设备能力或条件为网页应用特定的 CSS 样式</strong>。如果没有媒体查询，光用 CSS 是无法大大修改网页外观的。这个模块让我们可以提前编写出适应很多不可预测因素的 CSS 规则，比如屏幕方向水平或垂直、视口或大或小等等。弹性布局虽然可以让设计适应较多场景，也包括某些尺寸的屏幕，但有时候确实不够用，因为我们还需要对布局进行更细致的调整。媒体查询让这一切成为可能，它就相当于 CSS 中基本的条件逻辑。</p>
<h4 id="2-媒体查询语法"><a href="#2-媒体查询语法" class="headerlink" title="2.媒体查询语法"></a>2.媒体查询语法</h4><p><strong>我们在媒体查询外面写的第一条规则，是“基本的”样式，它适用于任何设备。在此基础上，我们再为不同视口、不同能力的设备，渐进增加不同的视觉效果和功能。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: grey;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">1200px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">        <span class="attribute">background-color</span>: pink;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">700px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">1200px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">background-color</span>: blue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">700px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">background-color</span>: orange;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 @media 就表示媒体查询，查询现在看这个网页的设备是什么，以及它的宽度是多少。screen 表示看这个网页的设备是显示器，而不是残疾人听力设备、也不是打印机。后面用 and 符号罗列所有的可能性。<br>值得注意：<strong>媒体查询只能包裹选择器，不能包裹 k:v 对儿。</strong></p>
<p><strong>IE6、7、8 不支持媒体查询，也为了防止手机端的某些浏览器不支持媒体查询，所以不要把所有的选择器都放在媒体查询里面。</strong></p>
<h2 id="七、rem-响应式布局"><a href="#七、rem-响应式布局" class="headerlink" title="七、rem 响应式布局"></a>七、rem 响应式布局</h2><blockquote>
<p>rem 响应式布局思想</p>
</blockquote>
<ol>
<li> 一般不要给元素设置具体的宽度,但是对于一些小图标可以设定具体宽度值</li>
<li> 高度值可以设置固定值,设计稿有多大,我们就严格写多大</li>
<li> 所有设置的固定值都用 REM 做单位(首先在 HTML 中设置一个基准值：PX 和 REM 的对应比例,然后在效果图上获取 PX 值,布局的时候转化为 REM 值)</li>
<li> JS 获取真实屏幕的宽度,让其除以设计稿的宽度,算出比例,把之前的基准值按照比例进行重新的设定,这样项目就可以在移动端自适应了</li>
</ol>
<blockquote>
<p>什么是 rem,它与 em 有何区别</p>
</blockquote>
<p><strong>rem:当前页面中元素的 REM 单位的样式值都是针对于 HTML 元素的 font-size 的值进行动态计算的</strong></p>
<p><strong>em:表示父元素的字号的倍数。(特例：在 text-indent 属性中，表示文字宽度)</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> body             →font-size:20px;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>   → font-size:2em;</span><br><span class="line">box1</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>  → font-size:2em;</span><br><span class="line">	box2</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span>  → font-size:2em;</span><br><span class="line">    	box3</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-89af7dfeb2b2c401?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="得到结果"></p>
<p>em 为单位的时候，font-size 属性是计算后继承，box1 计算出来是 40px。那么里面的 box2继承的是 40px。<strong>em 单位不仅仅可以用来设置字号，还可以设置任何盒模型的属性，比如 width、height、padding、margin、border</strong></p>
<p><strong>rem 有一点优势就是可以和媒体查询配合，实现响应式布局：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">320px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">14px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">360px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">16px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">400px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">18px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运用场景</p>
</blockquote>
<p>如果我们做的 H5 页面只在移动端访问，这是因为 REM 不兼容低版本的浏览器。而如果移动端和 PC 端公用一套代码，建议使用流式布局。</p>
<blockquote>
<p>如何做个 REM 响应式布局</p>
</blockquote>
<p><strong>1、从 UI 设计师拿到 PSD 设计稿,然后在样式中给 HTML 设定一个 font-size 的值，我们一般都设置一个方便后面计算的值，例如：100px</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">  font-size:100px;//1rem=100px</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2、写页面，写样式</strong><br>首先按照设计稿的尺寸来写样式，然后在写样式值的时候，需要把得到的像素值除以 100 计算出对应的 REM 的值。<br>值得注意的是：真实项目中外层盒子的宽度我们一般还是不写固定值，沿用流式布局法的思想，我们用百分比的方式布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin</span>:<span class="number">0</span>  <span class="number">0.2rem</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">3rem</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3、根据当前屏幕的宽度和设计稿的宽度来计算我们 HTML 的 font-size 的值</strong><br>例如：设计稿宽度为 640px,其中有一个部分是轮播图，它的尺寸是 600*300，在样式中给 HTML 设定一个 font-size 的值为 100px,则轮播图大小应该为 6rem×3rem，那如果手机屏幕宽度为 375px,其 font-size 应该设置为多少。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">375/640*100-&gt;fontsize=58.59375//此时轮播图能自适应手机屏幕大小</span><br></pre></td></tr></table></figure>

<p><strong>根据当前屏幕宽度和设计稿宽度的比例，动态计算一下当前宽度下的 fontsize 值应该是多少，如果 fontsize 的值改变了，之前设定的所有 REM 单位的值自动会跟着放大或者缩小</strong>。可以通过以下这段代码实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> desW=<span class="number">640</span>,</span></span><br><span class="line"><span class="javascript">winW=<span class="built_in">document</span>.documentElement.clientwidth,</span></span><br><span class="line"><span class="javascript">ratio=winW/desW;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.documentElement.style.fontSize=ratio*<span class="number">100</span>+<span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="javascript">&#125;();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但如果当前屏幕宽度大于设计稿宽度，图片会被拉长而失真，所以以上代码需要稍微做些修改：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//html部分</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">//js部分</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">~function()&#123;</span><br><span class="line">var desW=640,</span><br><span class="line">winW=document.documentElement.clientwidth,</span><br><span class="line">ratio=winW/desW;</span><br><span class="line">var oMain=document.getElementById(main&quot;)；</span><br><span class="line">if(winW&gt;desW)&#123;</span><br><span class="line">oMain.style.width=desW+&quot;px&quot;;</span><br><span class="line">oMain.style.margin=&quot;0 auto&quot;;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">document.documentElement.style.fontSize=ratio*100+&quot;px&quot;;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>响应式</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>this关键字详解(JavaScript)</title>
    <url>/2018/10/14/sdo5sd8s/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>this关键字是JavaScript中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数的作用域中。对于那些没有投入时间学习this机制的JavaScript开发者来说，this的绑定一直是一件非常令人困惑的事。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-7da713b01b0f0829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="二、了解this"><a href="#二、了解this" class="headerlink" title="二、了解this"></a>二、了解this</h2><p><strong>学习this的第一步是明白this既不指向函数自身也不指向函数的词法作用域</strong>，你也许被这样的解释误导过，但其实它们都是错误的。随着函数使用场合的不同，this的值会发生变化。但总有一条原则就是<strong>JS中的this代表的是当前行为执行的主体</strong>，在JS中主要研究的都是函数中的this，但并不是说只有在函数里才有this，<strong>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用</strong>。如何的区分this呢？</p>
<h2 id="三、this到底是谁"><a href="#三、this到底是谁" class="headerlink" title="三、this到底是谁"></a>三、this到底是谁</h2><p>这要分情况讨论，常见有五种情况：</p>
<h3 id="1、函数执行时首先看函数名前面是否有”-”，有的话，”-”前面是谁-this就是谁；没有的话this就是window"><a href="#1、函数执行时首先看函数名前面是否有”-”，有的话，”-”前面是谁-this就是谁；没有的话this就是window" class="headerlink" title="1、函数执行时首先看函数名前面是否有”.”，有的话，”.”前面是谁,this就是谁；没有的话this就是window"></a>1、函数执行时首先看函数名前面是否有”.”，有的话，”.”前面是谁,this就是谁；没有的话this就是window</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">fn</span>:fn&#125;;</span><br><span class="line">fn();<span class="comment">//this-&gt;window</span></span><br><span class="line">obj.fn();<span class="comment">//this-&gt;obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     fn();<span class="comment">//this-&gt;window</span></span><br><span class="line">&#125;</span><br><span class="line">sum();</span><br><span class="line"><span class="keyword">var</span> oo=&#123;</span><br><span class="line"> <span class="attr">sum</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//this-&gt;oo</span></span><br><span class="line">       fn()；<span class="comment">//this-&gt;window</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">oo.sum();</span><br></pre></td></tr></table></figure>

<h3 id="2、自执行函数中的this永远是window"><a href="#2、自执行函数中的this永远是window" class="headerlink" title="2、自执行函数中的this永远是window"></a>2、自执行函数中的this永远是window</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//this-&gt;window &#125;)();</span></span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//this-&gt;window &#125;();</span></span><br></pre></td></tr></table></figure>

<h3 id="3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素，除了IE6-8下使用attachEvent（IE一个著名的bug）"><a href="#3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素，除了IE6-8下使用attachEvent（IE一个著名的bug）" class="headerlink" title="3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素，除了IE6~8下使用attachEvent（IE一个著名的bug）"></a>3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素，除了IE6~8下使用attachEvent（IE一个著名的bug）</h3><ul>
<li>  DOM零级事件绑定</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//this-&gt;oDiv</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>  DOM二级事件绑定</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//this-&gt;oDiv</span></span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>  在IE6~8下使用attachEvent，默认的this就是指的window对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.attachEvent(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">//this-&gt;window</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们大多数时候，遇到事件绑定，如下面例子这种，对于IE6~8下使用attachEvent不必太较真</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>).onclick=fn;<span class="comment">//fn中的this就是#divl</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>).onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//this-&gt;#div1</span></span><br><span class="line">fn();<span class="comment">//this-&gt;window</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h3 id="4、在构造函数模式中，类中-函数体中-出现的this-xxx-xxx中的this是当前类的一个实例"><a href="#4、在构造函数模式中，类中-函数体中-出现的this-xxx-xxx中的this是当前类的一个实例" class="headerlink" title="4、在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例"></a>4、在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateJsPerson</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="comment">//浏览器默认创建的对象就是我们的实例p1-&gt;this</span></span><br><span class="line"><span class="built_in">this</span>.name=name;<span class="comment">//-&gt;p1.name=name</span></span><br><span class="line"><span class="built_in">this</span>.age=age;</span><br><span class="line"><span class="built_in">this</span>.writeJs=<span class="function"><span class="keyword">function</span>（）</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;my name is&quot;</span>+<span class="built_in">this</span>.name +<span class="string">&quot;,i can write Js&quot;</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="comment">//浏览器再把创建的实例默认的进行返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> CreateJsPerson(<span class="string">&quot;尹华芝&quot;</span>,<span class="number">48</span>);</span><br></pre></td></tr></table></figure>

<p>必须要注意一点：<strong>类中某一个属性值(方法)，方法中的this需要看方法执行的时候，前面是否有”.”,才能知道this是谁</strong>。大家不妨看下接下来的这个例子，就可明白是啥意思。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.x=<span class="number">100</span>；<span class="comment">//this-&gt;f1</span></span><br><span class="line"><span class="built_in">this</span>.getX=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.x);<span class="comment">//this-&gt;需要看getX执行的时候才知道</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1=<span class="keyword">new</span> Fn;</span><br><span class="line">f1.getX();<span class="comment">//-&gt;方法中的this是f1，所以f1.x=100</span></span><br><span class="line"><span class="keyword">var</span> ss=f1.getX;</span><br><span class="line">ss();<span class="comment">//-&gt;方法中的this是window -&gt;undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="5-call、apply和bind"><a href="#5-call、apply和bind" class="headerlink" title="5.call、apply和bind"></a>5.call、apply和bind</h3><p>我们先来看一个问题，想在下面的例子中this绑定obj,怎么实现？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>:<span class="string">&quot;浪里行舟&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//this=&gt;window</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">obj.fn();<span class="comment">//-&gt;Uncaught TypeError:obj.fn is not a function</span></span><br></pre></td></tr></table></figure>

<p>如果直接绑定obj.fn(),程序就会报错。这里我们应该用fn.call(obj)就可以实现this绑定obj,接下来我们详细介绍下call方法：</p>
<ul>
<li>  <strong>call方法的作用:</strong></li>
</ul>
<p><strong>①首先我们让原型上的call方法执行，在执行call方法的时候，我们让fn方法中的this变为第一个参数值obj；然后再把fn这个函数执行。</strong></p>
<p><strong>②call还可以传值，在严格模式下和非严格模式下，得到值不一样。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在非严格模式下</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>:<span class="string">&quot;浪里行舟 &quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(num1+num2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn.call(<span class="number">100</span>,<span class="number">200</span>);<span class="comment">//this-&gt;100 num1=200 num2=undefined</span></span><br><span class="line">fn.call(obj,<span class="number">100</span>,<span class="number">200</span>);<span class="comment">//this-&gt;obj num1=100 num2=200</span></span><br><span class="line">fn.call();<span class="comment">//this-&gt;window</span></span><br><span class="line">fn.call(<span class="literal">null</span>);<span class="comment">//this-&gt;window</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>);<span class="comment">//this-&gt;window</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//严格模式下 </span></span><br><span class="line">fn.call();<span class="comment">//在严格模式下this-&gt;undefined</span></span><br><span class="line">fn.call(<span class="literal">null</span>);<span class="comment">// 在严格模式 下this-&gt;null</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>);<span class="comment">//在严格模式下this-&gt;undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>apply和call方法的作用是一模一样的，都是用来改变方法的this关键字并且把方法<br>  执行，而且在严格模式下和非严格模式下对于第一个参数是null/undefined这种情况的规<br>  律也是一样的。</strong></li>
</ul>
<p>两者唯一的区别：call在给fn传递参数的时候，是一个个的传递值的，而apply不是一个个传，而是把要给fn传递的参数值统一的放在一个数组中进行操作。但是也相当子一个个的给fn的形参赋值。<strong>总结一句话:call第二个参数开始接受一个参数列表,apply第二个参数开始接受一个参数数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj,<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">fn.apply(obj,[<span class="number">100</span>,<span class="number">200</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>bind：这个方法在IE6～8下不兼容，和call/apply类似都是用来改变this关键字的</strong>，但是和这两者有明显区别：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//-&gt;改变this和执行fn函数是一起都完成了</span></span><br><span class="line">fn.bind(obj,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//-&gt;只是改变了fn中的this为obj，并且给fn传递了两个参数值1、2，</span></span><br><span class="line">                     但是此时并没有把fn这个函数执行</span><br><span class="line"><span class="keyword">var</span> tempFn=fn.bind(obj,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">tempFn(); <span class="comment">//这样才把fn这个函数执行</span></span><br></pre></td></tr></table></figure>

<p><strong>bind体现了预处理思想：事先把fn的this改变为我们想要的结果，并且把对应的参数值也准备好，以后要用到了，直接的执行即可。</strong></p>
<p><strong>call和apply直接执行函数，而bind需要再一次调用。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;</span><br><span class="line">      <span class="attr">name</span> : <span class="string">&quot;Cherry&quot;</span>,</span><br><span class="line">      <span class="attr">fn</span> : <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log( a + b)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b.bind(a,<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-521e048b0cfefa1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上述代码没有执行，bind返回改变了上下文的一个函数，我们必须要手动去调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">b.bind(a,<span class="number">1</span>,<span class="number">2</span>)() <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p><strong>必须要声明一点：遇到第五种情况（call apply和bind),前面四种全部让步。</strong></p>
<h2 id="四、箭头函数this指向"><a href="#四、箭头函数this指向" class="headerlink" title="四、箭头函数this指向"></a>四、箭头函数this指向</h2><p>箭头函数正如名称所示那样使用一个“箭头”(=&gt;)来定义函数的新语法，但它优于传统的函数,主要体现两点：<strong>更简短的函数并且不绑定this</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.birth; <span class="comment">// this指向window或undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，箭头函数完全修复了this的指向，<strong>箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this</strong>。</p>
<p>换句话说，<strong>箭头函数的this看外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>测试箭头函数this_1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>测试箭头函数this_2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">   </span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> obj = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">age</span>: <span class="number">39</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            btn1.onclick = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//obj</span></span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    obj.getName();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-4a9944d597a4ba4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上例中，由于箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。其实可以简化为如下代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span><br><span class="line">     <span class="keyword">let</span> obj = &#123;</span><br><span class="line">         <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">         <span class="attr">age</span>: <span class="number">39</span>,</span><br><span class="line">         <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">obj.getName();</span><br></pre></td></tr></table></figure>

<p>那假如上一层并不存在函数，this指向又是谁？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>测试箭头函数this_1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>测试箭头函数this_2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">   </span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> btn2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> obj = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">age</span>: <span class="number">39</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">getName</span>: <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            btn2.onclick = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    obj.getName();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-1ab98cd1d45cc459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上例中，虽然存在两个箭头函数，其实this取决于最外层的箭头函数,由于obj是个对象而非函数，所以this指向为Window对象</p>
<p>由于this在箭头函数中已经按照词法作用域绑定了，所以，<strong>用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params">year</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function">(<span class="params">y</span>) =&gt;</span> y - <span class="built_in">this</span>.birth; <span class="comment">// this.birth仍是1990</span></span><br><span class="line">        <span class="keyword">return</span> fn.call(&#123;<span class="attr">birth</span>:<span class="number">2000</span>&#125;, year);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(<span class="number">2018</span>); <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>


<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://juejin.cn/post/6844903496253177863">this、apply、call、bind</a></p>
<p><a href="https://juejin.cn/post/6844903573428371464">JS中的箭头函数与this</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1031549578462080">箭头函数</a></p>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>关键字 - JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器存储</title>
    <url>/2018/10/14/ssd5y6we/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着移动网络的发展与演化，我们手机上现在除了有原生 App，还能跑“WebApp”——它即开即用，用完即走。一个优秀的 WebApp 甚至可以拥有和原生 App 媲美的功能和体验。WebApp 优异的性能表现，有一部分原因要归功于浏览器存储技术的提升。cookie存储数据的功能已经很难满足开发所需，逐渐被WebStorage、IndexedDB所取代，本文将介绍这几种存储方式的差异和优缺点。</p>
<h2 id="一、Cookie"><a href="#一、Cookie" class="headerlink" title="一、Cookie"></a>一、Cookie</h2><h3 id="1-Cookie的来源"><a href="#1-Cookie的来源" class="headerlink" title="1.Cookie的来源"></a>1.Cookie的来源</h3><p><strong>Cookie 的本职工作并非本地存储，而是“维持状态”</strong>。<br>因为<strong>HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存</strong>，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了Cookie。它就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。</p>
<p>我们可以把Cookie 理解为一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。</p>
<p>在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p>
<h3 id="2-什么是Cookie及应用场景"><a href="#2-什么是Cookie及应用场景" class="headerlink" title="2.什么是Cookie及应用场景"></a>2.什么是Cookie及应用场景</h3><p><strong>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储</strong>。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的set-cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/88a1801d209eabf4b1db25fed4ab204c.png"></p>
<p>如上图所示，<strong>Cookie 以键值对的形式存在</strong>。</p>
<p>典型的应用场景有：</p>
<ul>
<li><p>  记住密码，下次自动登录。</p>
</li>
<li><p>  购物车功能。</p>
</li>
<li><p>  记录用户浏览数据，进行商品（广告）推荐。</p>
</li>
</ul>
<h3 id="3-Cookie的原理及生成方式"><a href="#3-Cookie的原理及生成方式" class="headerlink" title="3.Cookie的原理及生成方式"></a>3.Cookie的原理及生成方式</h3><p>Cookie的原理<br><img src="https://img-blog.csdnimg.cn/img_convert/c897430d72b08689ed182f9f18f89654.png"></p>
<p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie信息发送给服务器，服务端会辨别用户身份，另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p>
<p>Cookie的生成方式主要有两种：</p>
<ul>
<li>  生成方式一：http response header中的set-cookie</li>
</ul>
<p>我们可以通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2018</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT;<span class="comment">//可以指定一个特定的过期时间（Expires）或有效期（Max-Age）</span></span><br></pre></td></tr></table></figure>

<p>当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</p>
<ul>
<li>  生成方式二：js中可以通过document.cookie可以读写cookie，以键值对的形式展示</li>
</ul>
<p>例如我们在掘金社区控制台输入以下三句代码，便可以在Chrome 的 Application 面板查看生成的cookie:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie=&quot;userName=hello&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie=&quot;gender=male&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie=&#x27;age=20;domain=.baidu.com&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/367a3e55cd823fa8c6490a8bbe3d47f8.png"></p>
<p>从上图中我们可以得出：</p>
<p><strong>Domain 标识指定了哪些域名可以接受Cookie</strong>。如果没有设置domain，就会自动绑定到执行语句的当前域。<br>如果设置为”.baidu.com”,则所有以”baidu.com”结尾的域名都可以访问该Cookie，所以在掘金社区上读取不到第三条代码存储Cookie值。</p>
<h3 id="4-Cookie的缺陷"><a href="#4-Cookie的缺陷" class="headerlink" title="4.Cookie的缺陷"></a>4.Cookie的缺陷</h3><ul>
<li>  Cookie 不够大</li>
</ul>
<p>Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。此外很多浏览器对一个站点的cookie个数也是有限制的。</p>
<p>这里需注意：各浏览器的cookie每一个<code>name=value</code>的value值大概在4k，所以4k并不是一个域名下所有的cookie共享的,而是一个name的大小。</p>
<ul>
<li>  过多的 Cookie 会带来巨大的性能浪费</li>
</ul>
<p>Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。</p>
<p>cookie是用来维护用户信息的，而域名(domain)下所有请求都会携带cookie，但对于静态文件的请求，携带cookie信息根本没有用，此时可以通过cdn（存储静态文件的）的域名和主站的域名分开来解决。</p>
<ul>
<li>  由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。</li>
</ul>
<h3 id="5-Cookie与安全"><a href="#5-Cookie与安全" class="headerlink" title="5.Cookie与安全"></a>5.Cookie与安全</h3><p>对于 cookie 来说，我们还需要注意安全性。<br><img src="https://img-blog.csdnimg.cn/img_convert/c2b2ddaa96d796e5305a99a1d826ef0a.png"></p>
<p>HttpOnly 不支持读写，浏览器不允许脚本操作document.cookie去更改cookie，<br>所以为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>

<p>标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p>
<p>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。</p>
<p><strong>HTML5中新增了本地存储的解决方案—-Web Storage，它分成两类：sessionStorage和localStorage</strong>。这样有了WebStorage后，cookie能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。</p>
<h2 id="二、LocalStorage"><a href="#二、LocalStorage" class="headerlink" title="二、LocalStorage"></a>二、LocalStorage</h2><h3 id="1-LocalStorage的特点"><a href="#1-LocalStorage的特点" class="headerlink" title="1.LocalStorage的特点"></a>1.LocalStorage的特点</h3><ul>
<li>  保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。</li>
<li>  大小为5M左右</li>
<li>  仅在客户端使用，不和服务端进行通信</li>
<li>  接口封装较好</li>
</ul>
<p>基于上面的特点，LocalStorage可以作为浏览器本地缓存方案，用来提升网页首屏渲染速度(根据第一请求返回时，将一些不变信息直接存储在本地)。</p>
<h3 id="2-存入-读取数据"><a href="#2-存入-读取数据" class="headerlink" title="2.存入/读取数据"></a>2.存入/读取数据</h3><p>localStorage保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。<br>存入数据使用setItem方法。它接受两个参数，第一个是键名，第二个是保存的数据。<br><code>localStorage.setItem(&quot;key&quot;,&quot;value&quot;);</code><br>读取数据使用getItem方法。它只有一个参数，就是键名。<br><code>var valueLocal = localStorage.getItem(&quot;key&quot;);</code></p>
<p>具体步骤，请看下面的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">if(window.localStorage)&#123;</span><br><span class="line">  localStorage.setItem（&#x27;name&#x27;,&#x27;world&#x27;）</span><br><span class="line">  localStorage.setItem（“gender&#x27;,&#x27;female&#x27;）</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> name=<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;name&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> gender=<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;gender&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;name&#x27;</span>).innerHTML=name</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;gender&#x27;</span>).innerHTML=gender</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3.使用场景"></a>3.使用场景</h3><p>LocalStorage在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 LocalStorage 来做。</p>
<p>这里给大家举个例子，考虑到 LocalStorage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：<br><img src="https://img-blog.csdnimg.cn/img_convert/d08269c01185f35b26be3750c8be86f2.png"></p>
<h2 id="三、sessionStorage"><a href="#三、sessionStorage" class="headerlink" title="三、sessionStorage"></a>三、sessionStorage</h2><p>sessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，<strong>即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享</strong>；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage的属性和方法与LocalStorage完全一样。</p>
<h3 id="1-sessionStorage的特点"><a href="#1-sessionStorage的特点" class="headerlink" title="1.sessionStorage的特点"></a>1.sessionStorage的特点</h3><ul>
<li>  会话级别的浏览器存储</li>
<li>  大小为5M左右</li>
<li>  仅在客户端使用，不和服务端进行通信</li>
<li>  接口封装较好</li>
</ul>
<p>基于上面的特点，sessionStorage 可以有效对表单信息进行维护，比如刷新时，表单信息不丢失。</p>
<h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h3><p>sessionStorage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 sessionStorage就主要是存储你本次会话的浏览足迹：<br><img src="https://img-blog.csdnimg.cn/img_convert/766e8aa98048064132011e2f3683bcd1.png"></p>
<p>lasturl 对应的就是你上一次访问的 URL 地址，这个地址是即时的。当你切换 URL 时，它随之更新，当你关闭页面时，留着它也确实没有什么意义了，干脆释放吧。这样的数据用 sessionStorage 来处理再合适不过。</p>
<h3 id="3-sessionStorage-、localStorage-和-cookie-之间的区别"><a href="#3-sessionStorage-、localStorage-和-cookie-之间的区别" class="headerlink" title="3.sessionStorage 、localStorage 和 cookie 之间的区别"></a>3.sessionStorage 、localStorage 和 cookie 之间的区别</h3><ul>
<li>  共同点：都是保存在浏览器端，且都遵循同源策略。</li>
<li>  不同点：在于生命周期与作用域的不同</li>
</ul>
<p>作用域：localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下<br><img src="https://img-blog.csdnimg.cn/img_convert/30482461b261171ee843eb9f98c6b30d.png"></p>
<p>生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</p>
<p>Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——<strong>它只能存储字符串</strong>，要想得到对象，我们还需要先对字符串进行一轮解析。</p>
<p>说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！</p>
<h2 id="四、IndexedDB"><a href="#四、IndexedDB" class="headerlink" title="四、IndexedDB"></a>四、IndexedDB</h2><p>IndexedDB 是一种低级API，**用于客户端存储大量结构化数据(包括文件和blobs)**。该API使用索引来实现对该数据的高性能搜索。IndexedDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。</p>
<h3 id="1-IndexedDB的特点"><a href="#1-IndexedDB的特点" class="headerlink" title="1.IndexedDB的特点"></a>1.IndexedDB的特点</h3><ul>
<li>  键值对储存。</li>
</ul>
<p>IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
<ul>
<li>  异步</li>
</ul>
<p>IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
<ul>
<li>  支持事务。</li>
</ul>
<p>IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
<ul>
<li>  同源限制</li>
</ul>
<p>IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
<ul>
<li>  储存空间大</li>
</ul>
<p>IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>
<ul>
<li>  支持二进制储存。</li>
</ul>
<p>IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>
<h3 id="2-IndexedDB的常见操作"><a href="#2-IndexedDB的常见操作" class="headerlink" title="2.IndexedDB的常见操作"></a>2.IndexedDB的常见操作</h3><p>在IndexedDB大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求——响应的模式。</p>
<ul>
<li>  建立打开IndexedDB —-<code>window.indexedDB.open(&quot;testDB&quot;)</code></li>
</ul>
<p>这条指令并不会返回一个DB对象的句柄，我们得到的是一个<code>IDBOpenDBRequest</code>对象，而我们希望得到的DB对象在其result属性中<br><img src="https://img-blog.csdnimg.cn/img_convert/a442775ca09c62b34a95977420a6a14d.png"></p>
<p>除了result，IDBOpenDBRequest接口定义了几个重要属性:</p>
<p>onerror: 请求失败的回调函数句柄</p>
<p>onsuccess:请求成功的回调函数句柄</p>
<p>onupgradeneeded:请求数据库版本变化句柄</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">openDB</span>(<span class="params">name</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> request=<span class="built_in">window</span>.indexedDB.open(name)<span class="comment">//建立打开IndexedDB</span></span></span><br><span class="line"><span class="javascript">request.onerror=<span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">&#x27;open indexdb error&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">request.onsuccess=<span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">myDB.db=e.target.result<span class="comment">//这是一个 IDBDatabase对象，这就是IndexedDB对象</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(myDB.db)<span class="comment">//此处就可以获取到db实例</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myDB=&#123;</span></span><br><span class="line"><span class="javascript"><span class="attr">name</span>:<span class="string">&#x27;testDB&#x27;</span>,</span></span><br><span class="line"><span class="javascript"><span class="attr">version</span>:<span class="string">&#x27;1&#x27;</span>,</span></span><br><span class="line"><span class="javascript"><span class="attr">db</span>:<span class="literal">null</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">openDB(myDB.name)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台得到一个 IDBDatabase对象，这就是IndexedDB对象<br><img src="https://img-blog.csdnimg.cn/img_convert/07eb89f08b4feb1b018735dc77e3f75a.png"></p>
<ul>
<li>  关闭IndexedDB—-<code>indexdb.close()</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function closeDB(db)&#123;</span><br><span class="line">    db.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  删除IndexedDB—-<code>window.indexedDB.deleteDatabase(indexdb)</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteDB</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  indexedDB.deleteDatabase(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-WebStorage、cookie-和-IndexedDB之间的区别"><a href="#3-WebStorage、cookie-和-IndexedDB之间的区别" class="headerlink" title="3.WebStorage、cookie 和 IndexedDB之间的区别"></a>3.WebStorage、cookie 和 IndexedDB之间的区别</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/3af7807f9d0222b50d94a1afa72070b9.png"></p>
<p>从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正是浏览器存储、缓存技术的出现和发展，为我们的前端应用带来了无限的转机。近年来基于存储、缓存技术的第三方库层出不绝，此外还衍生出了 PWA 这样优秀的 Web 应用模型。总结下本文几个核心观点：</p>
<ul>
<li>  Cookie 的本职工作并非本地存储，而是“维持状态”</li>
<li>  Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制，不与服务端发生通信</li>
<li>  IndexedDB 用于客户端存储大量结构化数据</li>
</ul>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li>  <a href="https://juejin.im/post/59d1f59bf265da06700b0934">把cookie聊清楚</a></li>
<li>  <a href="http://www.cnblogs.com/dolphinX/p/3415761.html">HTML5本地存储——IndexedDB（一：基本使用）</a></li>
<li>  <a href="http://jerryzou.com/posts/cookie-and-web-storage/">详说 Cookie, LocalStorage 与 SessionStorage</a></li>
<li>  <a href="https://juejin.im/book/5b936540f265da0a9624b04b/section/5ba5bb16f265da0ae92a6cfc">前端性能优化原理与实践</a></li>
<li>  <a href="https://juejin.im/post/5a9fcc5e51882555602074e3">localstorage 必知必会</a></li>
<li>  <a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html">浏览器数据库 IndexedDB 入门教程</a></li>
</ul>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>浏览器存储</tag>
      </tags>
  </entry>
</search>
