<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021面试题模拟</title>
    <url>/article/c8e8f511.html</url>
    <content><![CDATA[<h1 id="篇幅过大，正在分割"><a href="#篇幅过大，正在分割" class="headerlink" title="篇幅过大，正在分割"></a>篇幅过大，正在分割</h1><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试题总结</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>7个令人兴奋的 JavaScript 新特性</title>
    <url>/article/59cd89b4.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个ECMAScript标准的制作过程，包含了Stage 0到Stage 4 五个阶段，每个阶段提交至下一阶段都需要TC39审批通过。本文介绍这些新特性处于Stage 3 或者Stage 4 阶段，这意味着应该很快在浏览器和其他引擎中支持这些特性。</p>
<h2 id="一、类的私有变量"><a href="#一、类的私有变量" class="headerlink" title="一、类的私有变量"></a>一、类的私有变量</h2><p>最新提案之一是在类中添加私有变量的方法。我们将<strong>使用 # 符号表示类的私有变量</strong>。这样就不需要使用闭包来隐藏不想暴露给外界的私有变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  #x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  #<span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.#x++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">onClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.#increment();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Counter();</span><br><span class="line">c.onClick(); <span class="comment">// 正常</span></span><br><span class="line">c.#increment(); <span class="comment">// 报错 </span></span><br></pre></td></tr></table></figure>

<p>通过 # 修饰的成员变量或成员函数就成为了私有变量，如果试图在 Class 外部访问，则会抛出异常。现在，此特性可在最新版本的 Chrome 和 Node.js中使用。</p>
<h2 id="二、可选链操作符"><a href="#二、可选链操作符" class="headerlink" title="二、可选链操作符"></a>二、可选链操作符</h2><p>你可能碰到过这样的情形：当需要访问嵌套在对象内部好几层的属性时，会得到臭名昭著的错误<code>Cannot read property &#39;stop&#39; of undefined</code>,然后你就要修改你的代码来处理来处理属性链中每一个可能的undefined对象，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nestedProp = obj &amp;&amp; obj.first &amp;&amp; obj.first.second; </span><br></pre></td></tr></table></figure>

<p>在访问obj.first.second之前，obj和obj.first 的值要被确认非null(且不是undefined)。目的是为了防止错误发生，如果简单直接的访问obj.first.second而不对obj和obj.first 进行校验就有可能产生错误。</p>
<p>有了可选链式调用 ，你只要这样写就可以做同样的事情:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nestedProp = obj?.first?.second; </span><br></pre></td></tr></table></figure>

<p>如果obj或obj.first是null/undefined，表达式将会短路计算直接返回undefined。</p>
<h2 id="三、空位合并操作符"><a href="#三、空位合并操作符" class="headerlink" title="三、空位合并操作符"></a>三、空位合并操作符</h2><p>我们在开发过程中，经常会遇到这样场景：变量如果是空值，则就使用默认值，我们是这样实现的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = a ? a : b <span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">let</span> c = a || b <span class="comment">// 方式2 </span></span><br></pre></td></tr></table></figure>

<p>这两种方式有个明显的弊端，它都会覆盖所有的假值，如(0, ‘’, false)，这些值可能是在某些情况下有效的输入。</p>
<p>为了解决这个问题，有人提议创建一个“nullish”合并运算符，用 ?? 表示。<strong>有了它，我们仅在第一项为 null 或 undefined 时设置默认值</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = a ?? b;</span><br><span class="line"><span class="comment">// 等价于let c = a !== undefined &amp;&amp; a !== null ? a : b; </span></span><br></pre></td></tr></table></figure>

<p>例如有以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> y = x ?? <span class="number">500</span>;</span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// 500</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> m = n ?? <span class="number">9000</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m) <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure>

<h2 id="四、BigInt"><a href="#四、BigInt" class="headerlink" title="四、BigInt"></a>四、BigInt</h2><p>JS在Math上一直很糟糕的原因之一是，<strong>无法精确表示大于的数字2 ^ 53</strong>，这使得处理相当大的数字变得非常困难。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1234567890123456789</span> * <span class="number">123</span>;</span><br><span class="line"><span class="comment">// -&gt; 151851850485185200000 // 计算结果丢失精度 </span></span><br></pre></td></tr></table></figure>

<p>幸运的是，BigInt（大整数）就是来解决这个问题。你可以在BigInt上使用与普通数字相同的运算符，例如 +, -, /, *, %等等。</p>
<p>创建 BigInt 类型的值也非常简单，只需要在数字后面加上 n 即可。例如，123 变为 123n。也可以使用全局方法 BigInt(value) 转化，入参 value 为数字或数字字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aNumber = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">const</span> aBigInt = <span class="built_in">BigInt</span>(aNumber);</span><br><span class="line">aBigInt === <span class="number">111n</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> aBigInt === <span class="string">&#x27;bigint&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">111</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">111n</span> <span class="comment">// &quot;bigint&quot; </span></span><br></pre></td></tr></table></figure>

<p>只要在数字末尾加上 n，就可以正确计算大数了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1234567890123456789n</span> * <span class="number">123n</span>;</span><br><span class="line"><span class="comment">// -&gt; 151851850485185185047n </span></span><br></pre></td></tr></table></figure>

<p>不过有一个问题，在大多数操作中，不能将 BigInt与Number混合使用。比较Number和 BigInt是可以的，但是不能把它们相加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1n</span> &lt; <span class="number">2</span> </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1n</span> + <span class="number">2</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions </span></span><br></pre></td></tr></table></figure>

<p>现在，此特性可在最新版本的 Chrome 和 Node.js中使用。</p>
<h2 id="五、static-字段"><a href="#五、static-字段" class="headerlink" title="五、static 字段"></a>五、static 字段</h2><p>它允许类拥有静态字段，类似于大多数OOP语言。静态字段可以用来代替枚举，也可以用于私有字段。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colors</span> </span>&#123;</span><br><span class="line">  <span class="comment">// public static 字段</span></span><br><span class="line">  <span class="keyword">static</span> red = <span class="string">&#x27;#ff0000&#x27;</span>;</span><br><span class="line">  <span class="keyword">static</span> green = <span class="string">&#x27;#00ff00&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// private static 字段</span></span><br><span class="line">  <span class="keyword">static</span> #secretColor = <span class="string">&#x27;#f0f0f0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">font.color = Colors.red;</span><br><span class="line">font.color = Colors.#secretColor; <span class="comment">// 出错 </span></span><br></pre></td></tr></table></figure>

<p>现在，此特性可在最新版本的 Chrome 和 Node.js中使用。</p>
<h2 id="六、Top-level-await"><a href="#六、Top-level-await" class="headerlink" title="六、Top-level await"></a>六、Top-level await</h2><p>ES2017（ES8）中的 async/await 特性仅仅允许在 async 函数内使用 await 关键字，新的提案旨在允许 await 关键字在顶层内容中的使用，例如可以简化动态模块加载的过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> strings = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`/i18n/<span class="subst">$&#123;navigator.language&#125;</span>`</span>); </span><br></pre></td></tr></table></figure>

<p>这个特性在浏览器控制台中调试异步内容（如 fetch）非常有用，而无需将其包装到异步函数中。<br><img src="https://img-blog.csdnimg.cn/img_convert/c008f68d5aeb8b54d72ac351cd938f19.png"></p>
<p>另一个使用场景是，可以在以异步方式初始化的 ES 模块的顶层使用它(比如建立数据库连接)。当导入这样的“异步模块”时，模块系统将等待它被解析，然后再执行依赖它的模块。这种处理异步初始化方式比当前返回一个初始化promise并等待它解决来得更容易。一个模块不知道它的依赖是否异步。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// db.mjs</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> connection = <span class="keyword">await</span> createConnection(); </span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; connection &#125; <span class="keyword">from</span> <span class="string">&#x27;./db.mjs&#x27;</span>;</span><br><span class="line">server.start(); </span><br></pre></td></tr></table></figure>

<p>在此示例中，在server.mjs中完成连接之前不会执行任何操作db.mjs。</p>
<p>现在，此特性可在最新版本的 Chrome中使用。</p>
<h2 id="七、WeakRef"><a href="#七、WeakRef" class="headerlink" title="七、WeakRef"></a>七、WeakRef</h2><p>一般来说，在 JavaScript 中，对象的引用是强保留的，这意味着只要持有对象的引用，它就不会被垃圾回收。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = &#123; <span class="attr">x</span>: <span class="number">42</span>, <span class="attr">y</span>: <span class="number">51</span> &#125;;</span><br><span class="line"><span class="comment">// 只要我们访问 ref 对象（或者任何其他引用指向该对象），这个对象就不会被垃圾回收 </span></span><br></pre></td></tr></table></figure>

<p>目前在 Javascript 中，WeakMap 和 WeakSet 是弱引用对象的唯一方法：将对象作为键添加到 WeakMap 或 WeakSet 中，是不会阻止它被垃圾回收的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> metaData = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  wm.set(ref, metaData);</span><br><span class="line">  wm.get(ref);</span><br><span class="line">  <span class="comment">// 返回 metaData</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这个块范围内，我们已经没有对 ref 对象的引用。</span></span><br><span class="line"><span class="comment">// 因此，虽然它是 wm 中的键，我们仍然可以访问，但是它能够被垃圾回收。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(ref);</span><br><span class="line">ws.has(ref);<span class="comment">// 返回 true </span></span><br></pre></td></tr></table></figure>

<p><strong>JavaScript 的 WeakMap 并不是真正意义上的弱引用</strong>：实际上，只要键仍然存活，它就强引用其内容。WeakMap 仅在键被垃圾回收之后，才弱引用它的内容。</p>
<p>WeakRef 是一个更高级的 API，它提供了真正的弱引用，Weakref 实例具有一个方法 deref，该方法返回被引用的原始对象，如果原始对象已被收集，则返回undefined对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> setValue =  <span class="function">(<span class="params">key, obj</span>) =&gt;</span> &#123;</span><br><span class="line">  cache.set(key, <span class="keyword">new</span> WeakRef(obj));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getValue = <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = cache.get(key);</span><br><span class="line">  <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">    <span class="keyword">return</span> ref.deref();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will look for the value in the cache</span></span><br><span class="line"><span class="comment">// and recalculate if it&#x27;s missing</span></span><br><span class="line"><span class="keyword">const</span> fibonacciCached = <span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cached = getValue(number);</span><br><span class="line">  <span class="keyword">if</span> (cached) <span class="keyword">return</span> cached;</span><br><span class="line">  <span class="keyword">const</span> sum = calculateFibonacci(number);</span><br><span class="line">  setValue(number, sum);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>总而言之，JavaScript 中对象的引用是强引用，WeakMap 和 WeakSet 可以提供部分的弱引用功能，若想在 JavaScript 中实现真正的弱引用，可以通过配合使用 WeakRef 和终结器（Finalizer）来实现。</p>
<p>现在，此特性可在最新版本的 Chrome 和 Node.js中使用。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 如何居中一个元素</title>
    <url>/article/128f4bd1.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍水平居中，垂直居中，还有水平垂直居中各种办法，思维导图如下：<br><img src="https://upload-images.jianshu.io/upload_images/24295319-5b6d3d1b7b6708b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="一、水平居中"><a href="#一、水平居中" class="headerlink" title="一、水平居中"></a>一、水平居中</h2><h3 id="1-行内元素水平居中"><a href="#1-行内元素水平居中" class="headerlink" title="1.行内元素水平居中"></a>1.行内元素水平居中</h3><p><strong>利用 text-align: center 可以实现在块级元素内部的行内元素水平居中</strong>。此方法对inline、inline-block、inline-table和inline-flex元素水平居中都有效。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;//在父容器设置</span><br><span class="line">     <span class="attribute">text-align</span>:center;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此外，如果块级元素内部包着也是一个块级元素，<strong>我们可以先将其由块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>:center;  </span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-块级元素的水平居中"><a href="#2-块级元素的水平居中" class="headerlink" title="2.块级元素的水平居中"></a>2.块级元素的水平居中</h3><p>这种情形可以有多种实现方式，下面我们详细介绍:</p>
<h4 id="①将该块级元素左右外边距margin-left和margin-right设置为auto"><a href="#①将该块级元素左右外边距margin-left和margin-right设置为auto" class="headerlink" title="①将该块级元素左右外边距margin-left和margin-right设置为auto"></a>①将该块级元素左右外边距margin-left和margin-right设置为auto</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;//确保该块级元素定宽</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="②使用table-margin"><a href="#②使用table-margin" class="headerlink" title="②使用table+margin"></a>②使用table+margin</h4><p><strong>先将子元素设置为块级表格来显示（类似），再将其设置水平居中</strong></p>
<p><strong>display:table在表现上类似block元素，但是宽度为内容宽。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: table;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="③使用absolute-transform"><a href="#③使用absolute-transform" class="headerlink" title="③使用absolute+transform"></a>③使用absolute+transform</h4><p><strong>先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>:absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>:<span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">transform</span>:<span class="built_in">translateX</span>(-<span class="number">50%</span>);</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>不过transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀</strong>。</p>
<h4 id="④使用flex-justify-content"><a href="#④使用flex-justify-content" class="headerlink" title="④使用flex+justify-content"></a>④使用flex+justify-content</h4><p><strong>通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">    <span class="attribute">justify-content</span>:center;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="⑤使用flex-margin"><a href="#⑤使用flex-margin" class="headerlink" title="⑤使用flex+margin"></a>⑤使用flex+margin</h4><p><strong>通过flex将父容器设置为为Flex布局，再设置子元素居中。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>:<span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-多块级元素水平居中"><a href="#3-多块级元素水平居中" class="headerlink" title="3.多块级元素水平居中"></a>3.多块级元素水平居中</h3><p><img src="https://upload-images.jianshu.io/upload_images/24295319-e3f1ce64286b6a6c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="①利用flex布局"><a href="#①利用flex布局" class="headerlink" title="①利用flex布局"></a>①利用flex布局</h4><p><strong>利用弹性布局(flex)，实现水平居中，其中justify-content 用于设置弹性盒子元素在主轴（默认横轴）方向上的对齐方式</strong>，本例中设置子元素水平居中显示。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> <span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><a href="http://www.42du.cn/run/60">源代码演示</a></strong></p>
<h4 id="②利用inline-block"><a href="#②利用inline-block" class="headerlink" title="②利用inline-block"></a>②利用inline-block</h4><p><strong>将要水平排列的块状元素设为display:inline-block，然后在父级元素上设置text-align:center，达到与上面的行内元素的水平居中一样的效果</strong>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inline-block</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><a href="http://www.42du.cn/run/59">源代码演示</a></strong></p>
<h3 id="4-浮动元素水平居中"><a href="#4-浮动元素水平居中" class="headerlink" title="4.浮动元素水平居中"></a>4.浮动元素水平居中</h3><ul>
<li>  对于定宽的浮动元素，通过子元素设置relative + 负margin</li>
<li>  对于不定宽的浮动元素，父子容器都用相对定位</li>
<li>  通用方法(不管是定宽还是不定宽)：flex布局</li>
</ul>
<h4 id="①定宽的非浮动元素"><a href="#①定宽的非浮动元素" class="headerlink" title="①定宽的非浮动元素"></a>①定宽的非浮动元素</h4><p><strong>通过子元素设置relative + 负margin,原理见下图：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-ad6334027d038158?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><strong>注意：样式设置在浮动元素本身</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.child &#123;</span><br><span class="line">   position:relative;</span><br><span class="line">   left:50%;</span><br><span class="line">   margin-left:-250px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float: left;width: 500px;&quot;</span>&gt;</span>我是要居中的浮动元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="②不定宽的浮动元素"><a href="#②不定宽的浮动元素" class="headerlink" title="②不定宽的浮动元素"></a>②不定宽的浮动元素</h4><p>通过父子容器都相对定位，偏移位移见下图：<br><img src="https://upload-images.jianshu.io/upload_images/24295319-d351b2156269f8f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><strong>注意：要清除浮动，给外部元素加上float。这里的父元素就是外部元素</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是浮动的<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我也是居中的<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.box&#123;</span><br><span class="line">    float:left;</span><br><span class="line">    position:relative;</span><br><span class="line">    left:50%;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">    float:left;</span><br><span class="line">    position:relative;</span><br><span class="line">    right:50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="③通用办法flex布局-不管是定宽还是不定宽"><a href="#③通用办法flex布局-不管是定宽还是不定宽" class="headerlink" title="③通用办法flex布局(不管是定宽还是不定宽)"></a>③通用办法flex布局(不管是定宽还是不定宽)</h4><p><strong>利用弹性布局(flex)的<code>justify-content</code>属性，实现水平居中</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display:flex;</span><br><span class="line">    justify-content:center;</span><br><span class="line">&#125;</span><br><span class="line">.chlid&#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;//有无宽度不影响居中</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;chlid&quot;</span>&gt;</span>我是要居中的浮动元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-绝对定位元素水平居中"><a href="#5-绝对定位元素水平居中" class="headerlink" title="5.绝对定位元素水平居中"></a>5.绝对定位元素水平居中</h3><p>这种方式非常独特，<strong>通过子元素绝对定位，外加<code>margin: 0 auto</code>来实现</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>让绝对定位的元素水平居中对齐。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  .parent&#123;</span><br><span class="line">        position:relative;</span><br><span class="line">    &#125;</span><br><span class="line">   .child&#123;</span><br><span class="line">         position: absolute; /*绝对定位*/</span><br><span class="line">         width: 200px;</span><br><span class="line">         height:100px;</span><br><span class="line">         background: yellow;</span><br><span class="line">         margin: 0 auto; /*水平居中*/</span><br><span class="line">         left: 0; /*此处不能省略，且为0*/</span><br><span class="line">         right: 0;/*此处不能省略，且为0*/</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二、垂直居中"><a href="#二、垂直居中" class="headerlink" title="二、垂直居中"></a>二、垂直居中</h2><h3 id="1-单行内联元素垂直居中"><a href="#1-单行内联元素垂直居中" class="headerlink" title="1.单行内联元素垂直居中"></a>1.单行内联元素垂直居中</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span>&gt;</span>单行内联元素垂直居中。<span class="tag">&lt;/<span class="name">span</span>&gt;</span>。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"> <span class="selector-id">#box</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">line-height</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-多行内联元素垂直居中"><a href="#2-多行内联元素垂直居中" class="headerlink" title="2.多行内联元素垂直居中"></a>2.多行内联元素垂直居中</h3><h4 id="①利用flex布局（flex）"><a href="#①利用flex布局（flex）" class="headerlink" title="①利用flex布局（flex）"></a>①利用flex布局（flex）</h4><p><strong>利用flex布局实现垂直居中，其中flex-direction: column定义主轴方向为纵向</strong>。这种方式在较老的浏览器存在兼容性问题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Dance like nobody is watching, code like everybody is.    </span><br><span class="line">    Dance like nobody is watching, code like everybody is.    </span><br><span class="line">    Dance like nobody is watching, code like everybody is.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.parent</span> &#123; </span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">140px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">        <span class="attribute">flex-direction</span>: column;</span></span><br><span class="line"><span class="css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-5c0e188abb410abe?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="②利用表布局（table）"><a href="#②利用表布局（table）" class="headerlink" title="②利用表布局（table）"></a>②利用表布局（table）</h4><p><strong>利用表布局的vertical-align: middle可以实现子元素的垂直居中</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>The more technology you learn, the more you realize how little you know.</span><br><span class="line">    The more technology you learn, the more you realize how little you know.</span><br><span class="line">    The more technology you learn, the more you realize how little you know.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: table;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">140px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: table-cell;</span></span><br><span class="line"><span class="css">        <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-块级元素垂直居中"><a href="#3-块级元素垂直居中" class="headerlink" title="3 块级元素垂直居中"></a>3 块级元素垂直居中</h3><h4 id="①使用absolute-负margin-已知高度宽度"><a href="#①使用absolute-负margin-已知高度宽度" class="headerlink" title="①使用absolute+负margin(已知高度宽度)"></a>①使用absolute+负margin(已知高度宽度)</h4><p><strong>通过绝对定位元素距离顶部50%，并设置margin-top向上偏移元素高度的一半，就可以实现了</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>固定高度的块级元素垂直居中。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.parent &#123;</span><br><span class="line">position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">position: absolute;</span><br><span class="line">top: 50%;</span><br><span class="line">height: 100px;</span><br><span class="line">margin-top: -50px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="②使用absolute-transform"><a href="#②使用absolute-transform" class="headerlink" title="②使用absolute+transform"></a>②使用absolute+transform</h4><p><strong>当垂直居中的元素的高度和宽度未知时，可以借助CSS3中的transform属性向Y轴反向偏移50%的方法实现垂直居中</strong>。但是部分浏览器存在兼容性的问题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>未知高度的块级元素垂直居中。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.parent &#123;</span><br><span class="line">position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">position: absolute;</span><br><span class="line">top: 50%;</span><br><span class="line">transform: translateY(-50%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="③使用flex-align-items"><a href="#③使用flex-align-items" class="headerlink" title="③使用flex+align-items"></a>③使用flex+align-items</h4><p><strong>通过设置flex布局中的属性align-items，使子元素垂直居中</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>未知高度的块级元素垂直居中。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.parent &#123;</span><br><span class="line">    display:flex;</span><br><span class="line">    align-items:center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="④使用table-cell-vertical-align"><a href="#④使用table-cell-vertical-align" class="headerlink" title="④使用table-cell+vertical-align"></a>④使用table-cell+vertical-align</h4><p><strong>通过将父元素转化为一个表格单元格显示（类似 <code>&lt;td&gt;</code> 和 <code>&lt;th&gt;</code>），再通过设置 <code>vertical-align</code>属性，使表格单元格内容垂直居中。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: table-cell;</span></span><br><span class="line"><span class="css">    <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三、水平垂直居中"><a href="#三、水平垂直居中" class="headerlink" title="三、水平垂直居中"></a>三、水平垂直居中</h2><p>这种情形也是有多种实现方式，接下去我们娓娓道来：</p>
<h3 id="方法1：绝对定位与负边距实现（已知高度宽度）"><a href="#方法1：绝对定位与负边距实现（已知高度宽度）" class="headerlink" title="方法1：绝对定位与负边距实现（已知高度宽度）"></a>方法1：绝对定位与负边距实现（已知高度宽度）</h3><p><strong>这种方式需要知道被垂直居中元素的高和宽，才能计算出margin值，兼容所有浏览器</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// css部分</span><br><span class="line"> #container &#123;</span><br><span class="line">      position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"> #center &#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      top: 50%;</span><br><span class="line">      left: 50%;</span><br><span class="line">      margin: -50px 0 0 -50px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// html部分(这部分不做变化,下面例子直接共用)</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;container&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;center&#x27;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background-color: #666&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="方法2：绝对定位与margin-auto（已知高度宽度）"><a href="#方法2：绝对定位与margin-auto（已知高度宽度）" class="headerlink" title="方法2：绝对定位与margin:auto（已知高度宽度）"></a>方法2：绝对定位与margin:auto（已知高度宽度）</h3><p><strong>这种方式无需知道被垂直居中元素的高和宽，但不能兼容低版本的IE浏览器。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">     <span class="attribute">position</span>: relative;</span><br><span class="line">     <span class="attribute">height</span>:<span class="number">100px</span>;//必须有个高度</span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">     <span class="attribute">position</span>: absolute;</span><br><span class="line">     <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">margin</span>: auto;//注意此处的写法</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="方法3：绝对定位-CSS3-未知元素的高宽"><a href="#方法3：绝对定位-CSS3-未知元素的高宽" class="headerlink" title="方法3：绝对定位+CSS3(未知元素的高宽)"></a>方法3：绝对定位+CSS3(未知元素的高宽)</h3><p><strong>利用Css3的transform，可以轻松的在未知元素的高宽的情况下实现元素的垂直居中</strong>。<br>CSS3的transform固然好用，但在项目的实际运用中必须考虑兼容问题，大量的hack代码可能会导致得不偿失。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="方法4：flex布局"><a href="#方法4：flex布局" class="headerlink" title="方法4：flex布局"></a>方法4：flex布局</h3><p><strong>利用flex布局，其中justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式；而align-items属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。不能兼容低版本的IE浏览器。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;//直接在父容器设置即可</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">100vh</span>;//必须有高度</span><br><span class="line">   <span class="attribute">display</span>: flex;</span><br><span class="line">   <span class="attribute">justify-content</span>: center;</span><br><span class="line">   <span class="attribute">align-items</span>: center;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="方法5：flex-grid与margin-auto-最简单写法"><a href="#方法5：flex-grid与margin-auto-最简单写法" class="headerlink" title="方法5：flex/grid与margin:auto(最简单写法)"></a>方法5：flex/grid与margin:auto(最简单写法)</h3><p><strong>容器元素设为 flex 布局或是grid布局，子元素只要写 margin: auto 即可,不能兼容低版本的IE浏览器。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;//必须有高度</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-339b9f5730a392c6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>居中元素</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的垃圾回收和内存泄漏</title>
    <url>/article/7aead763.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存。所谓的内存泄漏简单来说是不再用到的内存，没有及时释放。为了更好避免内存泄漏，我们先介绍Javascript垃圾回收机制。</p>
<p>在C与C++等语言中，开发人员可以直接控制内存的申请和回收。但是在Java、C#、JavaScript语言中，变量的内存空间的申请和释放都由程序自己处理，开发人员不需要关心。也就是说Javascript具有自动垃圾回收机制(Garbage Collecation)。</p>
<h2 id="一、垃圾回收的必要性"><a href="#一、垃圾回收的必要性" class="headerlink" title="一、垃圾回收的必要性"></a>一、垃圾回收的必要性</h2><p>下面这段话引自《JavaScript权威指南（第四版）》</p>
<p>　　由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。<br><img src="https://img-blog.csdnimg.cn/img_convert/87858d461f51444303bd78963bee99ee.png"></p>
<p>这段话解释了为什么需要系统需要垃圾回收，JavaScript不像C/C++，它有自己的一套垃圾回收机制。</p>
<p>JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;浪里行舟&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;前端工匠&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> a = b; <span class="comment">//重写a </span></span><br></pre></td></tr></table></figure>

<p>这段代码运行之后，“浪里行舟”这个字符串失去了引用（之前是被a引用），系统检测到这个事实之后，就会释放该字符串的存储空间以便这些空间可以被再利用。</p>
<h2 id="二、垃圾回收机制"><a href="#二、垃圾回收机制" class="headerlink" title="二、垃圾回收机制"></a>二、垃圾回收机制</h2><p>垃圾回收机制怎么知道，哪些内存不再需要呢？</p>
<p>垃圾回收有两种方法：<strong>标记清除、引用计数</strong>。引用计数不太常用，标记清除较为常用。</p>
<h3 id="1-标记清除"><a href="#1-标记清除" class="headerlink" title="1.标记清除"></a>1.标记清除</h3><p><strong>这是javascript中最常用的垃圾回收方式</strong>。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。</p>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。<br><img src="https://img-blog.csdnimg.cn/img_convert/d88ad827e7fdc98608a845695734c3cc.gif"></p>
<p>我们用个例子，解释下这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">0</span>,n = <span class="number">19</span> <span class="comment">// 把 m,n,add() 标记为进入环境。</span></span><br><span class="line">add(m, n) <span class="comment">// 把 a, b, c标记为进入环境。</span></span><br><span class="line"><span class="built_in">console</span>.log(n) <span class="comment">// a,b,c标记为离开环境，等待垃圾回收。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  a++</span><br><span class="line">  <span class="keyword">var</span> c = a + b</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="2-引用计数"><a href="#2-引用计数" class="headerlink" title="2.引用计数"></a>2.引用计数</h3><p>所谓”引用计数”是指语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。<br><img src="https://img-blog.csdnimg.cn/img_convert/9fd8828ab6a3ff01f74a7714cc0586ed.png"><br>上图中，左下角的两个值，没有任何引用，所以可以释放。</p>
<p>如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;浪里行舟&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p>上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存。至于如何释放内存，我们下文介绍。</p>
<p>第三行代码中，数组[1, 2, 3, 4]引用的变量arr又取得了另外一个值，则数组[1, 2, 3, 4]的引用次数就减1，此时它引用次数变成0，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。</p>
<p>但是引用计数有个最大的问题： 循环引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    obj1.a = obj2; <span class="comment">// obj1 引用 obj2</span></span><br><span class="line">    obj2.a = obj1; <span class="comment">// obj2 引用 obj1</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。</p>
<p>要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空。上面的例子可以这么做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj1 = <span class="literal">null</span>;</span><br><span class="line">obj2 = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure>

<h2 id="三、哪些情况会引起内存泄漏？"><a href="#三、哪些情况会引起内存泄漏？" class="headerlink" title="三、哪些情况会引起内存泄漏？"></a>三、哪些情况会引起内存泄漏？</h2><p>虽然JavaScript会自动垃圾收集，但是如果我们的代码写法不当，会让变量一直处于“进入环境”的状态，无法被回收。下面列一下内存泄漏常见的几种情况：</p>
<h3 id="1-意外的全局变量"><a href="#1-意外的全局变量" class="headerlink" title="1.意外的全局变量"></a>1.意外的全局变量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>bar没被声明,会变成一个全局变量,在页面关闭之前不会被释放。</p>
<p>另一种意外的全局变量可能由 <code>this</code> 创建:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.variable = <span class="string">&quot;potential accidental global&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 调用自己，this 指向了全局对象（window）</span></span><br><span class="line">foo(); </span><br></pre></td></tr></table></figure>

<p>在 JavaScript 文件头部加上 ‘use strict’，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。</p>
<h3 id="2-被遗忘的计时器或回调函数"><a href="#2-被遗忘的计时器或回调函数" class="headerlink" title="2.被遗忘的计时器或回调函数"></a>2.被遗忘的计时器或回调函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = getData();</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;Node&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        <span class="comment">// 处理 node 和 someResource</span></span><br><span class="line">        node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>); </span><br></pre></td></tr></table></figure>

<p>这样的代码很常见，如果id为Node的元素从DOM中移除，该定时器仍会存在，同时，因为回调函数中包含对someResource的引用，定时器外面的someResource也不会被释放。</p>
<h3 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj=<span class="built_in">document</span>.createElement(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">  obj.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// Even if it is a empty function</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>闭包可以维持函数内局部变量，使其得不到释放。上例定义事件回调时，由于是函数内定义函数，并且内部函数–事件回调引用外部函数，形成了闭包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将事件处理函数定义在外面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">  obj.onclick = onclickHandler</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者在定义事件处理函数的外部函数中，删除对dom的引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">  obj.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Even if it is a empty function</span></span><br><span class="line">  &#125;</span><br><span class="line">  obj = <span class="literal">null</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>解决之道，将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对dom的引用。</p>
<h3 id="4-没有清理的DOM元素引用"><a href="#4-没有清理的DOM元素引用" class="headerlink" title="4.没有清理的DOM元素引用"></a>4.没有清理的DOM元素引用</h3><p>有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">    <span class="attr">button</span>: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;button&#x27;</span>),</span><br><span class="line">    <span class="attr">image</span>: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;image&#x27;</span>),</span><br><span class="line">    <span class="attr">text</span>: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    image.src = <span class="string">&#x27;http://some.url/image&#x27;</span>;</span><br><span class="line">    button.click();</span><br><span class="line">    <span class="built_in">console</span>.log(text.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;button&#x27;</span>));</span><br><span class="line">    <span class="comment">// 此时，仍旧存在一个全局的 #button 的引用</span></span><br><span class="line">    <span class="comment">// elements 字典。button 元素仍旧在内存中，不能被 GC 回收。</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>虽然我们用removeChild移除了button，但是还在elements对象里保存着#button的引用，换言之，DOM元素还在内存里面。</p>
<h2 id="四、内存泄漏的识别方法"><a href="#四、内存泄漏的识别方法" class="headerlink" title="四、内存泄漏的识别方法"></a>四、内存泄漏的识别方法</h2><p>新版本的chrome在 performance 中查看：<br><img src="https://img-blog.csdnimg.cn/img_convert/a2a8796ec29fd8f37c16a452dbb22d64.png"><br>步骤:</p>
<ul>
<li>  打开开发者工具 Performance</li>
<li>  勾选 Screenshots 和 memory</li>
<li>  左上角小圆点开始录制(record)</li>
<li>  停止录制</li>
</ul>
<p>图中 Heap 对应的部分就可以看到内存在周期性的回落也可以看到垃圾回收的周期,如果垃圾回收之后的最低值(我们称为min),min在不断上涨,那么肯定是有较为严重的内存泄漏问题。</p>
<p>避免内存泄漏的一些方式：</p>
<ul>
<li>  减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收</li>
<li>  注意程序逻辑，避免“死循环”之类的</li>
<li>  避免创建过多的对象</li>
</ul>
<p>总而言之需要遵循一条<strong>原则：不用了的东西要及时归还</strong></p>
<h2 id="五、垃圾回收的使用场景优化"><a href="#五、垃圾回收的使用场景优化" class="headerlink" title="五、垃圾回收的使用场景优化"></a>五、垃圾回收的使用场景优化</h2><h3 id="1-数组array优化"><a href="#1-数组array优化" class="headerlink" title="1.数组array优化"></a>1.数组array优化</h3><p>将[]赋值给一个数组对象，是清空数组的捷径(例如： arr = [];),但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;浪里行舟&#x27;</span>);</span><br><span class="line">arr.length = <span class="number">0</span>  <span class="comment">// 可以直接让数字清空，而且数组类型不变。</span></span><br><span class="line"><span class="comment">// arr = []; 虽然让a变量成一个空数组,但是在堆上重新申请了一个空数组对象。 </span></span><br></pre></td></tr></table></figure>

<h3 id="2-对象尽量复用"><a href="#2-对象尽量复用" class="headerlink" title="2. 对象尽量复用"></a>2. 对象尽量复用</h3><p>对象尽量复用，尤其是在循环等地方出现创建新对象，能复用就复用。不用的对象，尽可能设置为null，尽快被垃圾回收掉。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = &#123;&#125; <span class="comment">// 每次循环都会创建一个新对象。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// var t = &#123;&#125;;// 每次循环都会创建一个新对象。</span></span><br><span class="line">  t.age = <span class="number">19</span></span><br><span class="line">  t.name = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  t.index = i</span><br><span class="line">  <span class="built_in">console</span>.log(t)</span><br><span class="line">&#125;</span><br><span class="line">t = <span class="literal">null</span> <span class="comment">//对象如果已经不用了，那就立即设置为null；等待垃圾回收。 </span></span><br></pre></td></tr></table></figure>

<h3 id="3-在循环中的函数表达式，能复用最好放到循环外面。"><a href="#3-在循环中的函数表达式，能复用最好放到循环外面。" class="headerlink" title="3.在循环中的函数表达式，能复用最好放到循环外面。"></a>3.在循环中的函数表达式，能复用最好放到循环外面。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在循环中最好也别使用函数表达式。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">  <span class="keyword">var</span> t = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建了10次  函数对象。</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  t(k)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推荐用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">  t(k)</span><br><span class="line">&#125;</span><br><span class="line">t = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScriptDOM节点操作</title>
    <url>/article/1010e6c4.html</url>
    <content><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><blockquote>
<p>DOM ：文档对象模型</p>
<p>DMO是针对HTML文档的一个API（应用程序编程接口），DOM描绘了一个层次化的节点树，允许开发人员添加，删除，修改页面的某一部分。</p>
</blockquote>
<p>节点分为几种不同的类型 ：</p>
<blockquote>
<ul>
<li>Node类型</li>
<li>Document类型</li>
<li>Element类型</li>
<li>Text类型——文本类型</li>
<li>Comment类型 —— 注释类型</li>
</ul>
</blockquote>
<h2 id="二、类型的具体说明"><a href="#二、类型的具体说明" class="headerlink" title="二、类型的具体说明"></a>二、类型的具体说明</h2><p><strong>Node类型</strong></p>
<blockquote>
<p>属性：</p>
<p>1、<strong>nodeType</strong> ， 表示节点类型</p>
<p>规则：  1 –&gt;Element类型    3 –&gt;Text类型   8 –&gt;Comment类型   9 –&gt;Document类型</p>
<p>2、 <strong>childNodes</strong> ，表示子节点集合，可以使用slice方法将NodeList转换为数组</p>
<p><code>var arr = Array.prototype.slice.call(nodes,0);</code></p>
</blockquote>
<p> demo:       </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	    <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.childNodes);   <span class="comment">//获取所有子节点，包括各种类型的节点，返回NodeList类数组对象</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//将类数组对象转换为数组对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> tempArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.body.childNodes,<span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(tempArr);</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">        <span class="comment">//Text类型</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> texts = tempArr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">return</span> item.nodeType == <span class="number">3</span>;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(texts);</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">    <span class="comment">//Element类型</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> eles = tempArr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	    <span class="keyword">return</span> item.nodeType == <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(eles);</span></span><br><span class="line"><span class="javascript">    <span class="comment">//Comment类型</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> com = tempArr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">return</span> item.nodeType == <span class="number">8</span>;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(com);</span></span><br><span class="line"><span class="javascript">    <span class="comment">//Document类型</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> docu = tempArr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	    <span class="keyword">return</span> item.nodeType == <span class="number">9</span>;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(docu);</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    hello</span><br><span class="line">    <span class="comment">&lt;!-- 注释 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span>&gt;</span>world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    你好</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>​          <img src="../images/20180903142908498.png" alt="img">                     </p>
<blockquote>
<p>3、nodeName , 取决于节点类型，如果是元素类型，值为元素的标签名</p>
<p>4、nodeValue , 取决于节点类型，如果是元素类型，值为null</p>
<p>5、parentNode，指向文档树中的父节点</p>
<p>6、previousSibling，兄弟节点的前一个节点</p>
<p>7、nextSibling，兄弟节点的下一个节点</p>
<p>8、firstSibling，childsNode列表中的第一个节点</p>
<p> 9、ownerDocument，指向表示整个文档的文档节点</p>
<p>10、hasChildNodes，包含一个或多个节点时，返回true</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Node属性<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(<span class="built_in">document</span>.body.childNodes);  <span class="comment">//获取所有节点</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> childs = <span class="built_in">document</span>.body.childNodes;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(childs.length);</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(childs[<span class="number">3</span>].nodeName);     <span class="comment">//获取类数组对象中第三个节点的nodeName</span></span></span><br><span class="line"><span class="javascript">	<span class="comment">// 或者console.log(childs.item(0));</span></span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(childs[<span class="number">1</span>].nodeValue);   <span class="comment">//获取第一个节点的nodeValue</span></span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(childs[<span class="number">0</span>].parentNode);   <span class="comment">//指向文档树中的父节点</span></span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">	<span class="comment">//兄弟节点</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(childs[<span class="number">0</span>].nextSibling);     <span class="comment">//下一个兄弟</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(childs[<span class="number">4</span>].previousSibling); <span class="comment">//上一个兄弟</span></span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="built_in">document</span>.body.firstChild == childs[<span class="number">0</span>]);  <span class="comment">//第一个孩子节点</span></span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(childs[<span class="number">0</span>].ownerDocument);   <span class="comment">//任何节点都属于它所在的文档</span></span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="built_in">document</span>.body.hasChildNodes());  <span class="comment">//在包含一个或多个节点的情况下返回true</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(childs[<span class="number">0</span>].hasChildNodes());</span></span><br><span class="line"><span class="javascript">		</span></span><br><span class="line"><span class="javascript"> &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>                  </span><br><span class="line">    <span class="comment">&lt;!-- 注释 --&gt;</span></span><br><span class="line">    hello</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span>&gt;</span>world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    你好</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	one</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="../images/20180903151136900.png" alt="img"></p>
<p><strong>Node类型的操作节点</strong></p>
<p><strong>appendChild（）——  向childNodes列表末尾添加一个节点</strong>   </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>node节点操作<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">	    <span class="selector-class">.content</span>&#123;</span></span><br><span class="line"><span class="css">		<span class="attribute">border</span>:<span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="css">		<span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">	    &#125;</span></span><br><span class="line"><span class="css">	    <span class="selector-class">.content</span> &gt; <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">		<span class="attribute">width</span>:<span class="number">50px</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">		<span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">		<span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">	    &#125;</span></span><br><span class="line"><span class="css">	    <span class="selector-class">.content</span> <span class="selector-class">.two</span>&#123;</span></span><br><span class="line"><span class="css">		<span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="css">	    &#125;</span></span><br><span class="line"><span class="css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;one&#x27;</span>)[<span class="number">0</span>]; <span class="comment">//通过classname来获取元素</span></span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(div);</span></span><br><span class="line"><span class="javascript">	<span class="comment">//复制</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> newDiv = div.cloneNode(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>);  <span class="comment">//选中所有button元素</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(btns);</span></span><br><span class="line"><span class="javascript">            </span></span><br><span class="line"><span class="javascript">            <span class="comment">//添加点击效果</span></span></span><br><span class="line"><span class="javascript">	btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	        <span class="comment">//追加节点</span></span></span><br><span class="line"><span class="javascript">	        <span class="keyword">var</span> content = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;content&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">	        content.appendChild(newDiv);</span></span><br><span class="line"><span class="javascript">	    &#125;</span></span><br><span class="line"><span class="javascript">	&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>点击追加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span>&gt;</span>one<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span></span><br><span class="line">		two</span><br><span class="line">	    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>​      点击前：</p>
<p> <img src="../images/20180903152841575.png" alt="img"></p>
<p> 点击后： </p>
<p><img src="../images/20180903152816906.png" alt="img"></p>
<ul>
<li>insertBefore（）——第一个参数：要插入的节点，第二个参数：作为参照的节点</li>
<li>replaceChild（）——第一个参数：要插入的节点，第二个参数：要替换的节点</li>
<li>removeChild（）——一个参数，即要删除的节点</li>
<li>cloneNode（）——复制节点</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>node<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.content</span>&#123;</span></span><br><span class="line"><span class="css">	    <span class="attribute">border</span>:<span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="css">	    <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">	  &#125;</span></span><br><span class="line"><span class="css">	<span class="selector-class">.content</span> &gt; <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">	    <span class="attribute">width</span>:<span class="number">50px</span>;</span></span><br><span class="line"><span class="css">	    <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">	    <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">	    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">	    <span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">	  &#125;</span></span><br><span class="line"><span class="css">	 <span class="selector-class">.content</span> <span class="selector-class">.two</span>&#123;</span></span><br><span class="line"><span class="css">	    <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="css">	  &#125;</span></span><br><span class="line"><span class="css">	 <span class="selector-class">.content</span> <span class="selector-class">.three</span>&#123;</span></span><br><span class="line"><span class="css">	    <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">	  &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	    <span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="javascript">	    <span class="built_in">console</span>.log(btns);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> content = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;content&#x27;</span>)[<span class="number">0</span>];  </span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> newDiv = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;one&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="comment">//克隆one，要插入的节点</span></span></span><br><span class="line"><span class="javascript">    newDiv = newDiv.cloneNode(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">//粉色div，参考的节点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div3 = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;three&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">    <span class="comment">//插入节点</span></span></span><br><span class="line"><span class="javascript">    btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	    content.insertBefore(newDiv,div3);</span></span><br><span class="line"><span class="javascript">	&#125;</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">    <span class="comment">//替换节点</span></span></span><br><span class="line"><span class="javascript">    btns[<span class="number">1</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	    content.replaceChild(newDiv,div3);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"> </span></span><br><span class="line"><span class="javascript">    <span class="comment">//移除节点</span></span></span><br><span class="line"><span class="javascript">    btns[<span class="number">2</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">	    content.removeChild(div3);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span>&gt;</span>插入节点<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span>&gt;</span>替换节点<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span>&gt;</span>删除节点<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;three&quot;</span>&gt;</span>three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>点击前：</p>
<p><img src="../images/20180903153423227.png" alt="img"></p>
<p>点击“插入节点”：</p>
<p><img src="../images/20180903153453456.png" alt="img"></p>
<p>点击“替换节点”：</p>
<p><img src="../images/20180903153517141.png" alt="img"></p>
<p>点击“删除节点”：</p>
<p><img src="../images/20180903153541309.png" alt="img"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>节点操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/article/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>js事件循环机制</title>
    <url>/article/ad6fd215.html</url>
    <content><![CDATA[<p>先来明白些概念性内容。</p>
<h2 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h2><ul>
<li><strong>进程</strong>是系统分配的独立资源，是 CPU 资源分配的基本单位，进程是由一个或者多个线程组成的。</li>
<li><strong>线程</strong>是进程的执行流，是CPU调度和分派的基本单位，同个进程之中的多个线程之间是共享该进程的资源的。</li>
</ul>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>​        浏览器是多进程的，浏览器每一个 tab 标签都代表一个独立的进程（也不一定，因为多个空白 tab 标签会合并成一个进程），浏览器内核（浏览器渲染进程）属于浏览器多进程中的一种。</p>
<p>​        浏览器内核有多种线程在工作。</p>
<ol>
<li><p>GUI 渲染线程:</p>
<ul>
<li><p>负责渲染页面，解析 HTML，CSS 构成 DOM 树等，当页面重绘或者由于某种操作引起回流都会调起该线程。</p>
</li>
<li><p>和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。</p>
</li>
</ul>
</li>
<li><p>JS 引擎线程:</p>
<ul>
<li><p>单线程工作，负责解析运行 JavaScript 脚本。</p>
</li>
<li><p>和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。</p>
</li>
</ul>
</li>
<li><p>事件触发线程:</p>
<p>当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。</p>
</li>
<li><p>定时器触发线程:</p>
<ul>
<li><p>浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。</p>
</li>
<li><p>开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理。</p>
</li>
</ul>
</li>
<li><p>http 请求线程:</p>
<ul>
<li><p>请求的时候会开启一条请求线程。</p>
</li>
<li><p>请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 JS 引擎处理。</p>
</li>
</ul>
</li>
</ol>
<img src="/images/42146675.png" style="zoom:67%;" />

<h2 id="JavaScript-引擎是单线程"><a href="#JavaScript-引擎是单线程" class="headerlink" title="JavaScript 引擎是单线程"></a>JavaScript 引擎是单线程</h2><p>​        JavaScript 引擎是单线程，也就是说每次只能执行一项任务，其他任务都得按照顺序排队等待被执行，只有当前的任务执行完成之后才会往下执行下一个任务。</p>
<p>​        HTML5 中提出了 Web-Worker API，主要是为了解决页面阻塞问题，但是并没有改变 JavaScript 是单线程的本质。了解 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API">Web-Worker</a>。</p>
<h2 id="JavaScript-事件循环机制"><a href="#JavaScript-事件循环机制" class="headerlink" title="JavaScript 事件循环机制"></a>JavaScript 事件循环机制</h2><p>​        JavaScript 事件循环机制分为浏览器和 Node 事件循环机制，两者的实现技术不一样，浏览器 Event Loop 是 HTML 中定义的规范，Node Event Loop 是由 libuv 库实现。这里主要讲的是浏览器部分。</p>
<p>​        Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p>
<ul>
<li><p>JS 调用栈</p>
<p>JS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。</p>
</li>
<li><p>同步任务、异步任务</p>
<p>JavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。</p>
</li>
<li><p>Event Loop</p>
<p>调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。</p>
</li>
</ul>
<img src="/images/42146683.png" style="zoom:67%;" />

<img src="/images/42146690.png" style="zoom:67%;" />



<ul>
<li><p>定时器</p>
<p>定时器会开启一条定时器触发线程来触发计时，定时器会在等待了指定的时间后将事件放入到任务队列中等待读取到主线程执行。</p>
<p>定时器指定的延时毫秒数其实并不准确，因为定时器只是在到了指定的时间时将事件放入到任务队列中，必须要等到同步的任务和现有的任务队列中的事件全部执行完成之后，才会去读取定时器的事件到主线程执行，中间可能会存在耗时比较久的任务，那么就不可能保证在指定的时间执行。</p>
</li>
<li><p>宏任务(macro-task)、微任务(micro-task)</p>
<p>除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。</p>
<p>macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</p>
<p>micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>​    示例中，setTimeout 和 Promise被称为任务源，来自不同的任务源注册的回调函数会被放入到不同的任务队列中。</p>
<p>​        有了宏任务和微任务的概念后，那 JS 的执行顺序是怎样的？是宏任务先还是微任务先？</p>
<p>​        第一次事件循环中，JavaScript 引擎会把整个 script 代码当成一个宏任务执行，执行完成之后，再检测本次循环中是否寻在微任务，存在的话就依次从微任务的任务队列中读取执行完所有的微任务，再读取宏任务的任务队列中的任务执行，再执行所有的微任务，如此循环。JS 的执行顺序就是每次事件循环中的宏任务-微任务。</p>
<ul>
<li>上面的示例中，第一次事件循环，整段代码作为宏任务进入主线程执行。</li>
<li>遇到了 setTimeout ，就会等到过了指定的时间后将回调函数放入到宏任务的任务队列中。</li>
<li>遇到 Promise，将 then 函数放入到微任务的任务队列中。</li>
<li>整个事件循环完成之后，会去检测微任务的任务队列中是否存在任务，存在就执行。</li>
<li>第一次的循环结果打印为: 1,3,5,4。</li>
<li>接着再到宏任务的任务队列中按顺序取出一个宏任务到栈中让主线程执行，那么在这次循环中的宏任务就是 setTimeout 注册的回调函数，执行完这个回调函数，发现在这次循环中并不存在微任务，就准备进行下一次事件循环。</li>
<li>检测到宏任务队列中已经没有了要执行的任务，那么就结束事件循环。</li>
<li>最终的结果就是 1,3,5,4,2。</li>
</ul>
<p>后记</p>
</li>
</ul>
<hr>
<p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>事件循环机制</tag>
      </tags>
  </entry>
  <entry>
    <title>this关键字详解(JavaScript)</title>
    <url>/article/ffff4ce0.html</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>​        this关键字是JavaScript中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数的作用域中。对于那些没有投入时间学习this机制的JavaScript开发者来说，this的绑定一直是一件非常令人困惑的事。</p>
<img src="/images/this0.png" style="zoom:67%;" />


<h2 id="二、了解this"><a href="#二、了解this" class="headerlink" title="二、了解this"></a>二、了解this</h2><p>​        <strong>学习this的第一步是明白this既不指向函数自身也不指向函数的词法作用域</strong>，你也许被这样的解释误导过，但其实它们都是错误的。随着函数使用场合的不同，this的值会发生变化。但总有一条原则就是<strong>JS中的this代表的是当前行为执行的主体</strong>，在JS中主要研究的都是函数中的this，但并不是说只有在函数里才有this，<strong>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用</strong>。如何的区分this呢？</p>
<h2 id="三、this到底是谁"><a href="#三、this到底是谁" class="headerlink" title="三、this到底是谁"></a>三、this到底是谁</h2><p>​        这要分情况讨论，常见有五种情况：</p>
<h3 id="1、函数执行时首先看函数名前面是否有”-”，有的话，”-”前面是谁-this就是谁；没有的话this就是window"><a href="#1、函数执行时首先看函数名前面是否有”-”，有的话，”-”前面是谁-this就是谁；没有的话this就是window" class="headerlink" title="1、函数执行时首先看函数名前面是否有”.”，有的话，”.”前面是谁,this就是谁；没有的话this就是window"></a>1、函数执行时首先看函数名前面是否有”.”，有的话，”.”前面是谁,this就是谁；没有的话this就是window</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">fn</span>:fn&#125;;</span><br><span class="line">fn();<span class="comment">//this-&gt;window</span></span><br><span class="line">obj.fn();<span class="comment">//this-&gt;obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     fn();<span class="comment">//this-&gt;window</span></span><br><span class="line">&#125;</span><br><span class="line">sum();</span><br><span class="line"><span class="keyword">var</span> oo=&#123;</span><br><span class="line"> <span class="attr">sum</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//this-&gt;oo</span></span><br><span class="line">       fn()；<span class="comment">//this-&gt;window</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">oo.sum();</span><br></pre></td></tr></table></figure>

<h3 id="2、自执行函数中的this永远是window"><a href="#2、自执行函数中的this永远是window" class="headerlink" title="2、自执行函数中的this永远是window"></a>2、自执行函数中的this永远是window</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//this-&gt;window &#125;)();</span></span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//this-&gt;window &#125;();</span></span><br></pre></td></tr></table></figure>

<h3 id="3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素，除了IE6-8下使用attachEvent（IE一个著名的bug）"><a href="#3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素，除了IE6-8下使用attachEvent（IE一个著名的bug）" class="headerlink" title="3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素，除了IE6~8下使用attachEvent（IE一个著名的bug）"></a>3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素，除了IE6~8下使用attachEvent（IE一个著名的bug）</h3><ul>
<li>  DOM零级事件绑定</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//this-&gt;oDiv</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>  DOM二级事件绑定</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//this-&gt;oDiv</span></span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>  在IE6~8下使用attachEvent，默认的this就是指的window对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.attachEvent(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">//this-&gt;window</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​        我们大多数时候，遇到事件绑定，如下面例子这种，对于IE6~8下使用attachEvent不必太较真</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>).onclick=fn;<span class="comment">//fn中的this就是#divl</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>).onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//this-&gt;#div1</span></span><br><span class="line">fn();<span class="comment">//this-&gt;window</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h3 id="4、在构造函数模式中，类中-函数体中-出现的this-xxx-xxx中的this是当前类的一个实例"><a href="#4、在构造函数模式中，类中-函数体中-出现的this-xxx-xxx中的this是当前类的一个实例" class="headerlink" title="4、在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例"></a>4、在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateJsPerson</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="comment">//浏览器默认创建的对象就是我们的实例p1-&gt;this</span></span><br><span class="line"><span class="built_in">this</span>.name=name;<span class="comment">//-&gt;p1.name=name</span></span><br><span class="line"><span class="built_in">this</span>.age=age;</span><br><span class="line"><span class="built_in">this</span>.writeJs=<span class="function"><span class="keyword">function</span>（）</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;my name is&quot;</span>+<span class="built_in">this</span>.name +<span class="string">&quot;,i can write Js&quot;</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="comment">//浏览器再把创建的实例默认的进行返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> CreateJsPerson(<span class="string">&quot;尹华芝&quot;</span>,<span class="number">48</span>);</span><br></pre></td></tr></table></figure>

<p>​        必须要注意一点：<strong>类中某一个属性值(方法)，方法中的this需要看方法执行的时候，前面是否有”.”,才能知道this是谁</strong>。大家不妨看下接下来的这个例子，就可明白是啥意思。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.x=<span class="number">100</span>；<span class="comment">//this-&gt;f1</span></span><br><span class="line"><span class="built_in">this</span>.getX=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.x);<span class="comment">//this-&gt;需要看getX执行的时候才知道</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1=<span class="keyword">new</span> Fn;</span><br><span class="line">f1.getX();<span class="comment">//-&gt;方法中的this是f1，所以f1.x=100</span></span><br><span class="line"><span class="keyword">var</span> ss=f1.getX;</span><br><span class="line">ss();<span class="comment">//-&gt;方法中的this是window -&gt;undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="5-call、apply和bind"><a href="#5-call、apply和bind" class="headerlink" title="5.call、apply和bind"></a>5.call、apply和bind</h3><p>​        我们先来看一个问题，想在下面的例子中this绑定obj,怎么实现？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>:<span class="string">&quot;浪里行舟&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//this=&gt;window</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">obj.fn();<span class="comment">//-&gt;Uncaught TypeError:obj.fn is not a function</span></span><br></pre></td></tr></table></figure>

<p>​        如果直接绑定obj.fn(),程序就会报错。这里我们应该用fn.call(obj)就可以实现this绑定obj,接下来我们详细介绍下call方法：</p>
<ul>
<li>  <strong>call方法的作用:</strong></li>
</ul>
<p><strong>①首先我们让原型上的call方法执行，在执行call方法的时候，我们让fn方法中的this变为第一个参数值obj；然后再把fn这个函数执行。</strong></p>
<p><strong>②call还可以传值，在严格模式下和非严格模式下，得到值不一样。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在非严格模式下</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>:<span class="string">&quot;浪里行舟 &quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(num1+num2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn.call(<span class="number">100</span>,<span class="number">200</span>);<span class="comment">//this-&gt;100 num1=200 num2=undefined</span></span><br><span class="line">fn.call(obj,<span class="number">100</span>,<span class="number">200</span>);<span class="comment">//this-&gt;obj num1=100 num2=200</span></span><br><span class="line">fn.call();<span class="comment">//this-&gt;window</span></span><br><span class="line">fn.call(<span class="literal">null</span>);<span class="comment">//this-&gt;window</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>);<span class="comment">//this-&gt;window</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//严格模式下 </span></span><br><span class="line">fn.call();<span class="comment">//在严格模式下this-&gt;undefined</span></span><br><span class="line">fn.call(<span class="literal">null</span>);<span class="comment">// 在严格模式 下this-&gt;null</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>);<span class="comment">//在严格模式下this-&gt;undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>apply和call方法的作用是一模一样的，都是用来改变方法的this关键字并且把方法<br>执行，而且在严格模式下和非严格模式下对于第一个参数是null/undefined这种情况的规<br>律也是一样的。</strong></p>
<p>两者唯一的区别：call在给fn传递参数的时候，是一个个的传递值的，而apply不是一个个传，而是把要给fn传递的参数值统一的放在一个数组中进行操作。但是也相当子一个个的给fn的形参赋值。<strong>总结一句话:call第二个参数开始接受一个参数列表,apply第二个参数开始接受一个参数数组</strong></p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj,<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">fn.apply(obj,[<span class="number">100</span>,<span class="number">200</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>bind：这个方法在IE6～8下不兼容，和call/apply类似都是用来改变this关键字的</strong>，但是和这两者有明显区别：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//-&gt;改变this和执行fn函数是一起都完成了</span></span><br><span class="line">fn.bind(obj,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//-&gt;只是改变了fn中的this为obj，并且给fn传递了两个参数值1、2，</span></span><br><span class="line">                     但是此时并没有把fn这个函数执行</span><br><span class="line"><span class="keyword">var</span> tempFn=fn.bind(obj,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">tempFn(); <span class="comment">//这样才把fn这个函数执行</span></span><br></pre></td></tr></table></figure>

<p><strong>bind体现了预处理思想：事先把fn的this改变为我们想要的结果，并且把对应的参数值也准备好，以后要用到了，直接的执行即可。</strong></p>
<p><strong>call和apply直接执行函数，而bind需要再一次调用。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;</span><br><span class="line">      <span class="attr">name</span> : <span class="string">&quot;Cherry&quot;</span>,</span><br><span class="line">      <span class="attr">fn</span> : <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log( a + b)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b.bind(a,<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/this3.png"></p>
<p>​        上述代码没有执行，bind返回改变了上下文的一个函数，我们必须要手动去调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">b.bind(a,<span class="number">1</span>,<span class="number">2</span>)() <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>必须要声明一点：遇到第五种情况（call apply和bind),前面四种全部让步。</strong></p>
<h2 id="四、箭头函数this指向"><a href="#四、箭头函数this指向" class="headerlink" title="四、箭头函数this指向"></a>四、箭头函数this指向</h2><p>​        箭头函数正如名称所示那样使用一个“箭头”(=&gt;)来定义函数的新语法，但它优于传统的函数,主要体现两点：<strong>更简短的函数并且不绑定this</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.birth; <span class="comment">// this指向window或undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​        现在，箭头函数完全修复了this的指向，<strong>箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this</strong>。</p>
<p>​        换句话说，<strong>箭头函数的this看外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>测试箭头函数this_1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>测试箭头函数this_2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">   </span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> obj = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">age</span>: <span class="number">39</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            btn1.onclick = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//obj</span></span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    obj.getName();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/this4.png"></p>
<p>​        上例中，由于箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。其实可以简化为如下代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span><br><span class="line">     <span class="keyword">let</span> obj = &#123;</span><br><span class="line">         <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">         <span class="attr">age</span>: <span class="number">39</span>,</span><br><span class="line">         <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">obj.getName();</span><br></pre></td></tr></table></figure>

<p>​        那假如上一层并不存在函数，this指向又是谁？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>测试箭头函数this_1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>测试箭头函数this_2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">   </span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> btn2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> obj = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">age</span>: <span class="number">39</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">getName</span>: <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            btn2.onclick = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    obj.getName();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/images/this1.png"/>


<p>​        上例中，虽然存在两个箭头函数，其实this取决于最外层的箭头函数,由于obj是个对象而非函数，所以this指向为Window对象</p>
<p>​        由于this在箭头函数中已经按照词法作用域绑定了，所以，<strong>用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params">year</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function">(<span class="params">y</span>) =&gt;</span> y - <span class="built_in">this</span>.birth; <span class="comment">// this.birth仍是1990</span></span><br><span class="line">        <span class="keyword">return</span> fn.call(&#123;<span class="attr">birth</span>:<span class="number">2000</span>&#125;, year);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(<span class="number">2018</span>); <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>


<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>你应该了解的25个JS技巧</title>
    <url>/article/266349ec.html</url>
    <content><![CDATA[<p>写代码的时候总有一些东西是会重复出现的，次数多了你就会想找找捷径了。这类问题中有很大一部分解决起来甚至连库都不用装。下面就是我多年来收集的前 25 个捷径和小技巧。</p>
<h2 id="1-类型检查小工具"><a href="#1-类型检查小工具" class="headerlink" title="1. 类型检查小工具"></a>1. 类型检查小工具</h2><p>JavaScript 不是强类型语言，对此我推荐的最佳解决方案是 TypeScript。但有时你只是想要一个简单的类型检查，这种时候 JavaScript 允许你使用“typeof”关键字。</p>
<p>“typeof”的问题在于，将其用于某些原语和函数时效果很好，但对于数组和对象来说，由于它们都被视为“对象”，因此很难把握它们之间的区别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isOfType = (<span class="function">() =&gt;</span> &#123; </span><br><span class="line">   <span class="comment">// create a plain object with no prototype  </span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="built_in">Object</span>.create(<span class="literal">null</span>);  </span><br><span class="line">  <span class="comment">// check for null type  </span></span><br><span class="line">  type.null = <span class="function"><span class="params">x</span> =&gt;</span> x === <span class="literal">null</span>;  </span><br><span class="line">  <span class="comment">// check for undefined type  </span></span><br><span class="line">  type.undefined = <span class="function"><span class="params">x</span> =&gt;</span> x === <span class="literal">undefined</span>;  </span><br><span class="line">  <span class="comment">// check for nil type. Either null or undefined  </span></span><br><span class="line">  type.nil = <span class="function"><span class="params">x</span> =&gt;</span> type.null(x) || type.undefined(x);  </span><br><span class="line">  <span class="comment">// check for strings and string literal type. e.g: &#x27;s&#x27;, &quot;s&quot;, `str`, new String()  </span></span><br><span class="line">  type.string = <span class="function"><span class="params">x</span> =&gt;</span> !type.nil(x) &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> || x <span class="keyword">instanceof</span> <span class="built_in">String</span>); </span><br><span class="line">  <span class="comment">// check for number or number literal type. e.g: 12, 30.5, new Number()  </span></span><br><span class="line">  type.number = <span class="function"><span class="params">x</span> =&gt;</span> !type.nil(x)</span><br><span class="line">    &amp;&amp; (<span class="comment">// NaN &amp; Infinity have typeof &quot;number&quot; and this excludes that</span></span><br><span class="line">      (!<span class="built_in">isNaN</span>(x) &amp;&amp; <span class="built_in">isFinite</span>(x)</span><br><span class="line">      &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">    ) || x <span class="keyword">instanceof</span> <span class="built_in">Number</span>);</span><br><span class="line">  <span class="comment">// check for boolean or boolean literal type. e.g: true, false, new Boolean()</span></span><br><span class="line">  type.boolean = <span class="function"><span class="params">x</span> =&gt;</span> !type.nil(x) &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&#x27;boolean&#x27;</span> || x <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);</span><br><span class="line">  <span class="comment">// check for array type</span></span><br><span class="line">  type.array = <span class="function"><span class="params">x</span> =&gt;</span> !type.nil(x) &amp;&amp; <span class="built_in">Array</span>.isArray(x);</span><br><span class="line">  <span class="comment">// check for object or object literal type. e.g: &#123;&#125;, new Object(), Object.create(null)</span></span><br><span class="line">  type.object = <span class="function"><span class="params">x</span> =&gt;</span> (&#123;&#125;).toString.call(x) === <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line">  <span class="comment">// check for provided type instance</span></span><br><span class="line">  type.type = <span class="function">(<span class="params">x, X</span>) =&gt;</span> !type.nil(x) &amp;&amp; x <span class="keyword">instanceof</span> X;</span><br><span class="line">  <span class="comment">// check for set type</span></span><br><span class="line">  type.set = <span class="function"><span class="params">x</span> =&gt;</span> type.type(x, <span class="built_in">Set</span>);</span><br><span class="line">  <span class="comment">// check for map type</span></span><br><span class="line">  type.map = <span class="function"><span class="params">x</span> =&gt;</span> type.type(x, <span class="built_in">Map</span>);</span><br><span class="line">  <span class="comment">// check for date type</span></span><br><span class="line">  type.date = <span class="function"><span class="params">x</span> =&gt;</span> type.type(x, <span class="built_in">Date</span>);</span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="2-检查是否为空"><a href="#2-检查是否为空" class="headerlink" title="2. 检查是否为空"></a>2. 检查是否为空</h2><p>有时你需要知道某些内容是否为空，并根据结果决定要使用的方法，例如检查长度、大小或是否包含任何子元素。下面这个工具打包了这些功能，你可以用它检查 String、Object、Array、Map 和 Set 的大小。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmpty</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(x)</span><br><span class="line">    || <span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">    || x <span class="keyword">instanceof</span> <span class="built_in">String</span></span><br><span class="line">   ) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x <span class="keyword">instanceof</span> <span class="built_in">Map</span> || x <span class="keyword">instanceof</span> <span class="built_in">Set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.size === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>((&#123;&#125;).toString.call(x) === <span class="string">&#x27;[object Object]&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(x).length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-获取列表最后一项"><a href="#3-获取列表最后一项" class="headerlink" title="3. 获取列表最后一项"></a>3. 获取列表最后一项</h2><p>其他语言里这个功能被做成了可以在数组上调用的方法或函数，但在 JavaScript 里面，你得自己做点工作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function lastItem(list) &#123;</span><br><span class="line">  if(Array.isArray(list)) &#123;</span><br><span class="line">    return list.slice(-1)[0];</span><br><span class="line">  &#125;</span><br><span class="line">  if(list instanceof Set) &#123;</span><br><span class="line">    return Array.from(list).slice(-1)[0];</span><br><span class="line">  &#125;</span><br><span class="line">  if(list instanceof Map) &#123;</span><br><span class="line">    return Array.from(list.values()).slice(-1)[0];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-带有范围的随机数生成器"><a href="#4-带有范围的随机数生成器" class="headerlink" title="4. 带有范围的随机数生成器"></a>4. 带有范围的随机数生成器</h2><p>有时你需要生成随机数，但希望这些数字在一定范围内，那就可以用这个工具。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomNumber</span>(<span class="params">max = <span class="number">1</span>, min = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(min &gt;= max) &#123;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min) + min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-随机-ID-生成器"><a href="#5-随机-ID-生成器" class="headerlink" title="5. 随机 ID 生成器"></a>5. 随机 ID 生成器</h2><p>有时你只是需要一些 ID？除非你要的是更复杂的 ID 生成器（例如 UUID），否则用不着为此安装什么新库，下面这个选项足够了。你可以从当前时间（以毫秒为单位）或特定的整数和增量开始生成，也可以从字母生成 ID。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create unique id starting from current time in milliseconds</span></span><br><span class="line"><span class="comment">// incrementing it by 1 everytime requested</span></span><br><span class="line"><span class="keyword">const</span> uniqueId = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = (<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mil = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">yield</span> mil += <span class="number">1</span>;</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> id.next().value;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// create unique incrementing id starting from provided value or zero</span></span><br><span class="line"><span class="comment">// good for temporary things or things that id resets</span></span><br><span class="line"><span class="keyword">const</span> uniqueIncrementingId = (<span class="function">(<span class="params">lastId = <span class="number">0</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = (<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> numb = lastId;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">yield</span> numb += <span class="number">1</span>;</span><br><span class="line">  &#125;)()</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">length = <span class="number">12</span></span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;id.next().value&#125;</span>`</span>.padStart(length, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// create unique id from letters and numbers</span></span><br><span class="line"><span class="keyword">const</span> uniqueAlphaNumericId = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> heyStack = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyz&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> randomInt = <span class="function">() =&gt;</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="built_in">Math</span>.floor(heyStack.length))</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">length = <span class="number">24</span></span>) =&gt;</span> <span class="built_in">Array</span>.from(&#123;length&#125;, <span class="function">() =&gt;</span> heyStack[randomInt()]).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="6-创建一个范围内的数字"><a href="#6-创建一个范围内的数字" class="headerlink" title="6. 创建一个范围内的数字"></a>6. 创建一个范围内的数字</h2><p>Python 里我很喜欢的一个功能是 range 函数，而在 JavaScript 里我经常需要自己写这个功能。下面是一个简单的实现，非常适合 for…of 循环以及需要特定范围内数字的情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">maxOrStart, end = <span class="literal">null</span>, step = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!end) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: maxOrStart&#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(end &lt;= maxOrStart) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(step !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(</span><br><span class="line">      &#123;<span class="attr">length</span>: <span class="built_in">Math</span>.ceil(((end - maxOrStart) / step))&#125;,</span><br><span class="line">      <span class="function">(<span class="params">_, i</span>) =&gt;</span> (i * step) + maxOrStart    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(</span><br><span class="line">    &#123;<span class="attr">length</span>: <span class="built_in">Math</span>.ceil((end - maxOrStart))&#125;,</span><br><span class="line">    <span class="function">(<span class="params">_, i</span>) =&gt;</span> i + maxOrStart  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-格式化-JSON-字符串，stringify-任何内容"><a href="#7-格式化-JSON-字符串，stringify-任何内容" class="headerlink" title="7. 格式化 JSON 字符串，stringify 任何内容"></a>7. 格式化 JSON 字符串，stringify 任何内容</h2><p>我在使用 NodeJs 将对象记录到控制台时经常使用这种方法。JSON.stringify 方法需要第三个参数，该参数必须有多个空格以缩进行。第二个参数可以为 null，但你可以用它来处理 function、Set、Map、Symbol 之类 JSON.stringify 方法无法处理或完全忽略的内容。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0611adcb430efd540bf032db20961adf.png" alt="图片"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stringify = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> replacer = <span class="function">(<span class="params">key, val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> val.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val <span class="keyword">instanceof</span> <span class="built_in">Set</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.from(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val <span class="keyword">instanceof</span> <span class="built_in">Map</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.from(val.entries());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> val.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">obj, spaces = <span class="number">0</span></span>) =&gt;</span> <span class="built_in">JSON</span>.stringify(obj, replacer, spaces)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="8-顺序执行-promise"><a href="#8-顺序执行-promise" class="headerlink" title="8. 顺序执行 promise"></a>8. 顺序执行 promise</h2><p>如果你有一堆异步或普通函数都返回 promise，要求你一个接一个地执行，这个工具就会很有用。它会获取函数或 promise 列表，并使用数组 reduce 方法按顺序解析它们。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncSequentializer = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> toPromise = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123; <span class="comment">// if promise just return it</span></span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// if function is not async this will turn its result into a promise</span></span><br><span class="line">      <span class="comment">// if it is async this will await for the result</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">async</span> () =&gt; <span class="keyword">await</span> x())();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> results = [];</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">      .reduce(<span class="function">(<span class="params">lastPromise, currentPromise</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastPromise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          results.push(res); <span class="comment">// collect the results</span></span><br><span class="line">          <span class="keyword">return</span> toPromise(currentPromise);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, toPromise(list.shift()))</span><br><span class="line">      <span class="comment">// collect the final result and return the array of results as resolved promise</span></span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">Promise</span>.resolve([...results, res]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="9-轮询数据"><a href="#9-轮询数据" class="headerlink" title="9. 轮询数据"></a>9. 轮询数据</h2><p>如果你需要持续检查数据更新，但系统中没有 WebSocket，则可以使用这个工具来执行操作。它非常适合上传文件时，想要持续检查文件是否已完成处理的情况，或者使用第三方 API（例如 dropbox 或 uber）并且想要持续检查过程是否完成或骑手是否到达目的地的情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">poll</span>(<span class="params">fn, validate, interval = <span class="number">2500</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resolver = <span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// catch any error thrown by the &quot;fn&quot; function</span></span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> fn(); <span class="comment">// fn does not need to be asynchronous or return promise</span></span><br><span class="line">      <span class="comment">// call validator to see if the data is at the state to stop the polling</span></span><br><span class="line">      <span class="keyword">const</span> valid = validate(result);</span><br><span class="line">      <span class="keyword">if</span> (valid === <span class="literal">true</span>) &#123;</span><br><span class="line">        resolve(result);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valid === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolver, interval, resolve, reject);</span><br><span class="line">      &#125; <span class="comment">// if validator returns anything other than &quot;true&quot; or &quot;false&quot; it stops polling</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(resolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-等待所有-promise-完成"><a href="#10-等待所有-promise-完成" class="headerlink" title="10. 等待所有 promise 完成"></a>10. 等待所有 promise 完成</h2><p>这个算不上是代码解决方案，更多是对 Promise API 的强化。这个 API 在不断进化，以前我还为“allSettled”“race”和“any”做了代码实现，现在直接用 API 的就好了。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/91d89098df2229ede51a2187ac5ca110.png" alt="图片"></p>
<h2 id="11-交换数组值的位置"><a href="#11-交换数组值的位置" class="headerlink" title="11. 交换数组值的位置"></a>11. 交换数组值的位置</h2><p>ES6 开始，从数组中的不同位置交换值变得容易多了。这个做起来不难，但是了解一下也不错，</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/59c758f624cfb160a08508290be2b436.png" alt="图片"></p>
<h2 id="12-条件对象键"><a href="#12-条件对象键" class="headerlink" title="12. 条件对象键"></a>12. 条件对象键</h2><p>我最喜欢这条技巧了，我在使用 React 更新状态时经常用它。你可以将条件包装在括号中来有条件地将一个键插入一个 spread 对象。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/55b9f61e987a19ac9b860cca262e3b55.png" alt="图片"></p>
<h2 id="13-使用变量作为对象键"><a href="#13-使用变量作为对象键" class="headerlink" title="13. 使用变量作为对象键"></a>13. 使用变量作为对象键</h2><p>当你有一个字符串变量，并想将其用作对象中的键以设置一个值时可以用它。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a955207a9cd67ec5332fbf91d5a9ad05.png" alt="图片"></p>
<h2 id="14-检查对象里的键"><a href="#14-检查对象里的键" class="headerlink" title="14. 检查对象里的键"></a>14. 检查对象里的键</h2><p>这是一个很好的技巧，可以帮助你检查对象键。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8bd102862688949517a6c2ca2597ab8d.png" alt="图片"></p>
<h2 id="15-删除数组重复项"><a href="#15-删除数组重复项" class="headerlink" title="15. 删除数组重复项"></a>15. 删除数组重复项</h2><p>数组中经常有重复的值，你可以使用 Set 数据结构来消除它。它适用于许多数据类型，并且 set 有多种检查相等性的方法，很好用。对于不同实例或对象的情况，你还是可以使用 Set 来跟踪特定事物并过滤出重复的对象。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2569b6be0c2a2999995ef96bd1fbb90a.png" alt="图片"></p>
<h2 id="16-在-ArrayforEach-中执行“break”和“continue”"><a href="#16-在-ArrayforEach-中执行“break”和“continue”" class="headerlink" title="16. 在 ArrayforEach 中执行“break”和“continue”"></a>16. 在 ArrayforEach 中执行“break”和“continue”</h2><p>我真的很喜欢使用数组“.forEach”方法，但有时我需要提早退出或继续进行下一个循环，而不想用 for…loop。你可以复制“continue”语句行为来提前返回，但如果要复制“break”行为，则需要使用数组“.some”方法。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/25f6125f313d8d7728f92cda33f9751b.png" alt="图片"></p>
<h2 id="17-使用别名和默认值来销毁"><a href="#17-使用别名和默认值来销毁" class="headerlink" title="17. 使用别名和默认值来销毁"></a>17. 使用别名和默认值来销毁</h2><p>Destructuring（销毁）是 JavaScript 最好用的功能之一，而且你可以使用“冒号”设置别名，并使用“等号”设置属性默认值。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e68f0738c0a863104ea721c0046fbbce.png" alt="图片"></p>
<h2 id="18-可选链和空值合并"><a href="#18-可选链和空值合并" class="headerlink" title="18. 可选链和空值合并"></a>18. 可选链和空值合并</h2><p>深入检查对象属性并处理 null 和 undefined 值时，你可以使用几个非常好用的 JavaScript 功能来解决常见的问题。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7438d602e3d124d2fb28408b6952513f.png" alt="图片"></p>
<h2 id="19-用函数扩展类"><a href="#19-用函数扩展类" class="headerlink" title="19. 用函数扩展类"></a>19. 用函数扩展类</h2><p>我经常对别人讲，JavaScript 类只是构造函数和底层的原型，不是像 Java 中那样的真实概念。一个证据是，你可以只使用一个构造函数来扩展一个类。在私有内容里这个很好用，在类里“#”这些看着很奇怪，并且用于 babel 或 WebPack 时，编译出来的代码更少。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f4eccefa99d8557c0c70e630aa6ba18e.png" alt="图片"></p>
<h2 id="20-扩展构造函数"><a href="#20-扩展构造函数" class="headerlink" title="20. 扩展构造函数"></a>20. 扩展构造函数</h2><p>类的一个问题是你只能扩展一个其他类。使用构造函数，你可以使用多个构造函数来构成一个函数，这样就会灵活多了。你可以使用函数原型的.apply 或.call 方法来实现。你甚至可以只扩展函数的一部分，只要它是一个对象即可。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/175ef8a6f1e2f4ca268c6f5dcc9352d3.png" alt="图片"></p>
<h2 id="21-循环任何内容有时，你需要循环任何可迭代的内容（Set、Map、Object、Array、String-等）。这个非常简单的-forEach-函数工具就可以做到这一点。如果回调返回-true，它将退出循环。"><a href="#21-循环任何内容有时，你需要循环任何可迭代的内容（Set、Map、Object、Array、String-等）。这个非常简单的-forEach-函数工具就可以做到这一点。如果回调返回-true，它将退出循环。" class="headerlink" title="21. 循环任何内容有时，你需要循环任何可迭代的内容（Set、Map、Object、Array、String 等）。这个非常简单的 forEach 函数工具就可以做到这一点。如果回调返回 true，它将退出循环。"></a>21. 循环任何内容有时，你需要循环任何可迭代的内容（Set、Map、Object、Array、String 等）。这个非常简单的 forEach 函数工具就可以做到这一点。如果回调返回 true，它将退出循环。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">list, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> entries = <span class="built_in">Object</span>.entries(list);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> len = entries.length;</span><br><span class="line">  <span class="keyword">for</span>(;i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = callback(entries[i][<span class="number">1</span>], entries[i][<span class="number">0</span>], list);</span><br><span class="line">    <span class="keyword">if</span>(res === <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-使函数参数为-required"><a href="#22-使函数参数为-required" class="headerlink" title="22. 使函数参数为 required"></a>22. 使函数参数为 required</h2><p>这是一种确保函数调用了完成工作所需内容的绝佳方法。你可以使用默认参数值的特性来调用函数，然后就会抛出一个错误。如果调用该函数时带上了它需要的值，则该值将替换该函数，并且什么也不会发生。使用 undefined 调用也有相同的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">required</span>(<span class="params">argName = <span class="string">&#x27;param&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`&quot;<span class="subst">$&#123;argName&#125;</span>&quot; is required`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iHaveRequiredOptions</span>(<span class="params">arg1 = required(<span class="string">&#x27;arg1&#x27;</span>), arg2 = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg1, arg2)</span><br><span class="line">&#125;</span><br><span class="line">iHaveRequiredOptions(); <span class="comment">// throws &quot;arg1&quot; is required</span></span><br><span class="line">iHaveRequiredOptions(<span class="number">12</span>); <span class="comment">// prints 12, 10</span></span><br><span class="line">iHaveRequiredOptions(<span class="number">12</span>, <span class="number">24</span>); <span class="comment">// prints 12, 24</span></span><br><span class="line">iHaveRequiredOptions(<span class="literal">undefined</span>, <span class="number">24</span>); <span class="comment">// throws &quot;arg1&quot; is required</span></span><br></pre></td></tr></table></figure>

<h2 id="23-创建模块或单例"><a href="#23-创建模块或单例" class="headerlink" title="23. 创建模块或单例"></a>23. 创建模块或单例</h2><p>很多时候，你需要在加载时初始化某些内容，设置它需要的各种事物，然后就可以在应用程序中到处使用它，而无需再做什么补充工作。你可以使用 IIFE 函数来做到这一点，这个函数太好用了。这种模块模式用来隔离事物非常好用，它可以只暴露需要交互的内容。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4a56503a7a18f81c1b94a1c04e50bd2f.png" alt="图片"></p>
<h2 id="24-深度克隆对象开发人员通常会安装一些类似“lodash”的库来执行这一操作，但使用纯-JavaScript-来实现确实也很容易。这是一个简单的递归函数：只要是一个对象，就使用函数的构造器将其重新初始化为一个克隆，然后对所有属性重复该过程。"><a href="#24-深度克隆对象开发人员通常会安装一些类似“lodash”的库来执行这一操作，但使用纯-JavaScript-来实现确实也很容易。这是一个简单的递归函数：只要是一个对象，就使用函数的构造器将其重新初始化为一个克隆，然后对所有属性重复该过程。" class="headerlink" title="24. 深度克隆对象开发人员通常会安装一些类似“lodash”的库来执行这一操作，但使用纯 JavaScript 来实现确实也很容易。这是一个简单的递归函数：只要是一个对象，就使用函数的构造器将其重新初始化为一个克隆，然后对所有属性重复该过程。"></a>24. 深度克隆对象开发人员通常会安装一些类似“lodash”的库来执行这一操作，但使用纯 JavaScript 来实现确实也很容易。这是一个简单的递归函数：只要是一个对象，就使用函数的构造器将其重新初始化为一个克隆，然后对所有属性重复该过程。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> clone = obj;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    clone = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertyNames(obj).forEach(</span><br><span class="line">      <span class="function"><span class="params">prop</span> =&gt;</span> (clone[prop] = deepClone(obj[prop]))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="25-深度冻结对象"><a href="#25-深度冻结对象" class="headerlink" title="25. 深度冻结对象"></a>25. 深度冻结对象</h2><p>如果你喜欢不变性，那么这个工具你一定要常备。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> clone = obj;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    clone = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertyNames(obj).forEach(</span><br><span class="line">      <span class="function"><span class="params">prop</span> =&gt;</span> (clone[prop] = deepClone(obj[prop]))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<p>=======</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>9ab82a130755d45919864989ffac67033fab1a4e<br>后记</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Http协议，你必须要知道的</title>
    <url>/article/5dc57562.html</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/24295319-5be52089c8c8e23f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Http协议请求--响应"></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。HTTP 是基于 TCP/IP 协议通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-63940358e136b951?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本文框架图"></p>
<h2 id="一、Http的特点"><a href="#一、Http的特点" class="headerlink" title="一、Http的特点"></a>一、Http的特点</h2><p>1.<strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、PUT、DELETE、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>2.<strong>灵活</strong>：HTTP允许传输任意类型的数据对象。</p>
<p>3.<strong>无连接</strong>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>4.<strong>无状态</strong>：<strong>HTTP协议是无状态的，HTTP 协议自身不对请求和响应之间的通信状态进行保存。任何两次请求之间都没有依赖关系。</strong>直观地说，就是每个请求都是独立的，与前面的请求和后面的请求都是没有直接联系的。协议本身并不保留之前一切的请求或 响应报文的信息。<strong>这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-b3374ff38879d568?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP协议是无状态的"></p>
<h2 id="二、Http报文"><a href="#二、Http报文" class="headerlink" title="二、Http报文"></a>二、Http报文</h2><p>Http报文包括请求报文和响应报文两大部分，其中请求报文由请求行（request line）、请求头（header）、空行和请求体四个部分组成。而响应报文由状态行、响应头部、空行和响应体四个部分组成。接下来我们详细介绍下请求报文的各个部分及其作用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-e2ced9f403ef5d6b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求报文"></p>
<h3 id="1-请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本。"><a href="#1-请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本。" class="headerlink" title="1.请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本。"></a>1.请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST  /chapter17/user.html HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>以上代码中“POST ”代表请求方法，“/chapter17/user.html”表示URI，“HTTP/1.1”代表协议和协议的版本。现在比较流行的是Http1.1版本</p>
<h3 id="2-请求头由关键字-值对组成，每行一对，关键字和值用英文冒号“-”分隔。"><a href="#2-请求头由关键字-值对组成，每行一对，关键字和值用英文冒号“-”分隔。" class="headerlink" title="2.请求头由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。"></a>2.请求头由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。</h3><p>请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：<br><strong>Host，表示主机名，虚拟主机；<br>Connection,HTTP/1.1增加的，使用keepalive，即持久连接，一个连接可以发多个请求；<br>User-Agent，请求发出者，兼容性以及定制化需求。</strong></p>
<h3 id="3-最后一个请求头之后是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。"><a href="#3-最后一个请求头之后是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。" class="headerlink" title="3.最后一个请求头之后是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。"></a>3.最后一个请求头之后是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。</h3><h3 id="4-请求体，可以承载多个请求参数的数据"><a href="#4-请求体，可以承载多个请求参数的数据" class="headerlink" title="4.请求体，可以承载多个请求参数的数据"></a>4.请求体，可以承载多个请求参数的数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=tom&amp;password=1234&amp;realName=tomson</span><br></pre></td></tr></table></figure>

<p>上面代码，承载着name、password、realName三个请求参数。</p>
<h2 id="三、HTTP请求方法"><a href="#三、HTTP请求方法" class="headerlink" title="三、HTTP请求方法"></a>三、HTTP请求方法</h2><ul>
<li>  GET 请求指定的页面信息，并返回实体主体。</li>
<li>  HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
<li>  POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。</li>
<li>  PUT 从客户端向服务器传送的数据取代指定的文档的内容。</li>
<li>  DELETE 请求服务器删除指定的页面。</li>
</ul>
<h2 id="四、GET与POST区别"><a href="#四、GET与POST区别" class="headerlink" title="四、GET与POST区别"></a>四、GET与POST区别</h2><ul>
<li>  GET在浏览器回退时是无害的，而POST会再次提交请求</li>
<li>  GET请求会被浏览器主动缓存，而POST不会，除非手动设置</li>
<li>  GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</li>
<li>  GET请求在URL中传送的参数是有长度限制的，而POST没有限制</li>
<li>  GET参数通过URL传递，POST放在Request body中</li>
</ul>
<h2 id="五、Http状态码"><a href="#五、Http状态码" class="headerlink" title="五、Http状态码"></a>五、Http状态码</h2><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<ul>
<li>  1xx：指示信息–表示请求已接收，继续处理</li>
<li>  2xx：成功–表示请求已被成功接收、理解、接受</li>
<li>  3xx：重定向–要完成请求必须进行更进一步的操作</li>
<li>  4xx：客户端错误–请求有语法错误或请求无法实现</li>
<li>  5xx：服务器端错误–服务器未能实现合法的请求</li>
</ul>
<p>比如我们平时常见两种出错的状态码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">403 Forbidden                 //对被请求页面的访问被禁止</span><br><span class="line">404 Not Found                 //请求资源不存在，比如：输入了错误的URL</span><br></pre></td></tr></table></figure>

<h2 id="六、持久连接"><a href="#六、持久连接" class="headerlink" title="六、持久连接"></a>六、持久连接</h2><h3 id="1-为什么需要持久连接"><a href="#1-为什么需要持久连接" class="headerlink" title="1.为什么需要持久连接"></a>1.为什么需要持久连接</h3><p><strong>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接</strong>。以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使这样也没有多大问题。可随着 HTTP 的 普及，文档中包含大量图片的情况多了起来。比如，使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请 求该 HTML 页面里包含的其他资源。因此，<strong>每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的 开销。</strong><br><img src="https://upload-images.jianshu.io/upload_images/24295319-0839841677c2e8ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="2-持久连接的特点"><a href="#2-持久连接的特点" class="headerlink" title="2.持久连接的特点"></a>2.持久连接的特点</h3><p>为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，<strong>只要任意一端没有明确提出断开连接，则保持TCP连接状态。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-9bd34e0b2a4423f4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="建立 1 次 次 TCP 连接后进行多次请求和响应的交互"></p>
<p><strong>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外， 减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。</strong><br>在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并未标准化。虽然有一部分服务器通过非 标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需 要支持持久连接。</p>
<h2 id="七、管线化"><a href="#七、管线化" class="headerlink" title="七、管线化"></a>七、管线化</h2><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能 发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。<br><strong>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。通俗地讲，请求打包一次传输过去，响应打包一次传递回来。管线化的前提是在持久连接下。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-2a8342e5d430410b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不等待响应，直接发送下一个请求 "></p>
<p>假如当请求一个包含 10 张图片的 HTML Web 页面，<strong>与挨个连接相比，用持久连接可以让请求更快结束。 而管线化技术则比持久连接还要快</strong>。请求数越多，时间差就越明显。客户端需要请求这十个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求，以此类推，而管道机制则是允许浏览器同时发出这十个请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。<br>于是在使用持久连接的情况下，某个连接上消息的传递类似于</p>
<p><strong>请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3</strong></p>
<p>管线化方式发送变成了类似这样：</p>
<p><strong>请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3</strong></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title>关于三次握手与四次挥手</title>
    <url>/article/ce48f58c.html</url>
    <content><![CDATA[<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><blockquote>
<p>​      在面试中，三次握手和四次挥手可以说是问的最频繁的一个知识点了，我相信大家也都看过很多关于三次握手与四次挥手的博客，今天的这篇博客，重点是围绕着面试，我们应该掌握哪些比较重要的点，哪些是比较被面试官给问到的，我觉得如果你能把我下面列举的一些点都记住、理解，我想就差不多了。</p>
</blockquote>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>​        <strong>当面试官问你为什么需要有三次握手、三次握手的作用、讲讲三次三次握手的时候，我想很多人会这样回答：</strong></p>
<p>首先很多人会先讲下握手的过程：</p>
<ol>
<li><p>第一次握手：客户端给服务器发送一个 SYN 报文。</p>
</li>
<li><p>第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。</p>
</li>
<li><p>第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。</p>
</li>
<li><p>服务器收到 ACK 报文之后，三次握手建立完成。</p>
</li>
</ol>
<p><strong>作用是为了确认双方的接收与发送能力是否正常</strong>。</p>
<p>  <strong>这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以：</strong></p>
<blockquote>
<p> 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>      第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>      第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
</blockquote>
<p>​        因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
<p>​        这样回答其实也是可以的，但我觉得，这个过程的我们应该要描述的更<strong>详细一点</strong>，因为三次握手的过程中，双方是<strong>由很多状态的改变的</strong>，而这些状态，也是面试官可能会问的点。所以我觉得在回答三次握手的时候，我们应该要描述的详细一点，而且描述的详细一点意味着可以扯久一点。加分的描述我觉得应该是这样：</p>
<p>​        <strong>刚开始客户端处于 closed 的状态，服务端处于 listen 状态</strong>。然后</p>
<p>​        第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号<strong>ISN（c）</strong>。此时客户端处于<strong>SYN_Send</strong>状态。</p>
<p>​        第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于<strong>SYN_REVD</strong>的状态。</p>
<p>​        第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <strong>establised</strong>状态。</p>
<p>​        服务器收到 ACK 报文之后，也处于<strong>establised 状态</strong>，此时，双方以建立起了链接。</p>
<img src="../images/20191016090535256.png" alt="img" style="zoom:67%;" />

<h2 id="三次握手的作用"><a href="#三次握手的作用" class="headerlink" title="三次握手的作用"></a>三次握手的作用</h2><p>​        三次握手的作用也是有好多的，多记住几个，保证不亏。例如：</p>
<ol>
<li><p>确认双方的接受能力、发送能力是否正常。</p>
</li>
<li><p>指定自己的初始化序列号，为后面的可靠传送做准备。</p>
</li>
<li><p>如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</p>
<p>单单这样还不足以应付三次握手，面试官可能还会问一些其他的问题，例如：</p>
</li>
</ol>
<p><strong>（ISN）是固定的吗？</strong><br>      三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>
<p>​        <strong>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的</strong>。</p>
<p><strong>什么是半连接队列</strong><br>      服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<blockquote>
<p>​        这里在补充一点关于SYN-ACK 重传次数的问题：　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, …</p>
</blockquote>
<p><strong>三次握手过程中可以携带数据吗</strong><br>      很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p>
<p>为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。<br>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>​      <strong>四次挥手也一样，千万不要对方一个 FIN 报文，我方一个 ACK 报文，再我方一个 FIN 报文，我方一个 ACK 报文。然后结束，最好是说的详细一点，例如想下面这样就差不多了，要把每个阶段的状态记好。</strong></p>
<p>​        刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：</p>
<ol>
<li><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于<strong>FIN_WAIT1</strong>状态。</p>
</li>
<li><p>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于<strong>CLOSE_WAIT</strong>状态。</p>
</li>
<li><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于<strong>LAST_ACK</strong>的状态。</p>
</li>
<li><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于<strong>TIME_WAIT</strong>状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</p>
</li>
<li><p>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p>
<img src="../images/20191016091925872.png" alt="img" style="zoom:67%;" /></li>
</ol>
<p>​        这里特别需要主要的就是TIME_WAIT这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p>
<p>​        至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p>
<p>​        <strong>这里我给出每个状态所包含的含义，有兴趣的可以看看。</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">LISTEN - 侦听来自远方TCP端口的连接请求； </span><br><span class="line">SYN-SENT -在发送连接请求后等待匹配的连接请求； </span><br><span class="line">SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认； </span><br><span class="line">ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； </span><br><span class="line">FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</span><br><span class="line">FIN-WAIT-2 - 从远程TCP等待连接中断请求；</span><br><span class="line">CLOSE-WAIT - 等待从本地用户发来的连接中断请求； </span><br><span class="line">CLOSING -等待远程TCP对连接中断的确认； </span><br><span class="line">LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认； </span><br><span class="line">TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； </span><br><span class="line">CLOSED - 没有任何连接状态；</span><br></pre></td></tr></table></figure>

<p>​         <strong>最后，在放张三次握手与四次挥手的图</strong></p>
<img src="https://img-blog.csdnimg.cn/20190608160404569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RyZWFtaXNwb3NzaWJsZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title>关于响应式布局，你必须要知道的</title>
    <url>/article/4fb4f5da.html</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>响应式 Web 设计可以让一个网站同时适配多种设备和多个屏幕，可以让网站的布局和功能随用户的使用环境（屏幕大小、输入方式、设备/浏览器能力）而变化。本文主要介绍一些响应式布局容易忽略但又很重要的知识点。</p>
<h2 id="二、视口"><a href="#二、视口" class="headerlink" title="二、视口"></a>二、视口</h2><p><strong>移动前端中常说的 viewport （视口）就是浏览器中用于呈现网页的区域。视口通常并不等于屏幕大小，特别是可以缩放浏览器窗口的情况下</strong>。手机端与 PC 端视口存在差异，电脑端的视口宽度等于分辨率，而移动端的视口宽度跟分辨率没有关系,宽度默认值是设备厂家指定的。iOS, Android 基本都将这个视口分辨率设置为 980px。</p>
<h4 id="1-为什么手机端视口要设为-980px"><a href="#1-为什么手机端视口要设为-980px" class="headerlink" title="1.为什么手机端视口要设为 980px?"></a>1.为什么手机端视口要设为 980px?</h4><p>当年乔布斯设想：苹果手机如果在市场上火爆了，但是各个网站还没有来得及制作手机端网页，那么用户不得不用手机访问电脑版的网页，<strong>如何用小屏幕访问大屏幕的页面也同样可读呢</strong>？乔帮主就想着为手机固定一个视口宽度，让手机的视口宽度等于世界上绝大多数 PC 网页的版心宽度，就是 980px。这样，用手机访问电脑版网页的时候，旁边刚好没有留白。不过页面缩放后文字会变得非常小，用户需要手动放大缩小才能看清楚，体验非常差。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-61b9f61766c2cfc0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PC端页面在手机上显示效果"></p>
<h4 id="2-约束视口"><a href="#2-约束视口" class="headerlink" title="2.约束视口"></a>2.约束视口</h4><p>为了解决前面的问题，可以在网页的中添加下面这行代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">width=device-width   视口为设备宽度（就是人设置的一个宽度）//不设置的话默认为980px</span><br><span class="line">initial-scale=1.0    初始化的视口大小是1.0倍</span><br><span class="line">maximum-scale=1.0    最大的倍数是1.0倍</span><br><span class="line">user-scalable=0      不允许缩放视口</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个视口的标签告诉浏览器怎么渲染网页。在这里，标签想表达的意思是：按照设备的宽度（device-width）来渲染网页内容。事实上，在支持这个标签的设备上给你看一看效果，你就明白了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-aa0a7fa4ea5860a2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="约束视口后"></p>
<p>不错呀！用户体验大大改善！！！<br>此时如果用 document.documentElement.clientWidth 来测试浏览器屏幕宽度，你会发现当前视口宽度等于手机屏幕的宽度，约数后的视口宽度都是在 320~480 之间（手机竖直使用的时候）。<br>这个视口的尺寸，是手机厂商设置的，能够保证我们的文字比如 16px，在自己的这个视口下清晰、大小刚刚合适。所以<strong>大屏幕的手机的约束视口 &gt; 小屏幕手机的约束视口。这就能够保证我们的网页可以用 px 写字号、写行高</strong>。<br><strong>需要注意的是：约束之后的视口宽度，不是自己的分辨率！！每个手机的分辨率，都要比自己的视口宽度大得多得多！</strong></p>
<p><strong>最最重要的一句话：前端开发工程师，丝毫不关心手机的分辨率，我们只关心视口。</strong></p>
<h2 id="三、图片"><a href="#三、图片" class="headerlink" title="三、图片"></a>三、图片</h2><p>人们常说说“一图胜千言”，确实如此。我们网页中关于松饼的文字介绍再多，也没有图片有吸引力。下面我们就在页面上方添加一张松饼的图片（2000 像素宽），效果类似引诱用户往下看的大题图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-ffe488f2924e7dcf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加图片后"></p>
<p>哇，真是好大一张图，它让整个网页看起来都失衡了，水平方向上图片溢出了。不行，必须解决这个问题。可以用 CSS 给图片指定固定宽度，<strong>但问题是我们想让它能在不同大小的屏幕中自动缩放</strong>。比如，我们例子中的 iPhone 屏幕宽度为 320 像素，如果我们把图片设置成 320 像素宽，那么 iPhone 屏幕旋转后又怎么办呢？这时候 320 像素变成了 480 像素。<br>解决方案很简单，只要一行 CSS 代码就可以让图片随容器宽度自动缩放:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line"> <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回到手机上，刷新页面，结果比较符合预期了。<br>这里声明 max-width 规则，就是要保证所有图片最大显示为其自身的 100%（即最大只可以显示为自身那么大）。<strong>此时，如果包含图片的元素（比如包含图片的 body 或 div）比图片固有宽度小，图片会缩放占满最大可用空间</strong>。</p>
<h4 id="为什么不用-width-100"><a href="#为什么不用-width-100" class="headerlink" title="为什么不用 width:100%?"></a>为什么不用 width:100%?</h4><p>要实现图片的自动缩放，也可以使用更通用的 width 属性，比如 width:100%。然而，这条规则在这里并不适用。因为这条规则会导致它显示得跟它的容器一样宽。<strong>在容器比图片宽得多的情况下，图片会被无谓地拉伸。</strong></p>
<h2 id="四、手机浏览器内核"><a href="#四、手机浏览器内核" class="headerlink" title="四、手机浏览器内核"></a>四、手机浏览器内核</h2><p>在移动端，仅有四个独立的浏览器内核，分别为微软的 Trident、火狐的 Gecko、开源内核 Webkit、Opera 的 Presto。<br>目前微软的 Trident 在移动终端上主要为 WP7、8 系统内置浏览器。Opera 的 Presto 内核主要为 Opera Mobile、OperaMini、欧朋浏览器以及欧朋 HD Beta 版。<strong>Webkit 内核的适用范围则较为广泛，Android 原生浏览器、苹果的 Safari、谷歌 Chrome(Android4.0 使用)都是基于 Webkit 开源内核开发的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">兼容的前缀：</span><br><span class="line">1	-ms-</span><br><span class="line">2	-moz-</span><br><span class="line">3	-o-</span><br><span class="line">4	-webkit-</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>中国用户的浏览器市场份额：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-65700ebe6311e394?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="近一年中国用户的浏览器市场份额"></p>
<p>UC、Android 内置、Chrome、Safari、QQ Browser 都是 webkit 内核，从图上看占了绝大部分的市场份额。<br>所以一定要伺候好-webkit-。 有的公司干脆只兼容-webkit-，别的兼容比如-ms-都不写。</p>
<h2 id="五、流式布局"><a href="#五、流式布局" class="headerlink" title="五、流式布局"></a>五、流式布局</h2><p><strong>百分比布局也叫作流式布局、弹性盒布局。手机网页没有版心，都左右撑满。</strong></p>
<p><strong>百分比能够设置的属性是 width、height、padding、margin。其他属性比如 border、font-size 不能用百分比设置的。</strong></p>
<ul>
<li>  如果用百分比写 width，那么指的是父元素 width 的百分之多少。</li>
<li>  如果用百分比写 height，那么指的是父元素 height 的百分之多少。</li>
<li>  如果用百分比写 padding，那么指的是父元素 width 的百分之多少，无论是水平的 padding 还是竖直的 padding。</li>
<li>  如果用百分比写 margin，那么指的是父元素 width 的百分之多少，无论是水平的 margin 还是竖直的 margin。</li>
<li>  不能用百分比写 border 的宽度</li>
</ul>
<p>接下来我们看一个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">padding</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">padding</span>:<span class="number">10%</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">/*此时p的真实宽度是多少？*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-6cd6772e448675b0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p的盒模型图"></p>
<p>此时 p 的真实宽度是 140px*190px</p>
<h2 id="六、媒体查询"><a href="#六、媒体查询" class="headerlink" title="六、媒体查询"></a>六、媒体查询</h2><h4 id="1-为什么响应式-Web-设计需要媒体查询"><a href="#1-为什么响应式-Web-设计需要媒体查询" class="headerlink" title="1.为什么响应式 Web 设计需要媒体查询"></a>1.为什么响应式 Web 设计需要媒体查询</h4><p><strong>CSS3 媒体查询可以让我们针对特定的设备能力或条件为网页应用特定的 CSS 样式</strong>。如果没有媒体查询，光用 CSS 是无法大大修改网页外观的。这个模块让我们可以提前编写出适应很多不可预测因素的 CSS 规则，比如屏幕方向水平或垂直、视口或大或小等等。弹性布局虽然可以让设计适应较多场景，也包括某些尺寸的屏幕，但有时候确实不够用，因为我们还需要对布局进行更细致的调整。媒体查询让这一切成为可能，它就相当于 CSS 中基本的条件逻辑。</p>
<h4 id="2-媒体查询语法"><a href="#2-媒体查询语法" class="headerlink" title="2.媒体查询语法"></a>2.媒体查询语法</h4><p><strong>我们在媒体查询外面写的第一条规则，是“基本的”样式，它适用于任何设备。在此基础上，我们再为不同视口、不同能力的设备，渐进增加不同的视觉效果和功能。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: grey;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">1200px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">        <span class="attribute">background-color</span>: pink;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">700px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">1200px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">background-color</span>: blue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">700px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">background-color</span>: orange;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 @media 就表示媒体查询，查询现在看这个网页的设备是什么，以及它的宽度是多少。screen 表示看这个网页的设备是显示器，而不是残疾人听力设备、也不是打印机。后面用 and 符号罗列所有的可能性。<br>值得注意：<strong>媒体查询只能包裹选择器，不能包裹 k:v 对儿。</strong></p>
<p><strong>IE6、7、8 不支持媒体查询，也为了防止手机端的某些浏览器不支持媒体查询，所以不要把所有的选择器都放在媒体查询里面。</strong></p>
<h2 id="七、rem-响应式布局"><a href="#七、rem-响应式布局" class="headerlink" title="七、rem 响应式布局"></a>七、rem 响应式布局</h2><blockquote>
<p>rem 响应式布局思想</p>
</blockquote>
<ol>
<li> 一般不要给元素设置具体的宽度,但是对于一些小图标可以设定具体宽度值</li>
<li> 高度值可以设置固定值,设计稿有多大,我们就严格写多大</li>
<li> 所有设置的固定值都用 REM 做单位(首先在 HTML 中设置一个基准值：PX 和 REM 的对应比例,然后在效果图上获取 PX 值,布局的时候转化为 REM 值)</li>
<li> JS 获取真实屏幕的宽度,让其除以设计稿的宽度,算出比例,把之前的基准值按照比例进行重新的设定,这样项目就可以在移动端自适应了</li>
</ol>
<blockquote>
<p>什么是 rem,它与 em 有何区别</p>
</blockquote>
<p><strong>rem:当前页面中元素的 REM 单位的样式值都是针对于 HTML 元素的 font-size 的值进行动态计算的</strong></p>
<p><strong>em:表示父元素的字号的倍数。(特例：在 text-indent 属性中，表示文字宽度)</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> body             →font-size:20px;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>   → font-size:2em;</span><br><span class="line">box1</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>  → font-size:2em;</span><br><span class="line">	box2</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span>  → font-size:2em;</span><br><span class="line">    	box3</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-89af7dfeb2b2c401?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="得到结果"></p>
<p>em 为单位的时候，font-size 属性是计算后继承，box1 计算出来是 40px。那么里面的 box2继承的是 40px。<strong>em 单位不仅仅可以用来设置字号，还可以设置任何盒模型的属性，比如 width、height、padding、margin、border</strong></p>
<p><strong>rem 有一点优势就是可以和媒体查询配合，实现响应式布局：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">320px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">14px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">360px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">16px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">400px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">18px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运用场景</p>
</blockquote>
<p>如果我们做的 H5 页面只在移动端访问，这是因为 REM 不兼容低版本的浏览器。而如果移动端和 PC 端公用一套代码，建议使用流式布局。</p>
<blockquote>
<p>如何做个 REM 响应式布局</p>
</blockquote>
<p><strong>1、从 UI 设计师拿到 PSD 设计稿,然后在样式中给 HTML 设定一个 font-size 的值，我们一般都设置一个方便后面计算的值，例如：100px</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">  font-size:100px;//1rem=100px</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2、写页面，写样式</strong><br>首先按照设计稿的尺寸来写样式，然后在写样式值的时候，需要把得到的像素值除以 100 计算出对应的 REM 的值。<br>值得注意的是：真实项目中外层盒子的宽度我们一般还是不写固定值，沿用流式布局法的思想，我们用百分比的方式布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin</span>:<span class="number">0</span>  <span class="number">0.2rem</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">3rem</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3、根据当前屏幕的宽度和设计稿的宽度来计算我们 HTML 的 font-size 的值</strong><br>例如：设计稿宽度为 640px,其中有一个部分是轮播图，它的尺寸是 600*300，在样式中给 HTML 设定一个 font-size 的值为 100px,则轮播图大小应该为 6rem×3rem，那如果手机屏幕宽度为 375px,其 font-size 应该设置为多少。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">375/640*100-&gt;fontsize=58.59375//此时轮播图能自适应手机屏幕大小</span><br></pre></td></tr></table></figure>

<p><strong>根据当前屏幕宽度和设计稿宽度的比例，动态计算一下当前宽度下的 fontsize 值应该是多少，如果 fontsize 的值改变了，之前设定的所有 REM 单位的值自动会跟着放大或者缩小</strong>。可以通过以下这段代码实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> desW=<span class="number">640</span>,</span></span><br><span class="line"><span class="javascript">winW=<span class="built_in">document</span>.documentElement.clientwidth,</span></span><br><span class="line"><span class="javascript">ratio=winW/desW;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.documentElement.style.fontSize=ratio*<span class="number">100</span>+<span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="javascript">&#125;();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但如果当前屏幕宽度大于设计稿宽度，图片会被拉长而失真，所以以上代码需要稍微做些修改：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//html部分</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">//js部分</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">~function()&#123;</span><br><span class="line">var desW=640,</span><br><span class="line">winW=document.documentElement.clientwidth,</span><br><span class="line">ratio=winW/desW;</span><br><span class="line">var oMain=document.getElementById(main&quot;)；</span><br><span class="line">if(winW&gt;desW)&#123;</span><br><span class="line">oMain.style.width=desW+&quot;px&quot;;</span><br><span class="line">oMain.style.margin=&quot;0 auto&quot;;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">document.documentElement.style.fontSize=ratio*100+&quot;px&quot;;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>响应式布局</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 Vite 基础知识</title>
    <url>/article/c758bf65.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Vite</strong>（法语单词，“快” 的意思）是一种新型的前端构建工具</p>
<p>最初是配合 Vue3.0 一起使用的，后来适配了各种前端项目，目前提供了 Vue、React、Preact 框架模板</p>
<p>目前来说，Vue 使用的是 vue-cli 脚手架，React 一般使用 create-react-app 脚手架。虽然脚手架工具不一样，但是内部的打包工具都是 Webpack</p>
<p>为什么要开发一个全新的构建工具，是 Webpack 不香了吗？</p>
<p>Vite 方式构建的项目，和使用 Webpack 构建的项目，有什么不同？</p>
<p>一个新工具的出现，一定是为了解决现有工具存在的问题的，否则新工具就没有存在的价值和意义</p>
<h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><p>vite —— 一个由 vue 作者尤雨溪开发的 web 开发工具，它具有以下特点：</p>
<ol>
<li>快速的冷启动</li>
<li>即时的模块热更新</li>
<li>真正的按需编译</li>
</ol>
<p>从作者在微博上的发言：</p>
<blockquote>
<p>​        Vite，一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 rollup 打。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题</p>
</blockquote>
<p>​        可以看出 vite 主要特点是基于浏览器 native 的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">ES module</a> 来开发，省略打包这个步骤，因为需要什么资源直接在浏览器里引入即可</p>
<p>​        基于浏览器 ES module 来开发 web 应用也不是什么新鲜事，snowpack 也基于此，不过目前此项目社区中并没有流行起来，vite 的出现也许会让这种开发方式再火一阵子</p>
<p>​        有趣的是 vite 算是革了 webpack 的命了（生产环境用 rollup）</p>
<h3 id="vite-的使用方式"><a href="#vite-的使用方式" class="headerlink" title="vite 的使用方式"></a>vite 的使用方式</h3><p><a href="https://vitejs.dev/guide/">快速通道</a></p>
<p>同常见的开发工具一样，vite 提供了用 npm 或者 yarn 一建生成项目结构的方式，使用 yarn 在终端执行</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ yarn create vite-app &lt;project-name&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line">$ yarn</span><br><span class="line">$ yarn dev</span><br></pre></td></tr></table></figure>

<p>即可初始化一个 vite 项目（默认应用模板为 vue3.x），生成的项目结构十分简洁</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">|____node_modules</span><br><span class="line">|____App.vue <span class="comment">// 应用入口</span></span><br><span class="line">|____index.html <span class="comment">// 页面入口</span></span><br><span class="line">|____vite.config.js <span class="comment">// 配置文件</span></span><br><span class="line">|____package.json</span><br></pre></td></tr></table></figure>

<p>执行 <code>yarn dev</code> 即可启动应用</p>
<h2 id="Vite-解决了-Webpack-哪些问题"><a href="#Vite-解决了-Webpack-哪些问题" class="headerlink" title="Vite 解决了 Webpack 哪些问题"></a>Vite 解决了 Webpack 哪些问题</h2><p>​        随着项目的复杂度升级，代码规范和管理就必须要同步提升。于是，编程社区中提出了多种模块化规范，服务端选择了 CommonJS 规范，客户端选择 AMD 规范较多，但是，两种模块化规范也都存在一定的问题，都是 JS 编程，有两个不同的模块化规范，在 JS 语言层面还是不够的，终于在 ES6 中，ECMA 委员会推出了语言层面模块系统：<strong>ES Modules 规范</strong></p>
<p>​        模块化可以帮助我们更好地解决复杂应用开发过程中的代码组织问题，但是随着模块化思想的引入，我们的前端应用又会产生了一些新的问题，比如：</p>
<ul>
<li>首先，我们所使用的 ES Modules 模块系统本身就存在环境兼容问题。尽管现如今主流浏览器的最新版本都支持这一特性，但是目前还无法保证用户的浏览器使用情况。所以我们还需要解决兼容问题</li>
<li>其次，模块化的方式划分出来的模块文件过多，而前端应用又运行在浏览器中，每一个文件都需要单独从服务器请求回来。零散的模块文件必然会导致浏览器的频繁发送网络请求，影响应用的工作效率</li>
<li>最后，谈一下在实现 JS 模块化的基础上的发散。随着应用日益复杂，在前端应用开发过程中不仅仅只有 JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题。而且从宏观角度来看，这些文件也都应该看作前端应用中的一个模块，只不过这些模块的种类和用途跟 JavaScript 不同</li>
</ul>
<p>对于开发过程而言，模块化肯定是必要的，所以我们需要在前面所说的模块化实现的基础之上引入更好的方案或者工具，去解决上面提出的 3 个问题，让我们的应用在开发阶段继续享受模块化带来的优势，又不必担心模块化对生产环境所产生的影响</p>
<p><em>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器（module bundler）</em></p>
<img src="https://qiniu-image.qtshe.com/5Fsdsd179FE8104D.png" alt="img" style="zoom: 67%;" />

 

<p>Vue 脚手架工具 vue-cli 使用 webpack 进行打包，开发时可以启动本地开发服务器，实时预览。因为需要对整个项目文件进行打包，开发服务器启动缓慢</p>
<img src="https://qiniu-image.qtshe.com/5F12312e179FE8104D.png" alt="img" style="zoom: 67%;" />

 

<p>而对于开发时文件修改后的热更新 HMR 也存在同样的问题</p>
<p>Webpack 的热更新会以当前修改的文件为入口重新 build 打包，所有涉及到的依赖也都会被重新加载一次</p>
<p>Vite 则很好地解决了上面的两个问题</p>
<img src="https://qiniu-image.qtshe.com/123123RR179FE8104D.png" alt="img" style="zoom: 67%;" />

 

<h3 id="打包问题"><a href="#打包问题" class="headerlink" title="打包问题"></a>打包问题</h3><p>vite 只启动一台静态页面的服务器，对文件代码不打包，服务器会根据客户端的请求加载不同的模块处理，实现真正的按需加载</p>
<img src="https://qiniu-image.qtshe.com/QWEQWE123FE8104D.png" alt="img" style="zoom: 67%;" />

 

<h3 id="热更新问题"><a href="#热更新问题" class="headerlink" title="热更新问题"></a>热更新问题</h3><p>vite 采用立即编译当前修改文件的办法。同时 vite 还会使用缓存机制( http 缓存 =&gt; vite 内置缓存 )，加载更新后的文件内容</p>
<p>所以，vite 具有了快速冷启动、按需编译、模块热更新等优良特质</p>
<p>综上所述，vite 构建项目与 vue-cli 构建的项目在开发模式下还是有比较大的区别：</p>
<ul>
<li>Vite 在开发模式下不需要打包可以直接运行，使用的是 ES6 的模块化加载规则；Vue-CLI 开发模式下必须对项目打包才可以运行</li>
<li>Vite 基于缓存的热更新，Vue-CLI 基于 Webpack 的热更新</li>
</ul>
<h2 id="vite-启动链路"><a href="#vite-启动链路" class="headerlink" title="vite 启动链路"></a>vite 启动链路</h2><h3 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h3><p>这部分代码在 src/node/cli.ts 里，主要内容是借助 minimist —— 一个轻量级的命令解析工具解析 npm scripts，解析的函数是 <code>resolveOptions</code> ，精简后的代码片段如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveOptions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// command 可以是 dev/build/optimize</span></span><br><span class="line">    <span class="keyword">if</span> (argv._[<span class="number">0</span>]) &#123;</span><br><span class="line">        argv.command = argv._[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> argv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到 options 后，会根据 <code>options.command</code> 的值判断是执行在开发环境需要的 runServe 命令或生产环境需要的 runBuild 命令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!options.command || options.command === <span class="string">&#x27;serve&#x27;</span>) &#123;</span><br><span class="line">    runServe(options)</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.command === <span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">    runBuild(options)</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.command === <span class="string">&#x27;optimize&#x27;</span>) &#123;</span><br><span class="line">    runOptimize(options)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>runServe</code> 方法中，执行 server 模块的创建开发服务器方法，同样在 <code>runBuild</code> 中执行 build 模块的构建方法</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>这部分代码在 src/node/server/index.ts 里，主要暴露一个 <code>createServer</code> 方法</p>
<p>vite 使用 koa 作 web server，使用 clmloader 创建了一个监听文件改动的 watcher，同时实现了一个插件机制，将 koa-app 和 watcher 以及其他必要工具组合成一个 context 对象注入到每个 plugin 中</p>
<p>context 组成如下</p>
<img src="https://qiniu-image.qtshe.com/TRDGR5F123E8104D.png" alt="img" style="zoom: 67%;" />

<p>plugin 依次从 context 里获取上面这些组成部分，有的 plugin 在 koa 实例添加了几个 middleware，有的借助 watcher 实现对文件的改动监听，这种插件机制带来的好处是整个应用结构清晰，同时每个插件处理不同的事情，职责更分明</p>
<h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><p>plugin大致分类如下</p>
<ul>
<li>用户注入的 plugins —— 自定义 plugin</li>
<li>hmrPlugin —— 处理 hmr</li>
<li>htmlRewritePlugin —— 重写 html 内的 script 内容</li>
<li>moduleRewritePlugin —— 重写模块中的 import 导入</li>
<li>moduleResolvePlugin ——获取模块内容</li>
<li>vuePlugin —— 处理 vue 单文件组件</li>
<li>esbuildPlugin —— 使用 esbuild 处理资源</li>
<li>assetPathPlugin —— 处理静态资源</li>
<li>serveStaticPlugin —— 托管静态资源</li>
<li>cssPlugin —— 处理 css/less/sass 等引用</li>
</ul>
<p>接下来看看 plugin 的实现方式，开发一个用来拦截 json 文件 plugin 可以这么实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface ServerPluginContext &#123;</span><br><span class="line">  <span class="attr">root</span>: string</span><br><span class="line">  <span class="attr">app</span>: Koa</span><br><span class="line">  <span class="attr">server</span>: Server</span><br><span class="line">  <span class="attr">watcher</span>: HMRWatcher</span><br><span class="line">  <span class="attr">resolver</span>: InternalResolver</span><br><span class="line">  <span class="attr">config</span>: ServerConfig</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">type ServerPlugin = （ctx:ServerPluginContext）=&gt; <span class="keyword">void</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> JsonInterceptPlugin:ServerPlugin = <span class="function">(<span class="params">&#123;app&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">      <span class="keyword">await</span> next()</span><br><span class="line">      <span class="keyword">if</span> (ctx.path.endsWith(<span class="string">&#x27;.json&#x27;</span>) &amp;&amp; ctx.body) &#123;</span><br><span class="line">        ctx.type = <span class="string">&#x27;js&#x27;</span></span><br><span class="line">        ctx.body = <span class="string">`export default json`</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vite 背后的原理都在 plugin 里，有兴趣可以每一个都了解一下</p>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a><strong>build</strong></h3><p>这部分代码在 node/build/index.ts 中，build 目录的结构虽然与 server 相似，同样导出一个 build 方法，同样也有许多 plugin，不过这些 plugin 与 server 中的用途不一样，因为 build 使用了 rollup ，所以这些 plugin 也是为 rollup 打包的 plugin</p>
<p>结语：Vite原理下期再见</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>Vue,Vite</category>
      </categories>
      <tags>
        <tag>Vite</tag>
        <tag>前端构建</tag>
      </tags>
  </entry>
  <entry>
    <title>加载本地文件出现跨域解决方案</title>
    <url>/article/f9f02152.html</url>
    <content><![CDATA[<h2 id="本地-Ajax-跨域报错"><a href="#本地-Ajax-跨域报错" class="headerlink" title="本地 Ajax 跨域报错"></a>本地 Ajax 跨域报错</h2><p><strong>Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, chrome-untrusted, https.</strong></p>
<hr>
<p>当我们在做练习或者写 Demo 的时候，有访问本地文件的需求，当我们在加载的时候发现不能加载，会报如下错误： </p>
<p><img src="https://images.cnblogs.com/cnblogs_com/xzsj/1888303/o_210325085243filecross.png"></p>
<p>根据错误信息大概知道原因在于使用了 File 协议，应该使用它提示的 http, data, chrome, chrome-extension, chrome-untrusted, https 这些协议，可是只是做个练习，写些小 Demo，不至于自己去创建一个服务器，开个端口。那么应该如何解决这个问题呢？各位看官，往下看。</p>
<h2 id="1-换编辑器"><a href="#1-换编辑器" class="headerlink" title="1.换编辑器"></a>1.换编辑器</h2><hr>
<p>使用 webstorm 或是 visual studio 这种重量级 IDE 的同学，应该不会遇到这种问题，这类 IDE 都内置了 HTTP 服务器。<br>但是对于一些喜欢使用 VSCode，Sublime Text 这类轻量级编辑器的同学，我们继续往下看。</p>
<h2 id="2-安装Server插件"><a href="#2-安装Server插件" class="headerlink" title="2.安装Server插件"></a>2.安装Server插件</h2><hr>
<p>这里针对 VSCode 和 Sublime 分别安利一款插件。</p>
<h3 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h3><hr>
<p>Live Server 插件，这个插件功能十分强大，不止可以解决 ajax 不支持 file 协议的问题，还可以实现在编辑器里保存修改后，页面自动刷新的功能。具体使用方法在插件安装的地方有说明，用起来也十分简单。<br>安装完成之后，打开 html 文件后，点击右下角的 GoLive 即可。</p>
<h3 id="Sublime"><a href="#Sublime" class="headerlink" title="Sublime"></a>Sublime</h3><hr>
<p>SublimeServer 插件，安装完成之后，点击 Tools-&gt;SublimeServer-&gt;Start SublimeServer，启动服务器，然后在 html 文件中，注意是文件中点击右键，选择 View in SublimeServer 即可。<br>（注意一定要以文件夹的方式打开 html 文件所在目录，否则可能失效。）</p>
<h2 id="3-换浏览器"><a href="#3-换浏览器" class="headerlink" title="3.换浏览器"></a>3.换浏览器</h2><hr>
<p>火狐支持 file 协议，对 Chorme 没有什么执念的童鞋，可以换成火狐。</p>
<h2 id="4-配置Chrome浏览器支持file协议"><a href="#4-配置Chrome浏览器支持file协议" class="headerlink" title="4.配置Chrome浏览器支持file协议"></a>4.配置Chrome浏览器支持file协议</h2><hr>
<p>如果你是那种非常喜欢 Chrome 开发者工具的人，也可以尝试如下方式。</p>
<p>Windows：<br>设置 Chrome 的快捷方式属性，在“目标”后面加上–allow-file-access-from-files，注意前面有个空格，重新打开 Chrome 即可。</p>
<p>Mac：<br>打开终端，输入下面命令：open -a “Google Chrome” –args –disable-web-security 然后就可以屏蔽安全访问了[ –args：此参数可有可无]</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><hr>
<p>只是更改浏览器配置使之支持 file 协议，还是有很大的局限性的，建议最好采用前两种方式，配置 http 服务器才是长久之计。</p>
<h2 id="后记-1"><a href="#后记-1" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>跨域解决方案</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>原型与原型链详解</title>
    <url>/article/81e0994.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>与大部分面向对象语言不同，ES6之前并没有引入类（class）的概念，JavaScript并非通过类而是直接通过构造函数来创建实例。在介绍原型和原型链之前，我们有必要先复习一下构造函数的知识。</p>
<h2 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h2><p><strong>构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例。构造函数模式中拥有了类和实例的概念，并且实例和实例之间是相互独立的，即实例识别。</strong></p>
<p>构造函数就是一个普通的函数，创建方式和普通函数没有区别，<strong>不同的是构造函数习惯上首字母大写</strong>。另外就是调用方式的不同，普通函数是直接调用，<strong>而构造函数需要使用new关键字来调用</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">	<span class="built_in">this</span>.age = age</span><br><span class="line">	<span class="built_in">this</span>.gender = gender</span><br><span class="line">	<span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">	<span class="built_in">this</span>.age = age</span><br><span class="line">	<span class="built_in">this</span>.gender = gender</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">4</span>, <span class="string">&quot;雄&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(per);<span class="comment">//当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(dog);</span><br></pre></td></tr></table></figure>

<p><img src="/images/yuanxing.png"></p>
<p>每创建一个Person构造函数，在Person构造函数中，为每一个对象都添加了一个sayName方法，也就是说构造函数每执行一次就会创建一个新的sayName方法。这样就导致了构造函数执行一次就会创建一个新的方法，执行10000次就会创建10000个新的方法，而10000个方法都是一摸一样的，为什么不把这个方法单独放到一个地方，并让所有的实例都可以访问到呢?这就需要原型(<code>prototype</code>)</p>
<h2 id="二、原型"><a href="#二、原型" class="headerlink" title="二、原型"></a>二、原型</h2><p><strong>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个<code>prototype</code>属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。</strong></p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/67e633b1b48eb146b188536fa57cbf5f.png"></p>
<p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p>
<h2 id="三、原型链"><a href="#三、原型链" class="headerlink" title="三、原型链"></a>三、原型链</h2><h3 id="1-proto-和constructor"><a href="#1-proto-和constructor" class="headerlink" title="1.__proto__和constructor"></a>1.<code>__proto__</code>和<code>constructor</code></h3><p><strong>每一个对象数据类型(普通的对象、实例、<code>prototype</code>……)也天生自带一个属性<code>__proto__</code>，属性值是当前实例所属类的原型(<code>prototype</code>)。原型对象中有一个属性<code>constructor</code>, 它指向函数对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype)<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor===Person)<span class="comment">//true</span></span><br><span class="line"><span class="comment">//顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/80a10906001b2a310b8697c821284637.png"></p>
<h3 id="2-何为原型链"><a href="#2-何为原型链" class="headerlink" title="2.何为原型链"></a>2.何为原型链</h3><p><strong>在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链</strong>。</p>
<p>举例说明:person → Person → Object ，普通人继承人类，人类继承对象类</p>
<p><strong>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。</strong></p>
<p>我们可以使用对象的<code>hasOwnProperty()</code>来检查对象自身中是否含有该属性；使用<code>in</code>检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.a = <span class="number">123</span>;</span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.a)<span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span><span class="keyword">in</span> person)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>person实例中没有a这个属性，从 person 对象中找不到 a 属性就会从 person 的原型也就是 <code>person.__proto__</code> ，也就是 Person.prototype中查找，很幸运地得到a的值为123。那假如 <code>person.__proto__</code>中也没有该属性，又该如何查找？</p>
<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层Object为止。<strong>Object是JS中所有对象数据类型的基类(最顶层的类)在Object.prototype上没有<code>__proto__</code>这个属性。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0fc9b5cc09056eb5010086ccf23f1ed2.png" alt="img"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>关于响应式布局，你必须要知道的</title>
    <url>/article/4fb4f5da.html</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>响应式 Web 设计可以让一个网站同时适配多种设备和多个屏幕，可以让网站的布局和功能随用户的使用环境（屏幕大小、输入方式、设备/浏览器能力）而变化。本文主要介绍一些响应式布局容易忽略但又很重要的知识点。</p>
<h2 id="二、视口"><a href="#二、视口" class="headerlink" title="二、视口"></a>二、视口</h2><p><strong>移动前端中常说的 viewport （视口）就是浏览器中用于呈现网页的区域。视口通常并不等于屏幕大小，特别是可以缩放浏览器窗口的情况下</strong>。手机端与 PC 端视口存在差异，电脑端的视口宽度等于分辨率，而移动端的视口宽度跟分辨率没有关系,宽度默认值是设备厂家指定的。iOS, Android 基本都将这个视口分辨率设置为 980px。</p>
<h4 id="1-为什么手机端视口要设为-980px"><a href="#1-为什么手机端视口要设为-980px" class="headerlink" title="1.为什么手机端视口要设为 980px?"></a>1.为什么手机端视口要设为 980px?</h4><p>当年乔布斯设想：苹果手机如果在市场上火爆了，但是各个网站还没有来得及制作手机端网页，那么用户不得不用手机访问电脑版的网页，<strong>如何用小屏幕访问大屏幕的页面也同样可读呢</strong>？乔帮主就想着为手机固定一个视口宽度，让手机的视口宽度等于世界上绝大多数 PC 网页的版心宽度，就是 980px。这样，用手机访问电脑版网页的时候，旁边刚好没有留白。不过页面缩放后文字会变得非常小，用户需要手动放大缩小才能看清楚，体验非常差。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-61b9f61766c2cfc0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PC端页面在手机上显示效果"></p>
<h4 id="2-约束视口"><a href="#2-约束视口" class="headerlink" title="2.约束视口"></a>2.约束视口</h4><p>为了解决前面的问题，可以在网页的中添加下面这行代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">width=device-width   视口为设备宽度（就是人设置的一个宽度）//不设置的话默认为980px</span><br><span class="line">initial-scale=1.0    初始化的视口大小是1.0倍</span><br><span class="line">maximum-scale=1.0    最大的倍数是1.0倍</span><br><span class="line">user-scalable=0      不允许缩放视口</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个视口的标签告诉浏览器怎么渲染网页。在这里，标签想表达的意思是：按照设备的宽度（device-width）来渲染网页内容。事实上，在支持这个标签的设备上给你看一看效果，你就明白了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-aa0a7fa4ea5860a2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="约束视口后"></p>
<p>不错呀！用户体验大大改善！！！<br>此时如果用 document.documentElement.clientWidth 来测试浏览器屏幕宽度，你会发现当前视口宽度等于手机屏幕的宽度，约数后的视口宽度都是在 320~480 之间（手机竖直使用的时候）。<br>这个视口的尺寸，是手机厂商设置的，能够保证我们的文字比如 16px，在自己的这个视口下清晰、大小刚刚合适。所以<strong>大屏幕的手机的约束视口 &gt; 小屏幕手机的约束视口。这就能够保证我们的网页可以用 px 写字号、写行高</strong>。<br><strong>需要注意的是：约束之后的视口宽度，不是自己的分辨率！！每个手机的分辨率，都要比自己的视口宽度大得多得多！</strong></p>
<p><strong>最最重要的一句话：前端开发工程师，丝毫不关心手机的分辨率，我们只关心视口。</strong></p>
<h2 id="三、图片"><a href="#三、图片" class="headerlink" title="三、图片"></a>三、图片</h2><p>人们常说说“一图胜千言”，确实如此。我们网页中关于松饼的文字介绍再多，也没有图片有吸引力。下面我们就在页面上方添加一张松饼的图片（2000 像素宽），效果类似引诱用户往下看的大题图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-ffe488f2924e7dcf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加图片后"></p>
<p>哇，真是好大一张图，它让整个网页看起来都失衡了，水平方向上图片溢出了。不行，必须解决这个问题。可以用 CSS 给图片指定固定宽度，<strong>但问题是我们想让它能在不同大小的屏幕中自动缩放</strong>。比如，我们例子中的 iPhone 屏幕宽度为 320 像素，如果我们把图片设置成 320 像素宽，那么 iPhone 屏幕旋转后又怎么办呢？这时候 320 像素变成了 480 像素。<br>解决方案很简单，只要一行 CSS 代码就可以让图片随容器宽度自动缩放:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line"> <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回到手机上，刷新页面，结果比较符合预期了。<br>这里声明 max-width 规则，就是要保证所有图片最大显示为其自身的 100%（即最大只可以显示为自身那么大）。<strong>此时，如果包含图片的元素（比如包含图片的 body 或 div）比图片固有宽度小，图片会缩放占满最大可用空间</strong>。</p>
<h4 id="为什么不用-width-100"><a href="#为什么不用-width-100" class="headerlink" title="为什么不用 width:100%?"></a>为什么不用 width:100%?</h4><p>要实现图片的自动缩放，也可以使用更通用的 width 属性，比如 width:100%。然而，这条规则在这里并不适用。因为这条规则会导致它显示得跟它的容器一样宽。<strong>在容器比图片宽得多的情况下，图片会被无谓地拉伸。</strong></p>
<h2 id="四、手机浏览器内核"><a href="#四、手机浏览器内核" class="headerlink" title="四、手机浏览器内核"></a>四、手机浏览器内核</h2><p>在移动端，仅有四个独立的浏览器内核，分别为微软的 Trident、火狐的 Gecko、开源内核 Webkit、Opera 的 Presto。<br>目前微软的 Trident 在移动终端上主要为 WP7、8 系统内置浏览器。Opera 的 Presto 内核主要为 Opera Mobile、OperaMini、欧朋浏览器以及欧朋 HD Beta 版。<strong>Webkit 内核的适用范围则较为广泛，Android 原生浏览器、苹果的 Safari、谷歌 Chrome(Android4.0 使用)都是基于 Webkit 开源内核开发的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">兼容的前缀：</span><br><span class="line">1	-ms-</span><br><span class="line">2	-moz-</span><br><span class="line">3	-o-</span><br><span class="line">4	-webkit-</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>中国用户的浏览器市场份额：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-65700ebe6311e394?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="近一年中国用户的浏览器市场份额"></p>
<p>UC、Android 内置、Chrome、Safari、QQ Browser 都是 webkit 内核，从图上看占了绝大部分的市场份额。<br>所以一定要伺候好-webkit-。 有的公司干脆只兼容-webkit-，别的兼容比如-ms-都不写。</p>
<h2 id="五、流式布局"><a href="#五、流式布局" class="headerlink" title="五、流式布局"></a>五、流式布局</h2><p><strong>百分比布局也叫作流式布局、弹性盒布局。手机网页没有版心，都左右撑满。</strong></p>
<p><strong>百分比能够设置的属性是 width、height、padding、margin。其他属性比如 border、font-size 不能用百分比设置的。</strong></p>
<ul>
<li>  如果用百分比写 width，那么指的是父元素 width 的百分之多少。</li>
<li>  如果用百分比写 height，那么指的是父元素 height 的百分之多少。</li>
<li>  如果用百分比写 padding，那么指的是父元素 width 的百分之多少，无论是水平的 padding 还是竖直的 padding。</li>
<li>  如果用百分比写 margin，那么指的是父元素 width 的百分之多少，无论是水平的 margin 还是竖直的 margin。</li>
<li>  不能用百分比写 border 的宽度</li>
</ul>
<p>接下来我们看一个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">padding</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">padding</span>:<span class="number">10%</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">/*此时p的真实宽度是多少？*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-6cd6772e448675b0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p的盒模型图"></p>
<p>此时 p 的真实宽度是 140px*190px</p>
<h2 id="六、媒体查询"><a href="#六、媒体查询" class="headerlink" title="六、媒体查询"></a>六、媒体查询</h2><h4 id="1-为什么响应式-Web-设计需要媒体查询"><a href="#1-为什么响应式-Web-设计需要媒体查询" class="headerlink" title="1.为什么响应式 Web 设计需要媒体查询"></a>1.为什么响应式 Web 设计需要媒体查询</h4><p><strong>CSS3 媒体查询可以让我们针对特定的设备能力或条件为网页应用特定的 CSS 样式</strong>。如果没有媒体查询，光用 CSS 是无法大大修改网页外观的。这个模块让我们可以提前编写出适应很多不可预测因素的 CSS 规则，比如屏幕方向水平或垂直、视口或大或小等等。弹性布局虽然可以让设计适应较多场景，也包括某些尺寸的屏幕，但有时候确实不够用，因为我们还需要对布局进行更细致的调整。媒体查询让这一切成为可能，它就相当于 CSS 中基本的条件逻辑。</p>
<h4 id="2-媒体查询语法"><a href="#2-媒体查询语法" class="headerlink" title="2.媒体查询语法"></a>2.媒体查询语法</h4><p><strong>我们在媒体查询外面写的第一条规则，是“基本的”样式，它适用于任何设备。在此基础上，我们再为不同视口、不同能力的设备，渐进增加不同的视觉效果和功能。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: grey;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">1200px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">        <span class="attribute">background-color</span>: pink;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">700px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">1200px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">background-color</span>: blue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">700px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">background-color</span>: orange;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 @media 就表示媒体查询，查询现在看这个网页的设备是什么，以及它的宽度是多少。screen 表示看这个网页的设备是显示器，而不是残疾人听力设备、也不是打印机。后面用 and 符号罗列所有的可能性。<br>值得注意：<strong>媒体查询只能包裹选择器，不能包裹 k:v 对儿。</strong></p>
<p><strong>IE6、7、8 不支持媒体查询，也为了防止手机端的某些浏览器不支持媒体查询，所以不要把所有的选择器都放在媒体查询里面。</strong></p>
<h2 id="七、rem-响应式布局"><a href="#七、rem-响应式布局" class="headerlink" title="七、rem 响应式布局"></a>七、rem 响应式布局</h2><blockquote>
<p>rem 响应式布局思想</p>
</blockquote>
<ol>
<li> 一般不要给元素设置具体的宽度,但是对于一些小图标可以设定具体宽度值</li>
<li> 高度值可以设置固定值,设计稿有多大,我们就严格写多大</li>
<li> 所有设置的固定值都用 REM 做单位(首先在 HTML 中设置一个基准值：PX 和 REM 的对应比例,然后在效果图上获取 PX 值,布局的时候转化为 REM 值)</li>
<li> JS 获取真实屏幕的宽度,让其除以设计稿的宽度,算出比例,把之前的基准值按照比例进行重新的设定,这样项目就可以在移动端自适应了</li>
</ol>
<blockquote>
<p>什么是 rem,它与 em 有何区别</p>
</blockquote>
<p><strong>rem:当前页面中元素的 REM 单位的样式值都是针对于 HTML 元素的 font-size 的值进行动态计算的</strong></p>
<p><strong>em:表示父元素的字号的倍数。(特例：在 text-indent 属性中，表示文字宽度)</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> body             →font-size:20px;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>   → font-size:2em;</span><br><span class="line">box1</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>  → font-size:2em;</span><br><span class="line">	box2</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span>  → font-size:2em;</span><br><span class="line">    	box3</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-89af7dfeb2b2c401?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="得到结果"></p>
<p>em 为单位的时候，font-size 属性是计算后继承，box1 计算出来是 40px。那么里面的 box2继承的是 40px。<strong>em 单位不仅仅可以用来设置字号，还可以设置任何盒模型的属性，比如 width、height、padding、margin、border</strong></p>
<p><strong>rem 有一点优势就是可以和媒体查询配合，实现响应式布局：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">320px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">14px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">360px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">16px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">400px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">18px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运用场景</p>
</blockquote>
<p>如果我们做的 H5 页面只在移动端访问，这是因为 REM 不兼容低版本的浏览器。而如果移动端和 PC 端公用一套代码，建议使用流式布局。</p>
<blockquote>
<p>如何做个 REM 响应式布局</p>
</blockquote>
<p><strong>1、从 UI 设计师拿到 PSD 设计稿,然后在样式中给 HTML 设定一个 font-size 的值，我们一般都设置一个方便后面计算的值，例如：100px</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">  font-size:100px;//1rem=100px</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2、写页面，写样式</strong><br>首先按照设计稿的尺寸来写样式，然后在写样式值的时候，需要把得到的像素值除以 100 计算出对应的 REM 的值。<br>值得注意的是：真实项目中外层盒子的宽度我们一般还是不写固定值，沿用流式布局法的思想，我们用百分比的方式布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin</span>:<span class="number">0</span>  <span class="number">0.2rem</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">3rem</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3、根据当前屏幕的宽度和设计稿的宽度来计算我们 HTML 的 font-size 的值</strong><br>例如：设计稿宽度为 640px,其中有一个部分是轮播图，它的尺寸是 600*300，在样式中给 HTML 设定一个 font-size 的值为 100px,则轮播图大小应该为 6rem×3rem，那如果手机屏幕宽度为 375px,其 font-size 应该设置为多少。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">375/640*100-&gt;fontsize=58.59375//此时轮播图能自适应手机屏幕大小</span><br></pre></td></tr></table></figure>

<p><strong>根据当前屏幕宽度和设计稿宽度的比例，动态计算一下当前宽度下的 fontsize 值应该是多少，如果 fontsize 的值改变了，之前设定的所有 REM 单位的值自动会跟着放大或者缩小</strong>。可以通过以下这段代码实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> desW=<span class="number">640</span>,</span></span><br><span class="line"><span class="javascript">winW=<span class="built_in">document</span>.documentElement.clientwidth,</span></span><br><span class="line"><span class="javascript">ratio=winW/desW;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.documentElement.style.fontSize=ratio*<span class="number">100</span>+<span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="javascript">&#125;();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但如果当前屏幕宽度大于设计稿宽度，图片会被拉长而失真，所以以上代码需要稍微做些修改：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//html部分</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">//js部分</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">~function()&#123;</span><br><span class="line">var desW=640,</span><br><span class="line">winW=document.documentElement.clientwidth,</span><br><span class="line">ratio=winW/desW;</span><br><span class="line">var oMain=document.getElementById(main&quot;)；</span><br><span class="line">if(winW&gt;desW)&#123;</span><br><span class="line">oMain.style.width=desW+&quot;px&quot;;</span><br><span class="line">oMain.style.margin=&quot;0 auto&quot;;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">document.documentElement.style.fontSize=ratio*100+&quot;px&quot;;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>响应式</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>在线远程编写测试</title>
    <url>/article/5cdff96.html</url>
    <content><![CDATA[<p>你好，么么哒！</p>
<u>文本内容</u><wavy>文本内容</wavy>
<hr/>
<span class='p center logo large'>Volantis</span>
<span class='p center small'>A Wonderful Theme for Hexo</span>
<hr/>
<div class="note simple"><p>默认 提示块标签</p>
</div>

<div class="note default simple"><p>default 提示块标签</p>
</div>

<div class="note primary simple"><p>primary 提示块标签</p>
</div>

<div class="note success simple"><p>success 提示块标签</p>
</div>

<div class="note info simple"><p>info 提示块标签</p>
</div>

<div class="note warning simple"><p>warning 提示块标签</p>
</div>

<div class="note danger simple"><p>danger 提示块标签</p>
</div>
<hr/>
<div class="note modern"><p>默认 提示块标签</p>
</div>

<div class="note default modern"><p>default 提示块标签</p>
</div>

<div class="note primary modern"><p>primary 提示块标签</p>
</div>

<div class="note success modern"><p>success 提示块标签</p>
</div>

<div class="note info modern"><p>info 提示块标签</p>
</div>

<div class="note warning modern"><p>warning 提示块标签</p>
</div>

<div class="note danger modern"><p>danger 提示块标签</p>
</div>
<hr/>
<div class="note flat"><p>默认 提示块标签</p>
</div>

<div class="note default flat"><p>default 提示块标签</p>
</div>

<div class="note primary flat"><p>primary 提示块标签</p>
</div>

<div class="note success flat"><p>success 提示块标签</p>
</div>

<div class="note info flat"><p>info 提示块标签</p>
</div>

<div class="note warning flat"><p>warning 提示块标签</p>
</div>

<div class="note danger flat"><p>danger 提示块标签</p>
</div>
<hr/>
<div class="note no-icon flat"><p>默认 提示块标签</p>
</div>

<div class="note default no-icon flat"><p>default 提示块标签</p>
</div>

<div class="note primary no-icon flat"><p>primary 提示块标签</p>
</div>

<div class="note success no-icon flat"><p>success 提示块标签</p>
</div>

<div class="note info no-icon flat"><p>info 提示块标签</p>
</div>

<div class="note warning no-icon flat"><p>warning 提示块标签</p>
</div>

<div class="note danger no-icon flat"><p>danger 提示块标签</p>
</div>
<hr/>
<div class="tip "><p>默认情况</p>
</div>
<div class="tip success"><p>success</p>
</div>
<div class="tip error"><p>error</p>
</div>
<div class="tip warning"><p>warning</p>
</div>
<div class="tip bolt"><p>bolt</p>
</div>
<div class="tip ban"><p>ban</p>
</div>
<div class="tip home"><p>home</p>
</div>
<div class="tip sync"><p>sync</p>
</div>
<div class="tip cogs"><p>cogs</p>
</div>
<div class="tip key"><p>key</p>
</div>
<div class="tip bell"><p>bell</p>
</div>
<div class="tip fa-atom"><p>自定义font awesome图标</p>
</div>
<hr/>
<div class="tip warning faa-horizontal animated"><p>warning</p>
</div>
<div class="tip ban faa-flash animated"><p>ban</p>
</div>
<hr/>
<div class='checkbox'><input type="checkbox" />
            <p>纯文本测试</p>
            </div>
<div class='checkbox checked'><input type="checkbox" checked="checked"/>
            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>
            </div>
<div class='checkbox red'><input type="checkbox" />
            <p>支持自定义颜色</p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p>绿色 + 默认选中</p>
            </div>
<div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>
            <p>黄色 + 默认选中</p>
            </div>
<div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>
            <p>青色 + 默认选中</p>
            </div>
<div class='checkbox blue checked'><input type="checkbox" checked="checked"/>
            <p>蓝色 + 默认选中</p>
            </div>
<div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>
            <p>增加</p>
            </div>
<div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>
            <p>减少</p>
            </div>
<div class='checkbox times red checked'><input type="checkbox" checked="checked"/>
            <p>叉</p>
            </div>
<hr/>
<div class='checkbox'><input type="radio" />
            <p>纯文本测试</p>
            </div>
<div class='checkbox checked'><input type="radio" checked="checked"/>
            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>
            </div>
<div class='checkbox red'><input type="radio" />
            <p>支持自定义颜色</p>
            </div>
<div class='checkbox green'><input type="radio" />
            <p>绿色</p>
            </div>
<div class='checkbox yellow'><input type="radio" />
            <p>黄色</p>
            </div>
<div class='checkbox cyan'><input type="radio" />
            <p>青色</p>
            </div>
<div class='checkbox blue'><input type="radio" />
            <p>蓝色</p>
            </div>
<hr/>
<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p>
</div>
<div class="tip ban faa-flash animated faa-slow"><p>ban</p>
</div>
<hr/>
这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。

<p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p>
<hr/>
<div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p>
<p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p>
</div>

<p>(ฅ´ω`ฅ) <img src="https://cdn.jsdelivr.net/gh/luckyzluz/zblogBasics@master/images/1623329377000.jpg" alt="图片描述测试"></p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>如何清除浮动？</title>
    <url>/article/b582ade9.html</url>
    <content><![CDATA[<h2 id="本文概述"><a href="#本文概述" class="headerlink" title="本文概述"></a>本文概述</h2><p>本文的框架图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-6b059107f9366a6a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="一、浮动到底是什么？"><a href="#一、浮动到底是什么？" class="headerlink" title="一、浮动到底是什么？"></a>一、浮动到底是什么？</h2><p>W3school中给出的浮动定义为<strong>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</strong>由于浮动框脱离文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-82e1d94c49c8e905?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css浮动"></p>
<h2 id="二、浮动有什么特点？"><a href="#二、浮动有什么特点？" class="headerlink" title="二、浮动有什么特点？"></a>二、浮动有什么特点？</h2><p>浮动的特点，可以用八个字总结：<strong>脱标、贴边、字围和收缩。</strong></p>
<p>为了更好说明，请看下图：<br>当框 1 向左浮动时，它脱离文档流（脱标）并且向左移动（贴边），直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框 2，使框 2 从视图中消失。如果框2中有文字，就会围着框1排开（字围）。</p>
<p>如果把所有三个框都向左浮动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-54cbbdffe716eda1?imageMogr2/auto-orient/strip" alt="CSS 浮动实例 - 向左浮动的元素"><br>下面着重讲解下第四个特点–收缩</p>
<p>一个浮动的内联元素（比如span img标签）不需要设置display：block就可以设置宽度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: greenyellow;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    这是一段文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>得到以下的效果：<br><img src="https://upload-images.jianshu.io/upload_images/24295319-ec21eeb7a08a1d75?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>我们都知道div标签是块级元素，会独占一行，然而上面的例子中将div设置为左浮后，其宽度不再是占满一行，而是收紧为内部元素的宽度，这就是浮动第四个特征的含义。</p>
<h2 id="三、浮动有什么缺点？"><a href="#三、浮动有什么缺点？" class="headerlink" title="三、浮动有什么缺点？"></a>三、浮动有什么缺点？</h2><p>先看下面这段代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.parent</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">border</span>: solid <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.child</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.child</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>)&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.child</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>)&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: greenyellow;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们想让父容器包裹着三个浮动元素，然而事与愿违，得到却是这样的结果：<br><img src="https://upload-images.jianshu.io/upload_images/24295319-c67c2da543f13028?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="父容器高度塌陷"></p>
<p>这就是浮动带来副作用—-父容器高度塌陷，于是清理浮动就显着至关重要。</p>
<h2 id="四、如何清理浮动？"><a href="#四、如何清理浮动？" class="headerlink" title="四、如何清理浮动？"></a>四、如何清理浮动？</h2><p><strong>清除浮动不是不用浮动，清除浮动产生的父容器高度塌陷</strong>。</p>
<h3 id="套路1：给浮动元素的父元素添加高度（扩展性不好）"><a href="#套路1：给浮动元素的父元素添加高度（扩展性不好）" class="headerlink" title="套路1：给浮动元素的父元素添加高度（扩展性不好）"></a>套路1：给浮动元素的父元素添加高度（扩展性不好）</h3><p>如果一个元素要浮动，那么它的父元素一定要有高度。高度的盒子，才能关住浮动。可以通过直接给父元素设置height，实际应用中我们不大可能给所有的盒子加高度，不仅麻烦，并且不能适应页面的快速变化；另外一种，父容器的高度可以通过内容撑开（比如img图片），实际当中此方法用的比较多。</p>
<h3 id="套路2：clear-both"><a href="#套路2：clear-both" class="headerlink" title="套路2：clear:both;"></a>套路2：clear:both;</h3><p>在最后一个子元素新添加最后一个冗余元素，然后将其设置clear:both,这样就可以清除浮动。这里强调一点，即<strong>在父级元素末尾添加的元素必须是一个块级元素，否则无法撑起父级元素高度</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#inner</span>&#123;</span><br><span class="line">      <span class="attribute">float</span>: left;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="套路3：伪元素清除浮动"><a href="#套路3：伪元素清除浮动" class="headerlink" title="套路3：伪元素清除浮动"></a>套路3：伪元素清除浮动</h3><p>上面那种办法固然可以清除浮动，但是我们不想在页面中添加这些没有意义的冗余元素，此时如何清除浮动吗？<br><strong>结合 :after 伪元素和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrap&quot;</span> <span class="attr">class</span>=<span class="string">&quot;clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#inner</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*开启haslayout*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*ie6 7 不支持伪元素*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">visibility</span>:hidden;//允许浏览器渲染它，但是不显示出来</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>给浮动元素的父容器添加一个clearfix的class，然后给这个class添加一个:after伪元素，实现元素末尾添加一个看不见的块元素来清理浮动。这是通用的清理浮动方案，推荐使用</p>
<h3 id="套路4：给父元素使用overflow-hidden"><a href="#套路4：给父元素使用overflow-hidden" class="headerlink" title="套路4：给父元素使用overflow:hidden;"></a>套路4：给父元素使用overflow:hidden;</h3><p>这种方案让父容器形成了BFC（块级格式上下文），而BFC可以包含浮动，通常用来解决浮动父元素高度坍塌的问题。</p>
<p><strong>BFC的触发方式</strong></p>
<p>我们可以给父元素添加以下属性来触发BFC：</p>
<ul>
<li>  float 为 left | right</li>
<li>  overflow 为 hidden | auto | scorll</li>
<li>  display 为 table-cell | table-caption | inline-block</li>
<li>  position 为 absolute | fixed</li>
</ul>
<p>这里可以给父元素设置overflow:auto，但是为了兼容IE最好使用overflow:hidden。</p>
<p><strong>但这种办法有个缺陷：如果有内容出了盒子，用这种方法就会把多的部分裁切掉，所以这时候不能使用。</strong></p>
<p><strong>BFC的主要特征:</strong></p>
<ul>
<li><p>  BFC容器是一个隔离的容器，和其他元素互不干扰；所以我们可以用触发两个元素的BFC来解决垂直边距折叠问题。</p>
</li>
<li><p>  BFC不会重叠浮动元素</p>
</li>
<li><p>  BFC可以包含浮动,这可以清除浮动。</p>
</li>
</ul>
<h3 id="套路5：br标签清浮动"><a href="#套路5：br标签清浮动" class="headerlink" title="套路5：br标签清浮动"></a>套路5：br标签清浮动</h3><p><strong>br标签存在一个属性：clear。这个属性就是能够清除浮动的利器，在br标签中设置属性clear，并赋值all。即能清除掉浮动</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> <span class="attr">clear</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#inner</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>清除浮动</tag>
        <tag>H5布局</tag>
      </tags>
  </entry>
  <entry>
    <title>宝塔面板部署(Vue+Node+MongoDB)项目</title>
    <url>/article/72abe528.html</url>
    <content><![CDATA[<h1 id="宝塔面板部署-Vue-Node-MongoDB-项目"><a href="#宝塔面板部署-Vue-Node-MongoDB-项目" class="headerlink" title="宝塔面板部署(Vue+Node+MongoDB)项目"></a>宝塔面板部署(Vue+Node+MongoDB)项目</h1><h4 id="前端打包好项目-dist"><a href="#前端打包好项目-dist" class="headerlink" title="前端打包好项目,dist"></a>前端打包好项目,<code>dist</code></h4><p><img src="https://cdn.jsdelivr.net/gh/luckyzluz/zblogBasics/images/281611694.jpg" alt="1.JPG"></p>
<p>来<code>www\wwwroot</code>目录下,这里是默认的入口目录,把打包好的<code>dist</code>文件放在这个目录下,<br>我把<code>dist</code>名字改成了<code>vue-hotai-item</code></p>
<p>然后在宝塔面板的<code>软件商店</code>,搜索<code>Nginx</code>下载,下载完成后,<code>点击配置</code>,选择<code>配置修改</code>,<br>找到<code>server</code>,如下:<br><img src="https://cdn.jsdelivr.net/gh/luckyzluz/zblogBasics/images/2872411393.jpg" alt="4.JPG"></p>
<p>如果你的路由模式是<code>history</code>,那就还要加一个代码,不加你打开的前端界面刷新就会变成<code>404</code>,<br>还是在<code>server</code>里面添加,如下:<br><img src="https://cdn.jsdelivr.net/gh/luckyzluz/zblogBasics/images/3699826349.jpg" alt="6.JPG"></p>
<p>然后保存,修改完Nginx<code>一定要重启</code>不然没用,这时候你就可以访问你的IP地址,可以看见你的项目界面了.</p>
<h4 id="后端配置"><a href="#后端配置" class="headerlink" title="后端配置"></a>后端配置</h4><p>后端文件上传的时候,把<code>node_modules</code>依赖删掉,不然文件太大也可能会出错,用终端来<code>npm i</code>下载依赖就好了,<br>后端文件还是放在<code>wwwroot</code>入口目录下,放好之后,来到<code>软件商店</code>里下载<code>PM2</code>,接下来在配置里的<code>模块管理</code>,添加你需要的模块,我用到了<code>Express npm</code>等,如下:<br><img src="https://cdn.jsdelivr.net/gh/luckyzluz/zblogBasics/images/3915376959.jpg" alt="7.JPG"></p>
<p>接下来就要打开<code>终端</code>,cd到后端文件存放位置,下载依赖了,接下来操作如下:<br><img src="https://cdn.jsdelivr.net/gh/luckyzluz/zblogBasics/images/1842586655.jpg" alt="9.JPG"></p>
<p><img src="https://cdn.jsdelivr.net/gh/luckyzluz/zblogBasics/images/1242972185.jpg" alt="10.JPG"></p>
<p>进入到终端后,来到<code>后端文件</code>存放位置,<code>npm i 下载依赖</code>:<br><img src="https://cdn.jsdelivr.net/gh/luckyzluz/zblogBasics/images/1612331480.jpg" alt="11.JPG"></p>
<p>下载完成后,关闭终端,还是在<code>软件商店</code>下载你需要的<code>数据库</code>,我用的<code>Mongodb</code>,所以不用设置账号密码,<br>如果用的到的<code>mysql</code>,那么你就配置一下<code>用户密码</code>,需要跟接口里的用户密码<code>一致</code>,继续回到<code>PM2</code>配置下的<code>项目列表</code>,填写路径等,如下:<br><img src="https://cdn.jsdelivr.net/gh/luckyzluz/zblogBasics/images/1564773369.jpg" alt="8.JPG"></p>
<p>添加后,如果跟我上图一样,有<code>停止|重启</code> 显示,那么恭喜你成功一半了,如果什么都没有,<br>你可以在<code>日志管理</code>,最上面有一个<code>项目日志目录/root/.pm2/logs</code>,点击那个目录路径,进去查看<code>xx-error.log</code>,报错信息.<br>成功后,接下来,配置跨域Nginx代理,还是来到<code>Nginx</code>的<code>配置修改</code>:<br><img src="https://cdn.jsdelivr.net/gh/luckyzluz/zblogBasics/images/518553230.jpg" alt="12.JPG"></p>
<p>修改后Nginx<code>重启</code>,最后一步还需要配置你的<code>baseURL</code>:<br><img src="https://cdn.jsdelivr.net/gh/luckyzluz/zblogBasics/images/956923879.jpg" alt="13.JPG"></p>
<hr>
<p>恭喜你完成项目部署,上线成功</p>
]]></content>
      <categories>
        <category>部署项目</category>
      </categories>
      <tags>
        <tag>部署项目,宝塔面板</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出Javascript闭包</title>
    <url>/article/1c8afc86.html</url>
    <content><![CDATA[<h2 id="一、引子"><a href="#一、引子" class="headerlink" title="一、引子"></a>一、引子</h2><p>闭包（closure）是 Javascript 语言的一个难点，面试时常被问及，也是它的特色，很多高级应用都要依靠闭包实现。本文尽可能用简单易懂的话，讲清楚闭包的概念、形成条件及其常见的面试题。</p>
<p>我们先来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line">f1() <span class="comment">// 999</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数f1可以读取全局变量n。但是，函数外部无法读取函数内部声明的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: n is not defined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数f1内部声明的变量n，函数外是无法读取的。</p>
<p>如果有时需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 999</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p>
<h2 id="二、闭包是什么"><a href="#二、闭包是什么" class="headerlink" title="二、闭包是什么"></a>二、闭包是什么</h2><p>我们可以对上面代码进行如下修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">999</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f2; <span class="comment">// f1返回了f2的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = f1(); <span class="comment">// result就是f2函数了</span></span><br><span class="line">result();  <span class="comment">// 执行result，全局作用域下没有a的定义，</span></span><br><span class="line">      <span class="comment">//但是函数闭包，能够把定义函数的时候的作用域一起记住，输出999			</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数f1的返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1的内部变量了。</p>
<p>闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在JavaScript语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。<strong>闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量</strong>。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h4 id="那到底什么是闭包呢？"><a href="#那到底什么是闭包呢？" class="headerlink" title="那到底什么是闭包呢？"></a>那到底什么是闭包呢？</h4><p><strong>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这就产生了闭包。</strong> —-《你不知道的Javascript上卷》</p>
<p>我个人理解，<strong>闭包就是函数中的函数(其他语言不能函数再套函数)</strong>,里面的函数可以访问外面函数的变量，外面的变量的是这个内部函数的一部分。</p>
<h4 id="闭包形成的条件"><a href="#闭包形成的条件" class="headerlink" title="闭包形成的条件"></a>闭包形成的条件</h4><ul>
<li>  函数嵌套</li>
<li>  内部函数引用外部函数的局部变量</li>
</ul>
<h2 id="三、闭包的特性"><a href="#三、闭包的特性" class="headerlink" title="三、闭包的特性"></a>三、闭包的特性</h2><p><strong>每个函数都是闭包，每个函数天生都能够记忆自己定义时所处的作用域环境</strong>。把一个函数从它定义的那个作用域，挪走，运行。这个函数居然能够记忆住定义时的那个作用域。<strong>不管函数走到哪里，定义时的作用域就带到了哪里</strong>。接下来我们用两个例子来说明这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题1</span></span><br><span class="line"><span class="keyword">var</span> inner;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">250</span>;</span><br><span class="line">inner=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(a);<span class="comment">//这个函数虽然在外面执行，但能够记忆住定义时的那个作用域，a是250</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">300</span>;</span><br><span class="line">inner();<span class="comment">//一个函数在执行的时候，找闭包里面的变量，不会理会当前作用域。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x+y);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inn=outer(<span class="number">3</span>);<span class="comment">//数字3传入outer函数后，inner函数中x便会记住这个值</span></span><br><span class="line">inn(<span class="number">5</span>);<span class="comment">//当inner函数再传入5的时候，只会对y赋值，所以最后弹出8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="四、闭包的内存泄漏"><a href="#四、闭包的内存泄漏" class="headerlink" title="四、闭包的内存泄漏"></a>四、闭包的内存泄漏</h2><p>栈内存提供一个执行环境，即作用域，包括全局作用域和私有作用域,那他们什么时候释放内存的？</p>
<ul>
<li>  <strong>全局作用域—-只有当页面关闭的时候全局作用域才会销毁</strong></li>
<li>  <strong>私有的作用域—-只有函数执行才会产生</strong></li>
</ul>
<p><strong>一般情况下，函数执行会形成一个新的私有的作用域，当私有作用域中的代码执行完成后，我们当前作用域都会主动的进行释放和销毁。但当遇到函数执行返回了一个引用数据类型的值，并且在函数的外面被一个其他的东西给接收了，这种情况下一般形成的私有作用域都不会销毁</strong>。</p>
<p>如下面这种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">var num=100;</span><br><span class="line">return function()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f=fn();//fn执行形成的这个私有的作用域就不能再销毁了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是像上面这段代码，fn函数内部的私有作用域会被一直占用的，发生了内存泄漏。<strong>所谓内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。闭包不能滥用，否则会导致内存泄露，影响网页的性能。闭包使用完了后，要立即释放资源，将引用变量指向null</strong>。</p>
<p>接下来我们看下有关于内存泄漏的一道经典面试题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> num=<span class="number">0</span>;<span class="comment">//内部变量</span></span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;<span class="comment">//通过return返回add函数，就可以在outer函数外访问了</span></span><br><span class="line"> num++;<span class="comment">//内部函数有引用，作为add函数的一部分了</span></span><br><span class="line"> <span class="built_in">console</span>.log(num);</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">var</span> func1=outer();</span><br><span class="line"> func1();<span class="comment">//实际上是调用add函数， 输出1</span></span><br><span class="line"> func1();<span class="comment">//输出2 因为outer函数内部的私有作用域会一直被占用</span></span><br><span class="line"> <span class="keyword">var</span> func2=outer();</span><br><span class="line"> func2();<span class="comment">// 输出1  每次重新引用函数的时候，闭包是全新的。</span></span><br><span class="line"> func2();<span class="comment">// 输出2  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="五、闭包的作用"><a href="#五、闭包的作用" class="headerlink" title="五、闭包的作用"></a>五、闭包的作用</h2><p>1.<strong>可以读取函数内部的变量</strong>。</p>
<p>2.<strong>可以使变量的值长期保存在内存中，生命周期比较长</strong>。因此不能滥用闭包，否则会造成网页的性能问题</p>
<p>3.<strong>可以用来实现JS模块</strong>。</p>
<p><strong>JS模块:具有特定功能的js文件,将所有的数据和功能都封装在一个函数内部(私有的),只向外暴露一个包信n个方法的对象或函数,模块的使用者,只需要通过模块暴露的对象调用方法来实现对应的功能</strong>。</p>
<p>具体请看下面的例子:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//index.html文件</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;myModule.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">  myModule2.doSomething()</span><br><span class="line">  myModule2.doOtherthing()</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//myModule.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">&#x27;Beijing&#x27;</span><span class="comment">//私有数据</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doSomething() &#x27;</span>+msg.toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doOtherthing() &#x27;</span>+msg.toLowerCase())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//向外暴露对象(给外部使用的两个方法)</span></span><br><span class="line">  <span class="built_in">window</span>.myModule2 = &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doOtherthing</span>: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/79f7b84fd2ce2ce11c4d045fe2fc5685.png"></p>
<h2 id="六、闭包的运用"><a href="#六、闭包的运用" class="headerlink" title="六、闭包的运用"></a>六、闭包的运用</h2><p>我们要实现这样的一个需求: 点击某个按钮, 提示”点击的是第n个按钮”,此处我们先不用事件代理:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.....</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>测试1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>测试2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>测试3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">      btns[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;第&#x27;</span> + (i + <span class="number">1</span>) + <span class="string">&#x27;个&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>万万没想到，点击任意一个按钮，后台都是弹出“第四个”,这是因为<code>i</code>是全局变量,执行到点击事件时，此时<code>i</code>的值为3。那该如何修改，最简单的是用<code>let</code>声明<code>i</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">     btns[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;第&#x27;</span> + (i + <span class="number">1</span>) + <span class="string">&#x27;个&#x27;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外我们可以通过闭包的方式来修改:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">   (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">     btns[j].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;第&#x27;</span> + (j + <span class="number">1</span>) + <span class="string">&#x27;个&#x27;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)(i)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解BFC</title>
    <url>/article/90bb1448.html</url>
    <content><![CDATA[<h2 id="一、什么是BFC"><a href="#一、什么是BFC" class="headerlink" title="一、什么是BFC"></a>一、什么是BFC</h2><p>Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。<strong>Block formatting context直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干</strong>。<strong>通俗地讲，BFC是一个容器，用于管理块级元素。</strong></p>
<h2 id="二、如何创建BFC"><a href="#二、如何创建BFC" class="headerlink" title="二、如何创建BFC"></a>二、如何创建BFC</h2><ul>
<li>  float为 left|right</li>
<li>  overflow为 hidden|auto|scroll</li>
<li>  display为 table-cell|table-caption|inline-block|inline-flex|flex</li>
<li>  position为 absolute|fixed</li>
<li>  根元素</li>
</ul>
<h2 id="三、BFC布局规则："><a href="#三、BFC布局规则：" class="headerlink" title="三、BFC布局规则："></a>三、BFC布局规则：</h2><ul>
<li>  内部的Box会在垂直方向，一个接一个地放置(即块级元素独占一行)。</li>
<li>  BFC的区域不会与float box重叠(<strong>利用这点可以实现自适应两栏布局</strong>)。</li>
<li>  内部的Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠(<strong>margin重叠三个条件:同属于一个BFC;相邻;块级元素</strong>)。</li>
<li>  计算BFC的高度时，浮动元素也参与计算。（清除浮动 haslayout）</li>
<li>  BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
</ul>
<h2 id="四、-BFC有哪些特性"><a href="#四、-BFC有哪些特性" class="headerlink" title="四、 BFC有哪些特性"></a>四、 BFC有哪些特性</h2><h3 id="特性1：BFC会阻止垂直外边距折叠"><a href="#特性1：BFC会阻止垂直外边距折叠" class="headerlink" title="特性1：BFC会阻止垂直外边距折叠"></a>特性1：BFC会阻止垂直外边距折叠</h3><p><strong>按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直margin的重叠</strong>，这个包括相邻元素或者嵌套元素，只要他们之间没有阻挡（<strong>比如边框、非空内容、padding等</strong>）就会发生margin重叠。</p>
<h4 id="①相邻兄弟元素margin重叠问题"><a href="#①相邻兄弟元素margin重叠问题" class="headerlink" title="①相邻兄弟元素margin重叠问题"></a>①相邻兄弟元素margin重叠问题</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: <span class="number">#888</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-0fb0ee9e830d4861?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="相邻兄弟元素margin重叠问题"><br>上面例中两个P元素之间距离本该为200px,然而实际上只有100px,发生了margin重叠。遇到这种情形，我们如何处理？<br><strong>只需要在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: <span class="number">#888</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.wrap</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">overflow</span>:hidden;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-ecfdc6082b43d7d3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bug修补后"></p>
<h4 id="②父子元素margin重叠问题"><a href="#②父子元素margin重叠问题" class="headerlink" title="②父子元素margin重叠问题"></a>②父子元素margin重叠问题</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background</span>:<span class="number">#ccc</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.wrap</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>:yellow;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.wrap</span> <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>:pink;</span></span><br><span class="line"><span class="css">  <span class="attribute">margin</span>:<span class="number">40px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>box<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-c9d21ec3205dd304?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="父子元素margin重叠问题"><br>上图wrap元素与h1元素之间l理论上本该有个40px的上下margin值,然而实际上父子元素并没有存在margin值，与此同时，两个div元素的间距为40px。遇到这种情形，我们如何处理？<br>处理方法其实有很多，<strong>在wrap元素中添加:overflow:hidden;或者overflow：auto；使其父元素形成一个BFC；也可以在wrap元素中添加border：1px solid；或是padding：1px；</strong>这些都可以有效解决父子元素margin重叠问题。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-3097db81ff365177?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bug修补后"></p>
<h3 id="特性2：BFC不会重叠浮动元素"><a href="#特性2：BFC不会重叠浮动元素" class="headerlink" title="特性2：BFC不会重叠浮动元素"></a>特性2：BFC不会重叠浮动元素</h3><p>利用这个特性，我们可以创造<strong>自适应两栏布局</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.box1</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>: lightblue;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.box2</span>&#123;<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>: <span class="number">#eee</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>喂喂喂!大家不要生气嘛，生气会犯嗔戒的。悟空你也太调皮了，</span><br><span class="line">我跟你说过叫你不要乱扔东西，你怎么又……你看，我还没说完你就把棍子给扔掉了!</span><br><span class="line">月光宝盒是宝物，你把它扔掉会污染环境，要是砸到小朋友怎么办，就算砸不到小朋友，</span><br><span class="line">砸到花花草草也是不对的。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-0210b5150138e1f0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文字围绕浮动元素排列"><br>上图中，文字围绕着浮动元素排列，不过在这里，这显然不是我们想要的。此时我们可以<strong>为.box2元素的样式加上overflow:hidden；使其建立一个BFC,让其内容消除对外界浮动元素的影响</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-10c8523ad44011d6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自适应布局"><br>这个方法可以用来实现两列自适应布局，效果不错，此时左边的宽度固定，右边的内容自适应宽度。如果我们改变文字的大小或者左边浮动元素的大小，两栏布局的结构依然没有改变！</p>
<h3 id="特性3：BFC可以包含浮动—-清除浮动"><a href="#特性3：BFC可以包含浮动—-清除浮动" class="headerlink" title="特性3：BFC可以包含浮动—-清除浮动"></a>特性3：BFC可以包含浮动—-清除浮动</h3><p>我们都知道浮动会脱离文档流，接下来我们看看下面的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.box1</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">width</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.box2</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">width</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>:yellow</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-4c97b0fcaaec9699?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="出现bug"></p>
<p>由于容器内两个div元素浮动，脱离了文档流，父容器内容宽度为零（即发生高度塌陷），未能将子元素包裹住。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-a6a5366bf78c5e20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bug修补"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>BFC</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的懂Promise吗</title>
    <url>/article/717de2a7.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在异步编程中，Promise 扮演了举足轻重的角色，比传统的解决方案（回调函数和事件）更合理和更强大。有些朋友对于这个几乎每天都在打交道的“老朋友”，貌似全懂,但稍加深入就可能疑问百出，本文带大家深入理解这个熟悉的陌生人—— Promise.</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h3><p><code>new Promise( function(resolve, reject) &#123;...&#125; /* executor */  )</code></p>
<ul>
<li>  构建 Promise 对象时，需要传入一个 executor 函数，主要业务流程都在 executor 函数中执行。</li>
<li>  Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor，resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。<strong>一旦状态改变，就不会再变</strong>，任何时候都可以得到这个结果。</li>
<li>  在 executor 函数中调用 resolve 函数后，会触发 promise.then 设置的回调函数；而调用 reject 函数后，会触发 promise.catch 设置的回调函数。<br><img src="https://img-blog.csdnimg.cn/img_convert/2eee3761cf3ca9710a4e9ca98450601a.png"></li>
</ul>
<p>值得注意的是，<strong>Promise 是用来管理异步编程的，它本身不是异步的</strong>，new Promise的时候会立即把executor函数执行，只不过我们一般会在executor函数中处理一个异步操作。比如下面代码中，一开始是会先打印出2。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>) <span class="comment">// 2 3 1</span></span><br></pre></td></tr></table></figure>
<p>Promise 采用了回调函数延迟绑定技术，在执行 resolve 函数的时候，回调函数还没有绑定，那么只能<strong>推迟回调函数的执行</strong>。这具体是啥意思呢？我们先来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  resolve(<span class="string">&#x27;学致前端攻略&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// then:设置成功或者失败后处理的方法</span></span><br><span class="line">p1.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line"> <span class="comment">//p1延迟绑定回调函数</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;成功 &#x27;</span>+result)</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;失败 &#x27;</span>+reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 成功 学致前端攻略</span></span><br></pre></td></tr></table></figure>
<p>new Promise的时候先执行executor函数，打印出 1、2，Promise在执行resolve时，触发微任务，还是继续往下执行同步任务，<br>执行p1.then时，存储起来两个函数（此时这两个函数还没有执行）,然后打印出3，此时同步任务执行完成，最后执行刚刚那个微任务，从而执行.then中成功的方法。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>Promise 对象的错误<strong>具有“冒泡”性质，会一直向后传递</strong>，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个 Promise 对象中单独捕获异常了。</p>
<p>要遇到一个then，要执行成功或者失败的方法，但如果此方法并没有在当前then中被定义，则顺延到下一个对应的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executor</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rand = <span class="built_in">Math</span>.random()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(rand)</span><br><span class="line">  <span class="keyword">if</span> (rand &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p0 = <span class="keyword">new</span> <span class="built_in">Promise</span>(executor)</span><br><span class="line"><span class="keyword">var</span> p1 = p0.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;succeed-1&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(executor)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;succeed-2&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(executor)</span><br><span class="line">&#125;)</span><br><span class="line">p2.catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>, error)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码有三个 Promise 对象：p0～p2。无论哪个对象里面抛出异常，都可以通过最后一个对象 p2.catch 来捕获异常，通过这种方式可以将所有 Promise 对象的错误合并到一个函数来处理，这样就解决了每个任务都需要单独处理异常的问题。</p>
<p>通过这种方式，我们就消灭了嵌套调用和频繁的错误处理，这样使得我们写出来的代码更加优雅，更加符合人的线性思维。</p>
<h3 id="Promise链式调用"><a href="#Promise链式调用" class="headerlink" title="Promise链式调用"></a>Promise链式调用</h3><p>我们都知道可以把多个Promise连接到一起来表示一系列异步骤。这种方式可以实现的关键在于以下两个Promise 固有行为特性：</p>
<ul>
<li>  每次你对Promise调用then，它都会创建并返回一个新的Promise，我们可以将其链接起来；</li>
<li>  不管从then调用的完成回调（第一个参数）返回的值是什么，它都会被自动设置为被链接Promise（第一点中的）的完成。</li>
</ul>
<p>先通过下面的例子，来解释一下刚刚这段话是什么意思，然后详细介绍下链式调用的执行流程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">100</span>) <span class="comment">// 决定了下个then中成功方法会被执行</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 连接p1</span></span><br><span class="line"><span class="keyword">let</span> p2=p1.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;成功1 &#x27;</span>+result)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">1</span>) </span><br><span class="line"><span class="comment">// 返回一个新的Promise实例，决定了当前实例是失败的，所以决定下一个then中失败方法会被执行</span></span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;失败1 &#x27;</span>+reason)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 连接p2 </span></span><br><span class="line"><span class="keyword">let</span> p3=p2.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;成功2 &#x27;</span>+result)</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;失败2 &#x27;</span>+reason)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 成功1 100</span></span><br><span class="line"><span class="comment">// 失败2 1</span></span><br></pre></td></tr></table></figure>
<p>我们通过返回 Promise.reject(1) ，完成了第一个调用then创建并返回的promise p2。p2的then调用在运行时会从return Promise.reject(1) 语句接受完成值。当然，p2.then又创建了另一个新的promise，可以用变量p3存储。</p>
<p>new Promise出来的实例，成功或者失败，取决于executor函数执行的时候，<strong>执行的是resolve还是reject决定的</strong>，或<strong>executor函数执行发生异常错误</strong>，这两种情况都会把实例状态改为失败的。</p>
<p>p2执行then返回的新实例的状态，决定下一个then中哪一个方法会被执行，有以下几种情况：</p>
<ul>
<li>  不论是成功的方法执行，还是失败的方法执行（then中的两个方法），凡是执行抛出了异常，则都会把实例的状态改为失败。</li>
<li>  方法中如果返回一个新的Promise实例（比如上例中的Promise.reject(1)），返回这个实例的结果是成功还是失败，也决定了当前实例是成功还是失败。</li>
<li>  剩下的情况基本上都是让实例变为成功的状态，上一个then中方法返回的结果会传递到下一个then的方法中。</li>
</ul>
<p>我们再来看个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">    resolve(a) <span class="comment">// 报错 </span></span><br><span class="line"><span class="comment">// 这个executor函数执行发生异常错误，决定下个then失败方法会被执行</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`成功：<span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">return</span> result*<span class="number">10</span></span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`失败：<span class="subst">$&#123;reason&#125;</span>`</span>)</span><br><span class="line"><span class="comment">// 执行这句时候，没有发生异常或者返回一个失败的Promise实例，所以下个then成功方法会被执行</span></span><br><span class="line"><span class="comment">// 这里没有return，最后会返回 undefined</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`成功：<span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`失败：<span class="subst">$&#123;reason&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 失败：ReferenceError: a is not defined</span></span><br><span class="line"><span class="comment">// 成功：undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h3><p>从上面一些例子，我们可以看出，虽然使用 Promise 能很好地解决回调地狱的问题，但是这种方式充满了 Promise 的 then() 方法，如果处理流程比较复杂的话，那么整段代码将充斥着 then，语义化不明显，代码不能很好地表示执行流程。</p>
<p>ES7中新增的异步编程方法，async/await的实现是基于 Promise的，简单而言就是async 函数就是返回Promise对象，是generator的语法糖。很多人认为async/await是异步操作的终极解决方案：</p>
<ul>
<li>  语法简洁，更像是同步代码，也更符合普通的阅读习惯；</li>
<li>  改进JS中异步操作串行执行的代码组织方式，减少callback的嵌套；</li>
<li>  Promise中不能自定义使用try/catch进行错误捕获，但是在Async/await中可以像处理同步代码处理错误。</li>
</ul>
<p>不过也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式</span></span><br><span class="line">  <span class="comment">// 如果有依赖性的话，其实就是解决回调地狱的例子了</span></span><br><span class="line">  <span class="keyword">await</span> fetch(url1)</span><br><span class="line">  <span class="keyword">await</span> fetch(url2)</span><br><span class="line">  <span class="keyword">await</span> fetch(url3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察下面这段代码，你能判断出打印出来的内容是什么吗？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 当代码执行到此行（先把此行），构建一个异步的微任务</span></span><br><span class="line"><span class="comment">// 等待promise返回结果，并且await下面的代码也都被列到任务队列中</span></span><br><span class="line">  <span class="keyword">let</span> result1 = <span class="keyword">await</span> p2</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">let</span> result2 = <span class="keyword">await</span> p1</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4</span></span><br></pre></td></tr></table></figure>
<p>如果 await 右侧表达逻辑是个 promise，await会等待这个promise的返回结果，<strong>只有返回的状态是resolved情况</strong>，才会把结果返回,如果promise是失败状态，则await不会接收其返回结果，await下面的代码也不会在继续执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.reject(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> p1</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>) <span class="comment">//这行代码不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看道比较复杂的题目：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>)&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>)&#125;,<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">await</span> fn()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br><span class="line">run()</span><br><span class="line"><span class="comment">//需要执行150ms左右</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">90000000</span>;i++)&#123;&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="number">9</span>)&#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 1 5 3 10 4 7 8 9 2 </span></span><br></pre></td></tr></table></figure>

<p>做这道题之前，读者需明白：</p>
<ul>
<li>  基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术，本题中resolve()、await fn()都是微任务。</li>
<li>  不管宏任务是否到达时间，以及放置的先后顺序，每次主线程执行栈为空的时候，引擎会优先处理微任务队列，<strong>处理完微任务队列里的所有任务</strong>，再去处理宏任务。</li>
</ul>
<p>接下来，我们一步一步分析：</p>
<ul>
<li>  首先执行同步代码，输出 1，遇见第一个setTimeout，将其回调放入任务队列（宏任务）当中，继续往下执行</li>
<li>  运行run(),打印出 5，并往下执行，遇见 await fn()，将其放入任务队列（微任务）</li>
<li>  await fn() 当前这一行代码执行时，fn函数会立即执行的,打印出3，遇见第二个setTimeout，将其回调放入任务队列（宏任务），await fn() 下面的代码需要等待返回Promise成功状态才会执行，所以6是不会被打印的。</li>
<li>  继续往下执行，遇到for循环同步代码，需要等150ms,虽然第二个setTimeout已经到达时间，但不会执行，遇见第三个setTimeout，将其回调放入任务队列（宏任务），然后打印出10。值得注意的是，这个定时器 推迟时间0毫秒实际上达不到的。根据HTML5标准，setTimeOut推迟执行的时间，最少是4毫秒。</li>
<li>  同步代码执行完毕，此时没有微任务，就去执行宏任务，上面提到已经到点的setTimeout先执行，打印出4</li>
<li>  然后执行下一个setTimeout的宏任务，所以先打印出7，new Promise的时候会立即把executor函数执行，打印出8，然后在执行resolve时，触发微任务，于是打印出9</li>
<li>  最后执行第一个setTimeout的宏任务，打印出2</li>
</ul>
<h2 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h2><h3 id="1、Promise-resolve"><a href="#1、Promise-resolve" class="headerlink" title="1、Promise.resolve()"></a>1、Promise.resolve()</h3><p>Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象。<br>Promise.resolve()等价于下面的写法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">&#x27;foo&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>Promise.resolve方法的参数分成四种情况。</p>
<p>（1）参数是一个 Promise 实例</p>
<p>如果参数是 Promise 实例，那么Promise.resolve将<strong>不做任何修改、原封不动地</strong>返回这个实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</p>
<p>（2）参数不是具有then方法的对象，或根本就不是对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&quot;Success&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// Promise.resolve方法的参数，会同时传给回调函数。</span></span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// &quot;Success&quot;</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不会被调用</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>（3）不带有任何参数</p>
<p>Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"><span class="comment">// one two</span></span><br></pre></td></tr></table></figure>
<p>（4）参数是一个thenable对象</p>
<p>thenable对象指的是具有then方法的对象,Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2、Promise-reject"><a href="#2、Promise-reject" class="headerlink" title="2、Promise.reject()"></a>2、Promise.reject()</h3><p>Promise.reject()方法返回一个带有拒绝原因的Promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;出错了&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;出错了&quot;</span>));  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;BOOM!&quot;</span>)).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>值得注意的是，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而<strong>不应该直接写在resolve或reject的后面</strong>。所以，最好在它们前面加上return语句，这样就不会有意外。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> reject(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="3、Promise-all"><a href="#3、Promise-all" class="headerlink" title="3、Promise.all()"></a>3、Promise.all()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">Promise</span>.all([p3, p2, p1])</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 返回的结果是按照Array中编写实例的顺序来</span></span><br><span class="line">    <span class="built_in">console</span>.log(result) <span class="comment">// [ 3, 2, 1 ]</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;失败:reason&quot;</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>Promise.all 生成并返回一个新的 Promise 对象，所以它可以使用 Promise 实例的所有方法。参数传递promise数组中<strong>所有的 Promise 对象都变为resolve的时候</strong>，该方法才会返回， 新创建的 Promise 则会使用这些 promise 的值。</p>
<p>如果参数中的<strong>任何一个promise为reject的话</strong>，则整个Promise.all调用会<strong>立即终止</strong>，并返回一个reject的新的 Promise 对象。</p>
<h3 id="4、Promise-allSettled"><a href="#4、Promise-allSettled" class="headerlink" title="4、Promise.allSettled()"></a>4、Promise.allSettled()</h3><p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，ES2020 引入Promise.allSettled()方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。Promise.all()方法无法做到这一点。</p>
<p>假如有这样的场景：一个页面有三个区域，分别对应三个独立的接口数据，使用 Promise.all 来并发请求三个接口，如果其中任意一个接口出现异常，状态是reject,这会导致页面中该三个区域数据全都无法出来，显然这种状况我们是无法接受，Promise.allSettled的出现就可以解决这个痛点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled([</span><br><span class="line">  <span class="built_in">Promise</span>.reject(&#123; <span class="attr">code</span>: <span class="number">500</span>, <span class="attr">msg</span>: <span class="string">&#x27;服务异常&#x27;</span> &#125;),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">list</span>: [] &#125;),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">list</span>: [] &#125;)</span><br><span class="line">]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 0: &#123;status: &quot;rejected&quot;, reason: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment"> 1: &#123;status: &quot;fulfilled&quot;, value: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment"> 2: &#123;status: &quot;fulfilled&quot;, value: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="comment">// 过滤掉 rejected 状态，尽可能多的保证页面区域数据渲染</span></span><br><span class="line">  RenderContent(</span><br><span class="line">    res.filter(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> el.status !== <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise.allSettled跟Promise.all类似, 其参数接受一个Promise的数组, 返回一个新的Promise, <strong>唯一的不同在于, 它不会进行短路</strong>, 也就是说当Promise全部处理完成后,我们可以拿到每个Promise的状态, 而不管是否处理成功。</p>
<h3 id="5、Promise-race"><a href="#5、Promise-race" class="headerlink" title="5、Promise.race()"></a>5、Promise.race()</h3><p>Promise.all()方法的效果是”谁跑的慢，以谁为准执行回调”，那么相对的就有另一个方法”谁跑的快，以谁为准执行回调”，这就是Promise.race()方法，这个词本来就是赛跑的意思。race的用法与all一样，接收一个promise对象数组为参数。</p>
<p>Promise.all在接收到的所有的对象promise都变为FulFilled或者Rejected状态之后才会继续进行后面的处理，与之相对的是Promise.race<strong>只要有一个promise对象进入FulFilled或者Rejected状态的话</strong>，就会继续进行后面的处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `delay`毫秒后执行resolve</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timerPromisefy</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(delay);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任何一个promise变为resolve或reject的话程序就停止运行</span></span><br><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">    timerPromisefy(<span class="number">1</span>),</span><br><span class="line">    timerPromisefy(<span class="number">32</span>),</span><br><span class="line">    timerPromisefy(<span class="number">64</span>)</span><br><span class="line">]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);    <span class="comment">// =&gt; 1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了3个promise对象，这些promise对象会分别在1ms、32ms 和 64ms后变为确定状态，即FulFilled，并且在第一个变为确定状态的1ms后，.then注册的回调函数就会被调用。</p>
<h3 id="6、Promise-prototype-finally"><a href="#6、Promise-prototype-finally" class="headerlink" title="6、Promise.prototype.finally()"></a>6、Promise.prototype.finally()</h3><p>ES9 新增 finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。<strong>这为在Promise是否成功完成后都需要执行的代码提供了一种方式</strong>。这避免了同样的语句需要在then()和catch()中各写一次的情况。</p>
<p>比如我们发送请求之前会出现一个loading，当我们请求发送完成之后，不管请求有没有出错，我们都希望关掉这个loading。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.loading = <span class="literal">true</span></span><br><span class="line">request()</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// log err</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loading = <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>finally方法的回调函数不接受任何参数，这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>假设有这样一个需求：红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？<br>三个亮灯函数已经存在：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题复杂的地方在于<strong>需要“交替重复”亮灯</strong>，而不是亮完一遍就结束的一锤子买卖，我们可以通过递归来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 promise 实现</span></span><br><span class="line"><span class="keyword">let</span> task = <span class="function">(<span class="params">timer, light</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (light === <span class="string">&#x27;red&#x27;</span>) &#123;</span><br><span class="line">        red()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (light === <span class="string">&#x27;green&#x27;</span>) &#123;</span><br><span class="line">        green()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (light === <span class="string">&#x27;yellow&#x27;</span>) &#123;</span><br><span class="line">        yellow()</span><br><span class="line">      &#125;</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> step = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  task(<span class="number">3000</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> task(<span class="number">1000</span>, <span class="string">&#x27;green&#x27;</span>))</span><br><span class="line">    .then(<span class="function">() =&gt;</span> task(<span class="number">2000</span>, <span class="string">&#x27;yellow&#x27;</span>))</span><br><span class="line">    .then(step)</span><br><span class="line">&#125;</span><br><span class="line">step()</span><br></pre></td></tr></table></figure>
<p>同样也可以通过async/await 的实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  async/await 实现</span></span><br><span class="line"><span class="keyword">let</span> step = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> task(<span class="number">3000</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> task(<span class="number">1000</span>, <span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> task(<span class="number">2000</span>, <span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">  step()</span><br><span class="line">&#125;</span><br><span class="line">step()</span><br></pre></td></tr></table></figure>
<p>使用 async/await 可以实现用同步代码的风格来编写异步代码,毫无疑问，还是 async/await 的方案更加直观，不过深入理解Promise 是掌握async/await的基础。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。 </p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器与Node的事件循环(Event Loop)有何区别</title>
    <url>/article/7e39944.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文我们将会介绍 JS 实现异步的原理，并且了解了在浏览器和 Node 中 Event Loop 其实是不相同的。</p>
<h2 id="一、线程与进程"><a href="#一、线程与进程" class="headerlink" title="一、线程与进程"></a>一、线程与进程</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>我们经常说JS 是单线程执行的，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？</p>
<p>官方的说法是：<strong>进程是 CPU资源分配的最小单位；线程是 CPU调度的最小单位</strong>。这两句话并不好理解，我们先来看张图：<br><img src="https://upload-images.jianshu.io/upload_images/24295319-b1e8ff834f094839?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ul>
<li>  进程好比图中的工厂，有单独的专属自己的工厂资源。</li>
<li>  线程好比图中的工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n的关系。也就是说<strong>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线</strong>；</li>
<li>  工厂的空间是工人们共享的，这象征<strong>一个进程的内存空间是共享的，每个线程都可用这些共享内存</strong>。</li>
<li>  多个工厂之间独立存在。</li>
</ul>
<h3 id="2-多进程与多线程"><a href="#2-多进程与多线程" class="headerlink" title="2.多进程与多线程"></a>2.多进程与多线程</h3><ul>
<li>  多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</li>
<li>  多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</li>
</ul>
<p>以Chrome浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p>
<h2 id="二、浏览器内核"><a href="#二、浏览器内核" class="headerlink" title="二、浏览器内核"></a>二、浏览器内核</h2><p>简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p>
<p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p>
<ul>
<li>  GUI 渲染线程</li>
<li>  JavaScript引擎线程</li>
<li>  定时触发器线程</li>
<li>  事件触发线程</li>
<li>  异步http请求线程</li>
</ul>
<h3 id="1-GUI渲染线程"><a href="#1-GUI渲染线程" class="headerlink" title="1.GUI渲染线程"></a>1.GUI渲染线程</h3><ul>
<li>  主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。</li>
<li>  当界面需要重绘或者由于某种操作引发回流时，将执行该线程。</li>
<li>  该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。</li>
</ul>
<h3 id="2-JS引擎线程"><a href="#2-JS引擎线程" class="headerlink" title="2.JS引擎线程"></a>2.JS引擎线程</h3><ul>
<li>  该线程当然是主要负责处理 JavaScript脚本，执行代码。</li>
<li>  也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。</li>
<li>  当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。</li>
</ul>
<h3 id="3-定时器触发线程"><a href="#3-定时器触发线程" class="headerlink" title="3.定时器触发线程"></a>3.定时器触发线程</h3><ul>
<li>  负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。</li>
<li>  主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。</li>
</ul>
<h3 id="4-事件触发线程"><a href="#4-事件触发线程" class="headerlink" title="4.事件触发线程"></a>4.事件触发线程</h3><ul>
<li>  主要负责将准备好的事件交给 JS引擎线程执行。</li>
</ul>
<p>比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。</p>
<h3 id="5-异步http请求线程"><a href="#5-异步http请求线程" class="headerlink" title="5.异步http请求线程"></a>5.异步http请求线程</h3><ul>
<li>  负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。</li>
<li>  主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。</li>
</ul>
<h2 id="三、浏览器中的-Event-Loop"><a href="#三、浏览器中的-Event-Loop" class="headerlink" title="三、浏览器中的 Event Loop"></a>三、浏览器中的 Event Loop</h2><h3 id="1-Micro-Task-与-Macro-Task"><a href="#1-Micro-Task-与-Macro-Task" class="headerlink" title="1.Micro-Task 与 Macro-Task"></a>1.Micro-Task 与 Macro-Task</h3><p>浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。<strong>宏任务队列可以有多个，微任务队列只有一个</strong>。</p>
<ul>
<li>  常见的 macro-task 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。</li>
<li>  常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5新特性) 等。</li>
</ul>
<h3 id="2-Event-Loop-过程解析"><a href="#2-Event-Loop-过程解析" class="headerlink" title="2.Event Loop 过程解析"></a>2.Event Loop 过程解析</h3><p>一个完整的 Event Loop 过程，可以概括为以下阶段：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-3d17264672d81429?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ul>
<li><p>  一开始执行栈空,我们可以把<strong>执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</strong>。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</p>
</li>
<li><p>  全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</p>
</li>
<li><p>  上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是<strong>一个一个</strong>执行的；而 micro-task 出队时，任务是<strong>一队一队</strong>执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</p>
</li>
<li><p>  <strong>执行渲染操作，更新界面</strong></p>
</li>
<li><p>  检查是否存在 Web worker 任务，如果有，则对其进行处理</p>
</li>
<li><p>  上述过程循环往复，直到两个队列都清空</p>
</li>
</ul>
<p>我们总结一下，每一次循环都是一个这样的过程：<br><img src="https://upload-images.jianshu.io/upload_images/24295319-2e962d7e3c0ba117?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><strong>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</strong></p>
<p>接下来我们看道例子来介绍上面流程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise1&#x27;</span>)  </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise2&#x27;</span>)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2</p>
<ul>
<li>  一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出Promise1，同时会生成一个宏任务 setTimeout2</li>
<li>  然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1</li>
<li>  在执行宏任务setTimeout1时会生成微任务Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2</li>
<li>  清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</li>
</ul>
<h2 id="四、Node-中的-Event-Loop"><a href="#四、Node-中的-Event-Loop" class="headerlink" title="四、Node 中的 Event Loop"></a>四、Node 中的 Event Loop</h2><h3 id="1-Node简介"><a href="#1-Node简介" class="headerlink" title="1.Node简介"></a>1.Node简介</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现（下文会详细介绍）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-b5ca6c975f5b5e68?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>Node.js的运行机制如下:</p>
<ul>
<li>  V8引擎解析JavaScript脚本。</li>
<li>  解析后的代码，调用Node API。</li>
<li>  libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li>
<li>  V8引擎再将结果返回给用户。</li>
</ul>
<h3 id="2-六个阶段"><a href="#2-六个阶段" class="headerlink" title="2.六个阶段"></a>2.六个阶段</h3><p>其中libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-4acdfcfb136d0fa8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>从上图中，大致看出node中的事件循环的顺序：</p>
<p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）…</p>
<ul>
<li>  timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</li>
<li>  I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li>
<li>  idle, prepare 阶段：仅node内部使用</li>
<li>  poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</li>
<li>  check 阶段：执行 setImmediate() 的回调</li>
<li>  close callbacks 阶段：执行 socket 的 close 事件回调</li>
</ul>
<p>注意：<strong>上面六个阶段都不包括 process.nextTick()</strong>(下文会介绍)</p>
<p>接下去我们详细介绍<code>timers</code>、<code>poll</code>、<code>check</code>这3个阶段，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。</p>
<h4 id="1-timer"><a href="#1-timer" class="headerlink" title="(1) timer"></a>(1) timer</h4><p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。<br>同样，<strong>在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行</strong>。</p>
<h4 id="2-poll"><a href="#2-poll" class="headerlink" title="(2) poll"></a>(2) poll</h4><p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p>
<p>1.回到 timer 阶段执行回调</p>
<p>2.执行 I/O 回调</p>
<p>并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情</p>
<ul>
<li>  如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li>
<li>如果 poll 队列为空时，会有两件事发生<ul>
<li>  如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li>
<li>  如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li>
</ul>
</li>
</ul>
<p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p>
<h4 id="3-check阶段"><a href="#3-check阶段" class="headerlink" title="(3) check阶段"></a>(3) check阶段</h4><p>setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。<br>我们先来看个例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"><span class="comment">//start=&gt;end=&gt;promise3=&gt;timer1=&gt;timer2=&gt;promise1=&gt;promise2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  一开始执行栈的同步任务（这属于宏任务）执行完毕后（依次打印出start end，并将2个timer依次放入timer队列）,会先去执行微任务（<strong>这点跟浏览器端的一样</strong>），所以打印出promise3</li>
<li>  然后进入timers阶段，执行timer1的回调函数，打印timer1，并将promise.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；这点跟浏览器端相差比较大，<strong>timers阶段有几个setTimeout/setInterval都会依次执行</strong>，并不像浏览器端，每执行一个宏任务后就去执行一个微任务（关于Node与浏览器的 Event Loop 差异，下文还会详细介绍）。</li>
</ul>
<h3 id="3-Micro-Task-与-Macro-Task"><a href="#3-Micro-Task-与-Macro-Task" class="headerlink" title="3.Micro-Task 与 Macro-Task"></a>3.Micro-Task 与 Macro-Task</h3><p>Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。</p>
<ul>
<li>  常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等。</li>
<li>  常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等。</li>
</ul>
<h3 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4.注意点"></a>4.注意点</h3><h4 id="1-setTimeout-和-setImmediate"><a href="#1-setTimeout-和-setImmediate" class="headerlink" title="(1) setTimeout 和 setImmediate"></a>(1) setTimeout 和 setImmediate</h4><p>二者非常相似，区别主要在于调用时机不同。</p>
<ul>
<li>  setImmediate 设计在poll阶段完成时执行，即check阶段；</li>
<li>  setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timeout</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> <span class="title">immediate</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;immediate&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。</li>
<li>首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的<br>  进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调</li>
<li>  如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了</li>
</ul>
<p>但当二者在异步i/o callback内部调用时，总是先执行setImmediate，再执行setTimeout</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.readFile(__filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。</p>
<h4 id="2-process-nextTick"><a href="#2-process-nextTick" class="headerlink" title="(2) process.nextTick"></a>(2) process.nextTick</h4><p>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line"> process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">   process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">     process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="五、Node与浏览器的-Event-Loop-差异"><a href="#五、Node与浏览器的-Event-Loop-差异" class="headerlink" title="五、Node与浏览器的 Event Loop 差异"></a>五、Node与浏览器的 Event Loop 差异</h2><p><strong>浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-e8b26e4f08c2daaa?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>接下我们通过一个例子来说明两者区别：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>浏览器端运行结果：<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></p>
<p>浏览器端的处理过程如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-7939ccbdc24dc58e?imageMogr2/auto-orient/strip"></p>
<p>Node端运行结果分两种情况：</p>
<ul>
<li>  如果是node11版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li>
<li>如果是node10及其之前版本：要看第一个定时器执行完，第二个定时器是否在完成队列中。<ul>
<li>  如果是第二个定时器还未在完成队列中，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li>
<li>  如果是第二个定时器已经在完成队列中，则最后的结果为<code>timer1=&gt;timer2=&gt;promise1=&gt;promise2</code>(下文过程解释基于这种情况下)</li>
</ul>
</li>
</ul>
<p>1.全局脚本（main()）执行，将2个timer依次放入timer队列，main()执行完毕，调用栈空闲，任务队列开始执行；</p>
<p>2.首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；</p>
<p>3.至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2</p>
<p>Node端的处理过程如下：<br><img src="https://upload-images.jianshu.io/upload_images/24295319-bd720ae559b10719?imageMogr2/auto-orient/strip"></p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>浏览器和Node 环境下，microtask 任务队列的执行时机不同</p>
<ul>
<li>  Node端，microtask 在事件循环的各个阶段之间执行</li>
<li>  浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件循环</tag>
        <tag>浏览器</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器存储</title>
    <url>/article/4df0e90e.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着移动网络的发展与演化，我们手机上现在除了有原生 App，还能跑“WebApp”——它即开即用，用完即走。一个优秀的 WebApp 甚至可以拥有和原生 App 媲美的功能和体验。WebApp 优异的性能表现，有一部分原因要归功于浏览器存储技术的提升。cookie存储数据的功能已经很难满足开发所需，逐渐被WebStorage、IndexedDB所取代，本文将介绍这几种存储方式的差异和优缺点。</p>
<h2 id="一、Cookie"><a href="#一、Cookie" class="headerlink" title="一、Cookie"></a>一、Cookie</h2><h3 id="1-Cookie的来源"><a href="#1-Cookie的来源" class="headerlink" title="1.Cookie的来源"></a>1.Cookie的来源</h3><p><strong>Cookie 的本职工作并非本地存储，而是“维持状态”</strong>。<br>因为<strong>HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存</strong>，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了Cookie。它就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。</p>
<p>我们可以把Cookie 理解为一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。</p>
<p>在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p>
<h3 id="2-什么是Cookie及应用场景"><a href="#2-什么是Cookie及应用场景" class="headerlink" title="2.什么是Cookie及应用场景"></a>2.什么是Cookie及应用场景</h3><p><strong>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储</strong>。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的set-cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/88a1801d209eabf4b1db25fed4ab204c.png"></p>
<p>如上图所示，<strong>Cookie 以键值对的形式存在</strong>。</p>
<p>典型的应用场景有：</p>
<ul>
<li><p>  记住密码，下次自动登录。</p>
</li>
<li><p>  购物车功能。</p>
</li>
<li><p>  记录用户浏览数据，进行商品（广告）推荐。</p>
</li>
</ul>
<h3 id="3-Cookie的原理及生成方式"><a href="#3-Cookie的原理及生成方式" class="headerlink" title="3.Cookie的原理及生成方式"></a>3.Cookie的原理及生成方式</h3><p>Cookie的原理<br><img src="https://img-blog.csdnimg.cn/img_convert/c897430d72b08689ed182f9f18f89654.png"></p>
<p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie信息发送给服务器，服务端会辨别用户身份，另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p>
<p>Cookie的生成方式主要有两种：</p>
<ul>
<li>  生成方式一：http response header中的set-cookie</li>
</ul>
<p>我们可以通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2018</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT;<span class="comment">//可以指定一个特定的过期时间（Expires）或有效期（Max-Age）</span></span><br></pre></td></tr></table></figure>

<p>当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</p>
<ul>
<li>  生成方式二：js中可以通过document.cookie可以读写cookie，以键值对的形式展示</li>
</ul>
<p>例如我们在掘金社区控制台输入以下三句代码，便可以在Chrome 的 Application 面板查看生成的cookie:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie=&quot;userName=hello&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie=&quot;gender=male&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie=&#x27;age=20;domain=.baidu.com&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/367a3e55cd823fa8c6490a8bbe3d47f8.png"></p>
<p>从上图中我们可以得出：</p>
<p><strong>Domain 标识指定了哪些域名可以接受Cookie</strong>。如果没有设置domain，就会自动绑定到执行语句的当前域。<br>如果设置为”.baidu.com”,则所有以”baidu.com”结尾的域名都可以访问该Cookie，所以在掘金社区上读取不到第三条代码存储Cookie值。</p>
<h3 id="4-Cookie的缺陷"><a href="#4-Cookie的缺陷" class="headerlink" title="4.Cookie的缺陷"></a>4.Cookie的缺陷</h3><ul>
<li>  Cookie 不够大</li>
</ul>
<p>Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。此外很多浏览器对一个站点的cookie个数也是有限制的。</p>
<p>这里需注意：各浏览器的cookie每一个<code>name=value</code>的value值大概在4k，所以4k并不是一个域名下所有的cookie共享的,而是一个name的大小。</p>
<ul>
<li>  过多的 Cookie 会带来巨大的性能浪费</li>
</ul>
<p>Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。</p>
<p>cookie是用来维护用户信息的，而域名(domain)下所有请求都会携带cookie，但对于静态文件的请求，携带cookie信息根本没有用，此时可以通过cdn（存储静态文件的）的域名和主站的域名分开来解决。</p>
<ul>
<li>  由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。</li>
</ul>
<h3 id="5-Cookie与安全"><a href="#5-Cookie与安全" class="headerlink" title="5.Cookie与安全"></a>5.Cookie与安全</h3><p>对于 cookie 来说，我们还需要注意安全性。<br><img src="https://img-blog.csdnimg.cn/img_convert/c2b2ddaa96d796e5305a99a1d826ef0a.png"></p>
<p>HttpOnly 不支持读写，浏览器不允许脚本操作document.cookie去更改cookie，<br>所以为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>

<p>标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p>
<p>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。</p>
<p><strong>HTML5中新增了本地存储的解决方案—-Web Storage，它分成两类：sessionStorage和localStorage</strong>。这样有了WebStorage后，cookie能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。</p>
<h2 id="二、LocalStorage"><a href="#二、LocalStorage" class="headerlink" title="二、LocalStorage"></a>二、LocalStorage</h2><h3 id="1-LocalStorage的特点"><a href="#1-LocalStorage的特点" class="headerlink" title="1.LocalStorage的特点"></a>1.LocalStorage的特点</h3><ul>
<li>  保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。</li>
<li>  大小为5M左右</li>
<li>  仅在客户端使用，不和服务端进行通信</li>
<li>  接口封装较好</li>
</ul>
<p>基于上面的特点，LocalStorage可以作为浏览器本地缓存方案，用来提升网页首屏渲染速度(根据第一请求返回时，将一些不变信息直接存储在本地)。</p>
<h3 id="2-存入-读取数据"><a href="#2-存入-读取数据" class="headerlink" title="2.存入/读取数据"></a>2.存入/读取数据</h3><p>localStorage保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。<br>存入数据使用setItem方法。它接受两个参数，第一个是键名，第二个是保存的数据。<br><code>localStorage.setItem(&quot;key&quot;,&quot;value&quot;);</code><br>读取数据使用getItem方法。它只有一个参数，就是键名。<br><code>var valueLocal = localStorage.getItem(&quot;key&quot;);</code></p>
<p>具体步骤，请看下面的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">if(window.localStorage)&#123;</span><br><span class="line">  localStorage.setItem（&#x27;name&#x27;,&#x27;world&#x27;）</span><br><span class="line">  localStorage.setItem（“gender&#x27;,&#x27;female&#x27;）</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> name=<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;name&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> gender=<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;gender&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;name&#x27;</span>).innerHTML=name</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;gender&#x27;</span>).innerHTML=gender</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3.使用场景"></a>3.使用场景</h3><p>LocalStorage在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 LocalStorage 来做。</p>
<p>这里给大家举个例子，考虑到 LocalStorage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：<br><img src="https://img-blog.csdnimg.cn/img_convert/d08269c01185f35b26be3750c8be86f2.png"></p>
<h2 id="三、sessionStorage"><a href="#三、sessionStorage" class="headerlink" title="三、sessionStorage"></a>三、sessionStorage</h2><p>sessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，<strong>即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享</strong>；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage的属性和方法与LocalStorage完全一样。</p>
<h3 id="1-sessionStorage的特点"><a href="#1-sessionStorage的特点" class="headerlink" title="1.sessionStorage的特点"></a>1.sessionStorage的特点</h3><ul>
<li>  会话级别的浏览器存储</li>
<li>  大小为5M左右</li>
<li>  仅在客户端使用，不和服务端进行通信</li>
<li>  接口封装较好</li>
</ul>
<p>基于上面的特点，sessionStorage 可以有效对表单信息进行维护，比如刷新时，表单信息不丢失。</p>
<h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h3><p>sessionStorage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 sessionStorage就主要是存储你本次会话的浏览足迹：<br><img src="https://img-blog.csdnimg.cn/img_convert/766e8aa98048064132011e2f3683bcd1.png"></p>
<p>lasturl 对应的就是你上一次访问的 URL 地址，这个地址是即时的。当你切换 URL 时，它随之更新，当你关闭页面时，留着它也确实没有什么意义了，干脆释放吧。这样的数据用 sessionStorage 来处理再合适不过。</p>
<h3 id="3-sessionStorage-、localStorage-和-cookie-之间的区别"><a href="#3-sessionStorage-、localStorage-和-cookie-之间的区别" class="headerlink" title="3.sessionStorage 、localStorage 和 cookie 之间的区别"></a>3.sessionStorage 、localStorage 和 cookie 之间的区别</h3><ul>
<li>  共同点：都是保存在浏览器端，且都遵循同源策略。</li>
<li>  不同点：在于生命周期与作用域的不同</li>
</ul>
<p>作用域：localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下<br><img src="https://img-blog.csdnimg.cn/img_convert/30482461b261171ee843eb9f98c6b30d.png"></p>
<p>生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</p>
<p>Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——<strong>它只能存储字符串</strong>，要想得到对象，我们还需要先对字符串进行一轮解析。</p>
<p>说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！</p>
<h2 id="四、IndexedDB"><a href="#四、IndexedDB" class="headerlink" title="四、IndexedDB"></a>四、IndexedDB</h2><p>IndexedDB 是一种低级API，**用于客户端存储大量结构化数据(包括文件和blobs)**。该API使用索引来实现对该数据的高性能搜索。IndexedDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。</p>
<h3 id="1-IndexedDB的特点"><a href="#1-IndexedDB的特点" class="headerlink" title="1.IndexedDB的特点"></a>1.IndexedDB的特点</h3><ul>
<li>  键值对储存。</li>
</ul>
<p>IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
<ul>
<li>  异步</li>
</ul>
<p>IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
<ul>
<li>  支持事务。</li>
</ul>
<p>IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
<ul>
<li>  同源限制</li>
</ul>
<p>IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
<ul>
<li>  储存空间大</li>
</ul>
<p>IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>
<ul>
<li>  支持二进制储存。</li>
</ul>
<p>IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>
<h3 id="2-IndexedDB的常见操作"><a href="#2-IndexedDB的常见操作" class="headerlink" title="2.IndexedDB的常见操作"></a>2.IndexedDB的常见操作</h3><p>在IndexedDB大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求——响应的模式。</p>
<ul>
<li>  建立打开IndexedDB —-<code>window.indexedDB.open(&quot;testDB&quot;)</code></li>
</ul>
<p>这条指令并不会返回一个DB对象的句柄，我们得到的是一个<code>IDBOpenDBRequest</code>对象，而我们希望得到的DB对象在其result属性中<br><img src="https://img-blog.csdnimg.cn/img_convert/a442775ca09c62b34a95977420a6a14d.png"></p>
<p>除了result，IDBOpenDBRequest接口定义了几个重要属性:</p>
<p>onerror: 请求失败的回调函数句柄</p>
<p>onsuccess:请求成功的回调函数句柄</p>
<p>onupgradeneeded:请求数据库版本变化句柄</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">openDB</span>(<span class="params">name</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> request=<span class="built_in">window</span>.indexedDB.open(name)<span class="comment">//建立打开IndexedDB</span></span></span><br><span class="line"><span class="javascript">request.onerror=<span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">&#x27;open indexdb error&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">request.onsuccess=<span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">myDB.db=e.target.result<span class="comment">//这是一个 IDBDatabase对象，这就是IndexedDB对象</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(myDB.db)<span class="comment">//此处就可以获取到db实例</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myDB=&#123;</span></span><br><span class="line"><span class="javascript"><span class="attr">name</span>:<span class="string">&#x27;testDB&#x27;</span>,</span></span><br><span class="line"><span class="javascript"><span class="attr">version</span>:<span class="string">&#x27;1&#x27;</span>,</span></span><br><span class="line"><span class="javascript"><span class="attr">db</span>:<span class="literal">null</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">openDB(myDB.name)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台得到一个 IDBDatabase对象，这就是IndexedDB对象<br><img src="https://img-blog.csdnimg.cn/img_convert/07eb89f08b4feb1b018735dc77e3f75a.png"></p>
<ul>
<li>  关闭IndexedDB—-<code>indexdb.close()</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function closeDB(db)&#123;</span><br><span class="line">    db.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  删除IndexedDB—-<code>window.indexedDB.deleteDatabase(indexdb)</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteDB</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  indexedDB.deleteDatabase(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-WebStorage、cookie-和-IndexedDB之间的区别"><a href="#3-WebStorage、cookie-和-IndexedDB之间的区别" class="headerlink" title="3.WebStorage、cookie 和 IndexedDB之间的区别"></a>3.WebStorage、cookie 和 IndexedDB之间的区别</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/3af7807f9d0222b50d94a1afa72070b9.png"></p>
<p>从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正是浏览器存储、缓存技术的出现和发展，为我们的前端应用带来了无限的转机。近年来基于存储、缓存技术的第三方库层出不绝，此外还衍生出了 PWA 这样优秀的 Web 应用模型。总结下本文几个核心观点：</p>
<ul>
<li>  Cookie 的本职工作并非本地存储，而是“维持状态”</li>
<li>  Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制，不与服务端发生通信</li>
<li>  IndexedDB 用于客户端存储大量结构化数据</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>浏览器存储</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础知识总结</title>
    <url>/article/52752939.html</url>
    <content><![CDATA[<h2 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1. 计算机网络概述"></a>1. 计算机网络概述</h2><h3 id="1-1-基本术语"><a href="#1-1-基本术语" class="headerlink" title="1.1. 基本术语"></a>1.1. 基本术语</h3><ol>
<li> <strong>结点 （node）</strong> ：网络中的结点可以是计算机，集线器，交换机或路由器等。</li>
<li> <strong>链路（link ）</strong> : 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。</li>
<li> <strong>主机（host）</strong> ：连接在因特网上的计算机。</li>
<li> <strong>ISP（Internet Service Provider）</strong> ：因特网服务提供者（提供商）。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-eb908d456a660eb8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ISP (Internet Service Provider) Definition"></p>
<ol start="5">
<li> <strong>IXP（Internet eXchange Point）</strong> ： 互联网交换点 IXP 的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-c0c4e1a89c6ef651?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IXP Traffic Levels During the Stratos Skydive — RIPE Labs"></p>
<p><a href="https://labs.ripe.net/Members/fergalc/ixp-traffic-during-stratos-skydive">https://labs.ripe.net/Members/fergalc/ixp-traffic-during-stratos-skydive</a></p>
<ol start="6">
<li> <strong>RFC(Request For Comments)</strong> ：意思是“请求评议”，包含了关于 Internet 几乎所有的重要的文字资料。</li>
<li> <strong>广域网 WAN（Wide Area Network）</strong> ：任务是通过长距离运送主机发送的数据。</li>
<li> <strong>城域网 MAN（Metropolitan Area Network）</strong>：用来将多个局域网进行互连。</li>
<li> <strong>局域网 LAN（Local Area Network）</strong> ： 学校或企业大多拥有多个互连的局域网。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-fc9ad79b98e7e096?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MAN &amp; WMAN | Red de área metropolitana, Redes informaticas, Par trenzado"></p>
<p><a href="http://conexionesmanwman.blogspot.com/">http://conexionesmanwman.blogspot.com/</a></p>
<ol start="10">
<li> <strong>个人区域网 PAN（Personal Area Network）</strong> ：在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-255a5aab8a2cc52a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Advantages and disadvantages of personal area network (PAN) - IT Release"></p>
<p><a href="https://www.itrelease.com/2018/07/advantages-and-disadvantages-of-personal-area-network-pan/">https://www.itrelease.com/2018/07/advantages-and-disadvantages-of-personal-area-network-pan/</a></p>
<ol start="12">
<li><p> <strong>分组（packet ）</strong> ：因特网中传送的数据单元。由首部 header 和数据段组成。分组又称为包，首部可称为包头。</p>
</li>
<li><p> <strong>存储转发（store and forward ）</strong> ：路由器收到一个分组，先检查分组是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发送的输出端口地址，然后将该包发送出去。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-12a4b1f78b165ae4.gif?imageMogr2/auto-orient/strip"></p>
</li>
<li><p> <strong>带宽（bandwidth）</strong> ：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为 b/s。</p>
</li>
<li><p> <strong>吞吐量（throughput ）</strong> ：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。</p>
</li>
</ol>
<h3 id="1-2-重要知识点总结"><a href="#1-2-重要知识点总结" class="headerlink" title="1.2. 重要知识点总结"></a>1.2. 重要知识点总结</h3><ol>
<li> <strong>计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</strong></li>
<li> 小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则，其前身为 ARPANET。Internet 的推荐译名为因特网，现在一般流行称为互联网。</li>
<li> 路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</li>
<li> 互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。</li>
<li> 计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S 方式）和对等连接方式（P2P 方式）。</li>
<li> 客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</li>
<li> 按照作用范围的不同，计算机网络分为广域网 WAN，城域网 MAN，局域网 LAN，个人区域网 PAN。</li>
<li> <strong>计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</strong></li>
<li> 网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</li>
<li> <strong>五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。</strong></li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-cc80148d7005b258?imageMogr2/auto-orient/strip" alt="s"></p>
<p>下面的内容会介绍计算机网络的五层体系结构：<strong>物理层+数据链路层+网络层（网际层）+运输层+应用层</strong>。</p>
<h2 id="2-物理层（Physical-Layer）"><a href="#2-物理层（Physical-Layer）" class="headerlink" title="2. 物理层（Physical Layer）"></a>2. 物理层（Physical Layer）</h2><p><img src="https://upload-images.jianshu.io/upload_images/24295319-a6324f1262a8f0ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="物理层.png"></p>
<h3 id="2-1-基本术语"><a href="#2-1-基本术语" class="headerlink" title="2.1. 基本术语"></a>2.1. 基本术语</h3><ol>
<li><p> <strong>数据（data）</strong> :运送消息的实体。</p>
</li>
<li><p> <strong>信号（signal）</strong> ：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</p>
</li>
<li><p> <strong>码元（ code）</strong> ：在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。</p>
</li>
<li><p> <strong>单工（simplex ）</strong> : 只能有一个方向的通信而没有反方向的交互。</p>
</li>
<li><p> <strong>半双工（half duplex ）</strong> ：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</p>
</li>
<li><p> <strong>全双工（full duplex）</strong> : 通信的双方可以同时发送和接收信息。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-dab5cd970c1bda76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p> <strong>失真</strong>：失去真实性，主要是指接受到的信号和发送的信号不同，有磨损和衰减。影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量<br><img src="https://upload-images.jianshu.io/upload_images/24295319-74bb194cd67f5e9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
</ol>
<ol start="8">
<li> <strong>奈氏准则</strong> : 在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</li>
<li> <strong>香农定理</strong> ：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</li>
<li> <strong>基带信号（baseband signal）</strong> : 来自信源的信号。指没有经过调制的数字信号或模拟信号。</li>
<li> <strong>带通（频带）信号（bandpass signal）</strong> ：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。</li>
<li> <strong>调制（modulation ）</strong> : 对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。</li>
<li> <strong>信噪比（signal-to-noise ratio ）</strong> : 指信号的平均功率和噪声的平均功率之比，记为 S/N。信噪比（dB）=10*log10（S/N）。</li>
<li> <strong>信道复用（channel multiplexing ）</strong> ：指多个用户共享同一个信道。（并不一定是同时）。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-a1ba9b19b81f6431?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="信道复用技术"></p>
<ol start="15">
<li> <strong>比特率（bit rate ）</strong> ：单位时间（每秒）内传送的比特数。</li>
<li> <strong>波特率（baud rate）</strong> ：单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。</li>
<li> <strong>复用（multiplexing）</strong> ：共享信道的方法。</li>
<li> <strong>ADSL（Asymmetric Digital Subscriber Line ）</strong> ：非对称数字用户线。</li>
<li> <strong>光纤同轴混合网（HFC 网）</strong> :在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网</li>
</ol>
<h3 id="2-2-重要知识点总结"><a href="#2-2-重要知识点总结" class="headerlink" title="2.2. 重要知识点总结"></a>2.2. 重要知识点总结</h3><ol>
<li> <strong>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</strong></li>
<li> 一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</li>
<li> <strong>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。</strong></li>
<li> 根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</li>
<li> 根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</li>
<li> 来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li>
<li> 要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</li>
<li> 传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</li>
<li> 了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</li>
</ol>
<h3 id="2-3-补充"><a href="#2-3-补充" class="headerlink" title="2.3. 补充"></a>2.3. 补充</h3><h4 id="2-3-1-物理层主要做啥？"><a href="#2-3-1-物理层主要做啥？" class="headerlink" title="2.3.1. 物理层主要做啥？"></a>2.3.1. 物理层主要做啥？</h4><p>物理层主要做的事情就是 <strong>透明地传送比特流</strong>。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能能的各种可能事件的出现顺序）。</p>
<p><strong>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</strong> 现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p>
<h4 id="2-3-2-几种常用的信道复用技术"><a href="#2-3-2-几种常用的信道复用技术" class="headerlink" title="2.3.2. 几种常用的信道复用技术"></a>2.3.2. 几种常用的信道复用技术</h4><ol>
<li> <strong>频分复用(FDM)</strong> ：所有用户在同样的时间占用不同的带宽资源。</li>
<li> <strong>时分复用（TDM）</strong> ：所有用户在不同的时间占用同样的频带宽度（分时不分频）。</li>
<li> <strong>统计时分复用 (Statistic TDM)</strong> ：改进的时分复用，能够明显提高信道的利用率。</li>
<li> <strong>码分复用(CDM)</strong> ： 用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li>
<li> <strong>波分复用( WDM)</strong> ：波分复用就是光的频分复用。</li>
</ol>
<h4 id="2-3-3-几种常用的宽带接入技术，主要是-ADSL-和-FTTx"><a href="#2-3-3-几种常用的宽带接入技术，主要是-ADSL-和-FTTx" class="headerlink" title="2.3.3. 几种常用的宽带接入技术，主要是 ADSL 和 FTTx"></a>2.3.3. 几种常用的宽带接入技术，主要是 ADSL 和 FTTx</h4><p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ASDL 的快速版本是甚高速数字用户线 VDSL。），光纤同轴混合网 HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和 FTTx（即光纤到······）。</p>
<h2 id="3-数据链路层（Data-Link-Layer）"><a href="#3-数据链路层（Data-Link-Layer）" class="headerlink" title="3. 数据链路层（Data Link Layer）"></a>3. 数据链路层（Data Link Layer）</h2><p><img src="https://upload-images.jianshu.io/upload_images/24295319-856fb569df99d74d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="3-1-基本术语"><a href="#3-1-基本术语" class="headerlink" title="3.1. 基本术语"></a>3.1. 基本术语</h3><ol>
<li><p> <strong>链路（link）</strong> ：一个结点到相邻结点的一段物理链路。</p>
</li>
<li><p> <strong>数据链路（data link）</strong> ：把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路。</p>
</li>
<li><p> <strong>循环冗余检验 CRC（Cyclic Redundancy Check）</strong> ：为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术。</p>
</li>
<li><p> <strong>帧（frame）</strong> ：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。</p>
</li>
<li><p> <strong>MTU（Maximum Transfer Uint ）</strong> ：最大传送单元。帧的数据部分的的长度上限。</p>
</li>
<li><p> <strong>误码率 BER（Bit Error Rate ）</strong> ：在一段时间内，传输错误的比特占所传输比特总数的比率。</p>
</li>
<li><p> <strong>PPP（Point-to-Point Protocol ）</strong> ：点对点协议。即用户计算机和 ISP 进行通信时所使用的数据链路层协议。以下是 PPP 帧的示意图：<img src="https://upload-images.jianshu.io/upload_images/24295319-59ab01a77ee4aaf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p> <strong>MAC 地址（Media Access Control 或者 Medium Access Control）</strong> ：意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址 。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处。</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-9a36207377f22327?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ARP (Address Resolution Protocol) explained"></p>
<ol start="9">
<li> <strong>网桥（bridge）</strong> ：一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。</li>
<li> <strong>交换机（switch ）</strong> ：广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥</li>
</ol>
<h3 id="3-2-重要知识点总结"><a href="#3-2-重要知识点总结" class="headerlink" title="3.2. 重要知识点总结"></a>3.2. 重要知识点总结</h3><ol>
<li> 链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</li>
<li> 数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</li>
<li> 数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></li>
<li> <strong>循环冗余检验 CRC</strong> 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码</li>
<li> <strong>点对点协议 PPP</strong> 是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</li>
<li> PPPoE 是为宽带上网的主机使用的链路层协议</li>
<li> <strong>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</strong></li>
<li> 计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的 ROM 中</strong>。</li>
<li> 以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</li>
<li> 以太网采用的协议是具有冲突检测的<strong>载波监听多点接入 CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道</li>
<li> 以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</li>
<li> 使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</li>
</ol>
<h3 id="3-3-补充"><a href="#3-3-补充" class="headerlink" title="3.3. 补充"></a>3.3. 补充</h3><ol>
<li> 数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP 协议以及 CSMA/CD 协议）的特点</li>
<li> 数据链路层的三个基本问题：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong></li>
<li> 以太网的 MAC 层硬件地址</li>
<li> 适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合</li>
</ol>
<h2 id="4-网络层（Network-Layer）"><a href="#4-网络层（Network-Layer）" class="headerlink" title="4. 网络层（Network Layer）"></a>4. 网络层（Network Layer）</h2><p><img src="https://upload-images.jianshu.io/upload_images/24295319-d4c9d1bda90ba054.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="4-1-基本术语"><a href="#4-1-基本术语" class="headerlink" title="4.1. 基本术语"></a>4.1. 基本术语</h3><ol>
<li> <strong>虚电路（Virtual Circuit）</strong> : 在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li>
<li> <strong>IP（Internet Protocol ）</strong> : 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，是 TCP/IP 体系结构网际层的核心。配套的有 ARP，RARP，ICMP，IGMP。</li>
<li> <strong>ARP（Address Resolution Protocol）</strong> : 地址解析协议。地址解析协议 ARP 把 IP 地址解析为硬件地址。</li>
<li> <strong>ICMP（Internet Control Message Protocol ）</strong> ：网际控制报文协议 （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告）。</li>
<li> <strong>子网掩码（subnet mask ）</strong> ：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</li>
<li> **CIDR（ Classless Inter-Domain Routing ） **：无分类域间路由选择 （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）。</li>
<li> <strong>默认路由（default route）</strong> ：当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。</li>
<li> <strong>路由选择算法（Virtual Circuit）</strong> ：路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。</li>
</ol>
<h3 id="4-2-重要知识点总结"><a href="#4-2-重要知识点总结" class="headerlink" title="4.2. 重要知识点总结"></a>4.2. 重要知识点总结</h3><ol>
<li> <strong>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</strong></li>
<li> 在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</li>
<li> 分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明 IP 地址的类别。IP 地址是一种分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的 IP 地址</li>
<li> IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP 首部中的生存时间给出了 IP 数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</li>
<li> <strong>地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去广播方式发送 ARP 请求分组</strong></li>
<li> 无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好办法。CIDR 记法把 IP 地址后面加上斜线“/”，然后写上前缀所所占的位数。前缀（或网络前缀用来指明网络），前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”，IP 地址分配都以 CIDR 地址块为单位。</li>
<li> 网际控制报文协议是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 数据报并不是为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种 ICMP 差错报告报文和 ICMP 询问报文。</li>
<li> <strong>要解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议-IPv6。</strong> IPv6 所带来的变化有 ① 更大的地址空间（采用 128 位地址）② 灵活的首部格式 ③ 改进的选项 ④ 支持即插即用 ⑤ 支持资源的预分配 ⑥IPv6 的首部改为 8 字节对齐。</li>
<li> <strong>虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密。</strong></li>
<li> MPLS 的特点是：① 支持面向连接的服务质量 ② 支持流量工程，平衡网络负载 ③ 有效的支持虚拟专用网 VPN。MPLS 在入口节点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</li>
</ol>
<h2 id="5-传输层（Transport-Layer）"><a href="#5-传输层（Transport-Layer）" class="headerlink" title="5. 传输层（Transport Layer）"></a>5. 传输层（Transport Layer）</h2><p><img src="https://upload-images.jianshu.io/upload_images/24295319-b5c9040c63671937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="5-1-基本术语"><a href="#5-1-基本术语" class="headerlink" title="5.1. 基本术语"></a>5.1. 基本术语</h3><ol>
<li> <strong>进程（process）</strong> ：指计算机中正在运行的程序实体。</li>
<li> <strong>应用进程互相通信</strong> ：一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）。</li>
<li> <strong>传输层的复用与分用</strong> ：复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。</li>
<li> <strong>TCP（Transmission Control Protocol）</strong> ：传输控制协议。</li>
<li> <strong>UDP（User Datagram Protocol）</strong> ：用户数据报协议。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-d98341a4217be3c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ol>
<ol start="6">
<li> **端口（port） ** ：端口的目的是为了确认对方机器是那个进程在于自己进行交互，比如 MSN 和 QQ 的端口不同，如果没有端口就可能出现 QQ 进程和 MSN 交互错误。端口又称协议端口号。</li>
<li> <strong>停止等待协议（stop-and-wait）</strong> ：指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。</li>
<li> <strong>流量控制</strong> : 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li>
<li> <strong>拥塞控制</strong> ：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</li>
</ol>
<h3 id="5-2-重要知识点总结"><a href="#5-2-重要知识点总结" class="headerlink" title="5.2. 重要知识点总结"></a>5.2. 重要知识点总结</h3><ol>
<li> <strong>运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</strong></li>
<li> <strong>网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</strong></li>
<li> 运输层的两个重要协议是用户数据报协议 UDP 和传输控制协议 TCP。按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元 TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 TCP 报文段或 UDP 用户数据报。</li>
<li> <strong>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式。 TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</strong></li>
<li> 硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP 和 TCP 的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到 IP 层交上来的运输层报文时，就能够 根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方 IP 地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</li>
<li> 运输层用一个 16 位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由 TCP 和 UDP 来完成。</li>
<li> 运输层的端口号分为服务器端使用的端口号（0<del>1023 指派给熟知端口，1024</del>49151 是登记端口号）和客户端暂时使用的端口号（49152~65535）</li>
<li> <strong>UDP 的主要特点是 ① 无连接 ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</strong></li>
<li> <strong>TCP 的主要特点是 ① 面向连接 ② 每一条 TCP 连接只能是一对一的 ③ 提供可靠交付 ④ 提供全双工通信 ⑤ 面向字节流</strong></li>
<li> <strong>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP 地址：端口号）来表示。每一条 TCP 连接唯一被通信两端的两个端点所确定。</strong></li>
<li> 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li> 为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</li>
<li> 停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</li>
<li> TCP 报文段的前 20 个字节是固定的，后面有 4n 字节是根据需要增加的选项。因此，TCP 首部的最小长度是 20 字节。</li>
<li> <strong>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</strong></li>
<li> 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
<li> <strong>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</strong></li>
<li> <strong>TCP 的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</strong></li>
<li> 运输连接的三个阶段，即：连接建立，数据传送和连接释放。</li>
<li> <strong>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</strong></li>
<li> TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接</li>
</ol>
<h3 id="5-3-补充（重要）"><a href="#5-3-补充（重要）" class="headerlink" title="5.3. 补充（重要）"></a>5.3. 补充（重要）</h3><p>以下知识点需要重点关注：</p>
<ol>
<li> 端口和套接字的意义</li>
<li> UDP 和 TCP 的区别以及两者的应用场景</li>
<li> 在不可靠的网络上实现可靠传输的工作原理，停止等待协议和 ARQ 协议</li>
<li> TCP 的滑动窗口，流量控制，拥塞控制和连接管理</li>
<li> TCP 的三次握手，四次挥手机制</li>
</ol>
<h2 id="6-应用层（Application-Layer）"><a href="#6-应用层（Application-Layer）" class="headerlink" title="6. 应用层（Application Layer）"></a>6. 应用层（Application Layer）</h2><p><img src="https://upload-images.jianshu.io/upload_images/24295319-64721050ad3a81e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="6-1-基本术语"><a href="#6-1-基本术语" class="headerlink" title="6.1. 基本术语"></a>6.1. 基本术语</h3><ol>
<li> <strong>域名系统（DNS）</strong> ：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href="http://www.baidu.com/">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。我们可以将其理解为专为互联网设计的电话薄。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-321f7e7ca6c81a4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ol>
<p><a href="https://www.seobility.net/en/wiki/HTTP_headers">https://www.seobility.net/en/wiki/HTTP_headers</a></p>
<ol start="2">
<li> <strong>文件传输协议（FTP）</strong> ：FTP 是 File TransferProtocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于 Internet 上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的 FTP 应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在 FTP 的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。 “下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用 Internet 语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-e853f9b220621764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ol>
<ol start="3">
<li> <strong>简单文件传输协议（TFTP）</strong> ：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为 69。</li>
<li> <strong>远程终端协议（TELENET）</strong> ：Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。</li>
<li> <strong>万维网（WWW）</strong> ：WWW 是环球信息网的缩写，（亦作“Web”、“WWW”、“’W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，”环球网”等，常简称为 Web。分为 Web 客户端和 Web 服务器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览 Web 服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。万维网联盟（英语：World Wide Web Consortium，简称 W3C），又称 W3C 理事会。1994 年 10 月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</li>
<li> <strong>万维网的大致工作工程：</strong><br><img src="https://upload-images.jianshu.io/upload_images/24295319-3500918d244b3677.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ol>
<ol start="7">
<li> <strong>统一资源定位符（URL）</strong> ：统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</li>
<li> <strong>超文本传输协议（HTTP）</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了 HTTP 超文本传输协议标准架构的发展根基。</li>
</ol>
<p>HTTP 协议的本质就是一种浏览器与服务器之间约定好的通信格式。HTTP 的原理如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/24295319-67949264371299fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ol start="9">
<li> <strong>代理服务器（Proxy Server）</strong> ： 代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器工作，也可以在中间系统工作。</li>
<li> <strong>简单邮件传输协议(SMTP)</strong> : SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 通过 SMTP 协议所指定的服务器,就可以把 E-mail 寄到收信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-474e13443418ff47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li>
</ol>
<p><a href="https://www.campaignmonitor.com/resources/knowledge-base/what-is-the-code-that-makes-bcc-or-cc-operate-in-an-email/">https://www.campaignmonitor.com/resources/knowledge-base/what-is-the-code-that-makes-bcc-or-cc-operate-in-an-email/</a></p>
<ol start="11">
<li><p> <strong>搜索引擎</strong> :搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-9808cd4b8a7764ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</li>
<li><p> <strong>垂直搜索引擎</strong> ：垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。</p>
</li>
<li><p> <strong>全文索引</strong> :全文索引技术是目前搜索引擎的关键技术。试想在 1M 大小的文件中搜索一个词，可能需要几秒，在 100M 的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。</p>
</li>
<li><p> <strong>目录索引</strong> ：目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。</p>
</li>
</ol>
<h3 id="6-2-重要知识点总结"><a href="#6-2-重要知识点总结" class="headerlink" title="6.2. 重要知识点总结"></a>6.2. 重要知识点总结</h3><ol>
<li> 文件传输协议（FTP）使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可以同时为多个用户提供服务。在进进行文件传输时，FTP 的客户和服务器之间要先建立两个并行的 TCP 连接:控制连接和数据连接。实际用于传输文件的是数据连接。</li>
<li> 万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议 HTTP。HTTP 使用 TCP 连接进行可靠传输。但 HTTP 本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接（分为非流水线方式和流水线方式）</li>
<li> 电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</li>
<li> 一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</li>
</ol>
<h3 id="6-3-补充（重要）"><a href="#6-3-补充（重要）" class="headerlink" title="6.3. 补充（重要）"></a>6.3. 补充（重要）</h3><p>以下知识点需要重点关注：</p>
<ol>
<li> 应用层的常见协议（重点关注 HTTP 协议）</li>
<li> 域名系统-从域名解析出 IP 地址</li>
<li> 访问一个网站大致的过程</li>
<li> 系统调用和应用编程接口概念</li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>基础知识总结</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-原生JS</title>
    <url>/article/f3e36dc4.html</url>
    <content><![CDATA[<h2 id="1-Js基本数据类型有哪些"><a href="#1-Js基本数据类型有哪些" class="headerlink" title="1.Js基本数据类型有哪些"></a>1.Js基本数据类型有哪些</h2><p>7种,<code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Null</code>、<code>undefined</code>、<code>object</code>、<code>symbol</code>。</p>
<blockquote>
<p>在ES5的时候，我们认知的数据类型是前6种。</p>
<p>ES6 中新增了一种 <code>Symbol</code> 。</p>
<p>这种类型的对象永不相等，即始创建的时候传入相同的值，可以解决属性名冲突的问题，做为标记。</p>
</blockquote>
<hr>
<h2 id="2-Ajax如何使用"><a href="#2-Ajax如何使用" class="headerlink" title="2.Ajax如何使用"></a>2.Ajax如何使用</h2><blockquote>
<p><strong>全称：</strong><code>Asynchronous Javascript And XML</code>(异步传输+js+xml)。</p>
<p>所谓<strong>异步</strong>，在这里简单地解释就是：</p>
<p>向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是<strong>不会</strong>发生整页刷新的，提高了用户体验</p>
</blockquote>
<ol>
<li>创建<code>XMLHttpRequest</code>对象,也就是创建一个异步调用对象.</li>
<li>创建一个新的<code>HTTP</code>请求,并指定该HTTP请求的方法、URL及验证信息.</li>
<li>设置响应<code>HTTP</code>请求状态变化的函数.</li>
<li>发送<code>HTTP</code>请求.</li>
<li>获取异步调用返回的数据.</li>
<li>使用<code>JavaScript</code>和<code>DOM</code>实现局部刷新.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp = <span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">xmlHttp.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;demo.php&#x27;</span>,<span class="string">&#x27;true&#x27;</span>); </span><br><span class="line">xmlHttp.send() </span><br><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">   <span class="keyword">if</span>(xmlHttp.readyState === <span class="number">4</span> &amp; xmlHttp.status === <span class="number">200</span>)&#123; </span><br><span class="line">       <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-如何判断一个数据是NaN"><a href="#3-如何判断一个数据是NaN" class="headerlink" title="3.如何判断一个数据是NaN"></a>3.如何判断一个数据是NaN</h2><p><strong>注意</strong>:NaN首先是一个<code>number</code>类型，然后同时又有着<code>not a number</code>的意义，而不仅仅只是表达着<code>不是&quot;number类型&quot;</code></p>
<p>关于NaN的一些操作：</p>
<ol>
<li><strong>isNaN(n)</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a  = <span class="literal">NaN</span> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(a))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>Object.is(n)</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a  = <span class="literal">NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(a,<span class="literal">NaN</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>封装成方法：NaN连自己本身都不相等，所以可以利用这个特性来判断这个值是不是NaN</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isNaNMethod = <span class="function"><span class="params">v</span>=&gt;</span>v!==v &amp;&amp; <span class="literal">true</span> </span><br><span class="line">   <span class="built_in">console</span>.log(isNaNMethod(<span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">console</span>.log(isNaNMethod(<span class="string">&#x27;sdsd&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line">   <span class="built_in">console</span>.log(isNaNMethod(<span class="number">3</span>)); <span class="comment">// false</span></span><br><span class="line">   <span class="built_in">console</span>.log(isNaNMethod(<span class="string">&#x27;3.233&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line">   <span class="keyword">let</span> bq = &#123;<span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>&#125;</span><br><span class="line">   <span class="built_in">console</span>.log(isNaNMethod(bq)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>判断数组中是否含有NaN</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">NaN</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="literal">NaN</span>))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：不能用indexOf判断数组中是否含有NaN</strong></p>
<hr>
<h2 id="4-Js中null与undefined区别"><a href="#4-Js中null与undefined区别" class="headerlink" title="4.Js中null与undefined区别"></a>4.Js中null与undefined区别</h2><p><strong>Null</strong> 只有一个值，是 null，代表一个<code>空对象指针</code>。</p>
<p><strong>Undefined</strong> 只有一个值，是undefined。</p>
<p>当一个声明了一个变量未初始化时，得到的就是undefined。undefined 是从 null 中派生出来的。</p>
<p><strong>简单理解</strong>就是：undefined 是没有定义的，null 是定义了但是为空。</p>
<hr>
<h2 id="5-闭包是什么-有什么特性-对页面会有什么影响"><a href="#5-闭包是什么-有什么特性-对页面会有什么影响" class="headerlink" title="5.闭包是什么?有什么特性?对页面会有什么影响?"></a>5.闭包是什么?有什么特性?对页面会有什么影响?</h2><p>​        闭包可以简单理解成”定义在一个函数内部的函数”。<strong>当其中一个内部函数在包含它们的外部函数之外被调用时</strong>，就会形成闭包。</p>
<p><strong>特点：</strong></p>
<ol>
<li>函数嵌套函数。</li>
<li>函数内部可以引用外部的参数和变量。</li>
<li>参数和变量不会被垃圾回收机制回收。</li>
</ol>
<p><strong>用处</strong></p>
<p> 常驻内存会增大内存的使用量使用不：</p>
<ol>
<li>读取函数内部的变量；</li>
<li>这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除。</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>变量长期驻扎在内存中；</li>
<li>避免全局变量的污染；</li>
<li>私有成员的存在 ；</li>
</ol>
<p><strong>缺点：</strong></p>
<p>会造成内存泄露</p>
<h2 id="6-事件委托是什么？如何确定事件源"><a href="#6-事件委托是什么？如何确定事件源" class="headerlink" title="6.事件委托是什么？如何确定事件源"></a>6.事件委托是什么？如何确定事件源</h2><p>事件委托还有一个名字叫事件代理，JS高程上讲：</p>
<p>​        <strong>事件委托</strong>就是利用事件冒泡，只制定一个事件处理程序，就可以管理某一类型的所有事件。</p>
<p>​        <strong>在事件中,当前操作的那个元素就是事件源</strong>。比如网页元素中a标签和input都有onclick事件，当点击a发生onclick事件时，事件源就是a标签，当点击input发送onclic事件是，事件源就是input。</p>
<p><strong>如何获取事件源那？？</strong></p>
<blockquote>
<p>IE下：window.event.srcElement </p>
<p>标准下：event.target</p>
</blockquote>
<p>由此可见，我们是通过事件对象获取到的事件源。</p>
<hr>
<h2 id="7-本地存储与cookie的区别"><a href="#7-本地存储与cookie的区别" class="headerlink" title="7.本地存储与cookie的区别"></a>7.本地存储与cookie的区别</h2><p><strong>1.Cookie</strong> </p>
<p>​        是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为<u>4KB</u>左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p>
<p><strong>2.localStorage</strong></p>
<p>​        是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你方案是种不错的选择。</p>
<p><strong>3.sessionStorage</strong></p>
<p>​        与localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但<strong>当页面关闭后，sessionStorage 中的数据就会被清空</strong>。</p>
<p><strong>三者的异同</strong></p>
<table>
<thead>
<tr>
<th><em><strong>特性</strong></em></th>
<th><strong>Cookie</strong></th>
<th><strong>localStorage</strong></th>
<th><strong>sessionStorage</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据的生命期</td>
<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>
<td>除非被清除，否则永久保存</td>
<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>
</tr>
<tr>
<td>存放数据大小</td>
<td>4K左右</td>
<td>一般为5MB</td>
<td></td>
</tr>
<tr>
<td>与服务器端通信</td>
<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>
<td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
<td></td>
</tr>
<tr>
<td>易用性</td>
<td>需要程序员自己封装，源生的Cookie接口不友好</td>
<td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
<td></td>
</tr>
</tbody></table>
<p>**相同点:**都保存在浏览器端，同源的</p>
<p><strong>不同点：</strong></p>
<p><strong>①传递方式不同</strong></p>
<blockquote>
<ul>
<li><p>​        cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。</p>
</li>
<li><p>​        sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
</li>
</ul>
</blockquote>
<p><strong>②数据大小不同</strong></p>
<blockquote>
<ul>
<li><p>​        cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。</p>
</li>
<li><p>​        存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。</p>
</li>
<li><p>​        sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
</li>
</ul>
</blockquote>
<p><strong>③数据有效期不同</strong></p>
<blockquote>
<ul>
<li><p>​        sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</p>
</li>
<li><p>​        localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</p>
</li>
<li><p>​        cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</p>
</li>
</ul>
</blockquote>
<p><strong>④作用域不同</strong></p>
<blockquote>
<ul>
<li><p>​        sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</p>
</li>
<li><p>​        localStorage在所有同源窗口中都是共享的；</p>
</li>
<li><p>​        cookie也是在所有同源窗口中都是共享的。</p>
</li>
<li><p>​        Web Storage支持事件通知机制，可以将数据更新的通知发送给监听者。</p>
</li>
<li><p>​        Web Storage的api接口使用更方便。</p>
</li>
</ul>
</blockquote>
<hr>
<h2 id="8-ES6新特性"><a href="#8-ES6新特性" class="headerlink" title="8.ES6新特性"></a>8.ES6新特性</h2><ul>
<li><p><em><strong>const和let</strong></em></p>
</li>
<li><p><em><strong>模板字符串</strong></em></p>
</li>
<li><p><em><strong>箭头函数</strong></em></p>
</li>
<li><p><em><strong>函数的参数默认值</strong></em></p>
</li>
<li><p><em><strong>对象和数组解构</strong></em></p>
</li>
<li><p><em><strong>for…of 和 for…in</strong></em></p>
</li>
<li><p><em><strong>ES6中的类</strong></em></p>
</li>
</ul>
<hr>
<h2 id="9-Let与var与const的区别"><a href="#9-Let与var与const的区别" class="headerlink" title="9.Let与var与const的区别"></a>9.Let与var与const的区别</h2><ul>
<li><p><strong>var声明的变量会挂载在window上,而let和const声明的变量不会;</strong></p>
</li>
<li><p><strong>声明变量存在变量提升,let和const不存在变量提升</strong></p>
</li>
<li><p><strong>let和const声明形成块作用域</strong></p>
</li>
<li><p><strong>同一作用域下let和const不能声明同名变量,而var可以</strong></p>
</li>
<li><p><strong>let暂存死区</strong></p>
</li>
</ul>
<hr>
<h2 id="10-数组方法有哪些请简述"><a href="#10-数组方法有哪些请简述" class="headerlink" title="10.数组方法有哪些请简述"></a>10.数组方法有哪些请简述</h2><p><em><strong>arr.push()</strong></em> <em><strong>从后面添加元素，返回值为添加完后的数组的长度</strong></em></p>
<p><em><strong>arr.pop()</strong></em> <em><strong>从后面删除元素，只能是一个，返回值是删除的元素</strong></em></p>
<p><em><strong>arr.shift()</strong></em> <em><strong>从前面删除元素，只能删除一个 返回值是删除的元素</strong></em></p>
<p><em><strong>arr.unshift()</strong></em> <em><strong>从前面添加元素, 返回值是添加完后的数组的长度</strong></em></p>
<p> <em><strong>arr.splice(i,n)</strong></em> <em><strong>删除从i(索引值)开始之后的那个元素。返回值是删除的元素</strong></em></p>
<p><em><strong>arr.concat()</strong></em> <em><strong>连接两个数组 返回值为连接后的新数组</strong></em></p>
<p><em><strong>str.split()</strong></em> <em><strong>将字符串转化为数组</strong></em></p>
<p> <em><strong>arr.sort()</strong></em> <em><strong>将数组进行排序,返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的</strong></em></p>
<p><em><strong>arr.reverse()</strong></em> <em><strong>将数组反转,返回值是反转后的数组</strong></em></p>
<p> <em><strong>arr.slice(start,end)</strong></em> <em><strong>切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组</strong></em></p>
<p> <em><strong>arr.forEach(callback)</strong></em> <em><strong>遍历数组,无return 即使有return，也不会返回任何值，并且会影响原来的数组</strong></em></p>
<p> <em><strong>arr.map(callback)</strong></em> <em><strong>映射数组(遍历数组),有return 返回一个新数组 。</strong></em></p>
<p> <em><strong>arr.filter(callback)</strong></em> <em><strong>过滤数组，返回一个满足要求的数组</strong></em> </p>
<hr>
<h2 id="11-Json如何新增-删除键值对"><a href="#11-Json如何新增-删除键值对" class="headerlink" title="11.Json如何新增/删除键值对"></a>11.Json如何新增/删除键值对</h2><p>(1)数据结构是Object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr=&#123;&#125;;</span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line">jsonStr[<span class="string">&quot;name1&quot;</span>]=<span class="string">&quot;yu&quot;</span>;</span><br><span class="line">jsonStr[<span class="string">&quot;name2&quot;</span>]=<span class="string">&quot;jin&quot;</span>;</span><br><span class="line">$.each(jsonStr,<span class="function"><span class="keyword">function</span>(<span class="params">_key</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Push结果：&quot;</span>+_key+<span class="string">&quot;==&quot;</span>+jsonStr[_key]+<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">$.each(jsonStr,<span class="function"><span class="keyword">function</span>(<span class="params">_key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> key = _key;</span><br><span class="line">    <span class="keyword">var</span> value = jsonStr[_key];</span><br><span class="line">    <span class="keyword">if</span>(_key==<span class="string">&quot;name1&quot;</span>)</span><br><span class="line">    &#123;  <span class="comment">//删除</span></span><br><span class="line"><span class="keyword">delete</span> jsonStr[_key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">$.each(jsonStr,<span class="function"><span class="keyword">function</span>(<span class="params">_key</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;删除后的结果：&quot;</span>+_key+<span class="string">&quot;==&quot;</span>+jsonStr[_key]+<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>(2)数据结构是Array</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;[&#123;&quot;name&quot;:&quot;aa&quot;,&quot;age&quot;:&quot;23&quot;&#125;]&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> array=<span class="built_in">JSON</span>.parse(str);</span><br><span class="line"><span class="comment">//新增</span></span><br><span class="line">array.push(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;dd&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;25&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="keyword">var</span> obj=array.firstOrDefault(</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.name==<span class="string">&#x27;bb&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">obj.age=<span class="number">25</span>;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">array.delete(</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.name==<span class="string">&#x27;cc&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//转为json字符串</span></span><br><span class="line">str=<span class="built_in">JSON</span>.stringify(array);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="12-什么是面向对象请简述"><a href="#12-什么是面向对象请简述" class="headerlink" title="12.什么是面向对象请简述"></a>12.什么是面向对象请简述</h2><p>首先，我们要明确，<strong>面向对象</strong>不是语法，是一个思想，是一种编程模式</p>
<p>**面向过程(POP)**：关注点在于做了什么，描述的是发展的过程。</p>
<p>**面向对象(OOP)**：关注点在于能做什么，描述的是对象与对象之间的关系。</p>
<p>面向对象的<strong>特点</strong>：继承、多态、封装</p>
<hr>
<h2 id="13-普通函数和构造函数去的区别"><a href="#13-普通函数和构造函数去的区别" class="headerlink" title="13.普通函数和构造函数去的区别"></a>13.普通函数和构造函数去的区别</h2><p><strong>构造函数</strong>:如用函数用来初始化(使用new运算符)一个新建的对象，我们称之为构造函数(constructor)</p>
<p><strong>普通函数</strong>:不使用new运算符的函数就是普通函数</p>
<p><strong>区别</strong>：</p>
<ol>
<li><p>构造函数也是一个普通函数，创建方式和普通函数一样，但构造函数习惯上<strong>首字母大写</strong></p>
</li>
<li><p>构造函数和普通函数的区别在于：调用方式不一样。作用也不一样（<strong>构造函数用来新建实例对象</strong>）</p>
</li>
<li><p>调用方式不一样。</p>
<p>a. 普通函数的调用方式：<strong>直接调用</strong> <code>person()</code>;</p>
<p>b.构造函数的调用方式：<strong>需要使用new关键字来调用</strong> <code>new Person()</code>;</p>
</li>
<li><p>构造函数的函数名与类名相同：<code>Person()</code> 这个构造函数，<code>Person</code> 既是函数名，也是这个对象的类名</p>
</li>
<li><p>构造函数内部可以使用<code>this</code>关键字；<strong>普通函数内部不建议使用</strong><code>this</code>，因为这时候<strong>this指向的是window全局对象</strong>，这样无意间就会为window添加了一些全局变量或函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,job,age</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.name=name;</span><br><span class="line">     <span class="built_in">this</span>.job=job;</span><br><span class="line">     <span class="built_in">this</span>.age=age;</span><br><span class="line">     <span class="built_in">this</span>.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">          alert(<span class="string">&quot;Hi&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure></li>
<li><p>构造函数的执行流程</p>
<ol>
<li><p>立刻在堆内存中创建一个新的对象<code>var p = &#123;&#125;;</code></p>
</li>
<li><p>将新建的对象设置为函数中的this</p>
</li>
<li><p>逐个执行函数中的代码</p>
</li>
<li><p>将新建的对象作为返回值</p>
</li>
</ol>
</li>
<li><p>普通函数例子：因为没有返回值，所以为undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> per = person(); </span><br><span class="line">consoLe.log(per);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li>
<li><p>构造函数例子：构造函数会马上创建一个新对象，并将该新对象作为返回值返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(per);<span class="comment">//[object object]</span></span><br></pre></td></tr></table></figure></li>
<li><p>用instanceof 可以检查一个对象是否是一个类的实例，是则返回true；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name , age , gender</span>)</span>&#123;</span><br><span class="line"><span class="comment">//往对象中添加属性和属性值</span></span><br><span class="line"><span class="built_in">this</span>.name = name ;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line"><span class="built_in">this</span>.gender = gender</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">&quot;张三”,18,&quot;</span>男<span class="string">&quot;);</span></span><br><span class="line"><span class="string">console.log(per);//[object object]  马上创建一个对象</span></span><br><span class="line"><span class="string">console.log(per.name);//&quot;</span>张三”</span><br><span class="line"><span class="built_in">console</span>.log(per.age);<span class="comment">//&quot;18&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(per <span class="keyword">instanceof</span> Person);<span class="comment">//&quot;true&quot; per为Person函数的实例，返回true</span></span><br></pre></td></tr></table></figure>

<p>​    所有对象都是Object对象的后代，所以任何对象和Object做instanceof都会返回true</p>
</li>
</ol>
<hr>
<h2 id="14-请简述原型-原型链-继承"><a href="#14-请简述原型-原型链-继承" class="headerlink" title="14.请简述原型/原型链/继承"></a>14.请简述原型/原型链/继承</h2><p>​        <strong>原型</strong>：<strong>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个<code>prototype</code>属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。</strong></p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>
<img src="https://img-blog.csdnimg.cn/img_convert/67e633b1b48eb146b188536fa57cbf5f.png" style="zoom:67%;" />

<p>​        <strong>原型对象</strong>就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p>
<p>​        <strong>隐式原型(<em>proto</em>)</strong>:上面说的这个原型是JavaScript中的内置属性<code>prototype</code>，此属性继承自object对象，在脚本中没有标准的方式访问<code>prototype</code>，但Firefox、Safari和Chrome在每个对象上都支持一个属性<code>_proto_</code>，隐式原型的作用是用来构成原型链，实现基于原型的继承</p>
<p>​        <strong>显示原型(prototype)</strong>:每一个函数在创建之后，便会拥有一个prototype属性，这个属性指向函数的原型对象，显示原型的作用是用来实现基于原型的继承与属性的共享</p>
<p>​        <strong>原型链</strong>:在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。<strong>如果在Object原型中依然没有找到，则返回undefined</strong></p>
<blockquote>
<ol>
<li>原型链解决的主要是继承问题</li>
<li>每个对象拥有一个原型对象，通过 proto 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null(<code>Object.proptotype.__proto__</code>指向的是null)。这种关系被称为原型链(prototype chain)，通过原型链一个对象可以拥有定义在其他对象中的属性和方法</li>
<li>构造函数 Parent、Parent.prototype 和 实例 p 的关系如下:(<code>p.__proto__ === Parent.prototype</code>)</li>
</ol>
</blockquote>
<hr>
<h2 id="15-Promise的理解"><a href="#15-Promise的理解" class="headerlink" title="15.Promise的理解"></a>15.Promise的理解</h2><p>​        Promise 是异步编程的一种解决方案：</p>
<ol>
<li>从语法上讲，promise是一个对象，从它可以获取异步操作的消息；</li>
<li>从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</li>
<li>promise有三种状态： **pending(等待态)<strong>，</strong>resolved(成功态)<strong>，</strong>rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。</li>
<li>在需要用到异步处理并且需要回调值时，但是promise<strong>本身并不是异步的</strong>。</li>
</ol>
<hr>
<h2 id="16-Promise在哪里使用过"><a href="#16-Promise在哪里使用过" class="headerlink" title="16.Promise在哪里使用过"></a>16.Promise在哪里使用过</h2><p>加载图片，ajax请求，vue接口请求</p>
<hr>
<h2 id="17-请简述async的用法"><a href="#17-请简述async的用法" class="headerlink" title="17.请简述async的用法"></a>17.请简述async的用法</h2><p><strong>(1)async函数的基本形式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"><span class="comment">//Class 的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cachePromise = caches.open(<span class="string">&#x27;avatars&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getAvatar</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="built_in">this</span>.cachePromise;</span><br><span class="line">    <span class="keyword">return</span> cache.match(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> Storage();</span><br><span class="line">storage.getAvatar(<span class="string">&#x27;jake&#x27;</span>).then(…);</span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>(2) async函数的返回值总是一个Promise</strong></p>
<p>​        无论async函数有无await操作，其总是返回一个Promise。</p>
<ol>
<li><p>没有显式return，相当于return Promise.resolve(undefined);</p>
</li>
<li><p>return非Promise的数据data，相当于return Promise.resolve(data);</p>
</li>
<li><p>return Promise, 会得到Promise对象本身</p>
<blockquote>
<p>​    async总是返回Promise，因此，其后面可以直接调用then方法，函数内部return返回的值，会成为then回调函数的参数函数内部抛出的错误，会被then的第二个函数或catch方法捕获到</p>
</blockquote>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正常返回值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    retrun <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v));<span class="comment">//hello world</span></span><br><span class="line"><span class="comment">//抛出错误</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">f().then(</span><br><span class="line">    <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v),</span><br><span class="line">    <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e) <span class="comment">//Error: 出错了</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="18-jQuery相关的知识"><a href="#18-jQuery相关的知识" class="headerlink" title="18.jQuery相关的知识"></a>18.jQuery相关的知识</h2><p> 见jquery</p>
<hr>
<h2 id="19-Css预处理sass-less是什么？为什么使用他们"><a href="#19-Css预处理sass-less是什么？为什么使用他们" class="headerlink" title="19.Css预处理sass less是什么？为什么使用他们"></a>19.Css预处理sass less是什么？为什么使用他们</h2><p>​        <strong>Sass 和 LESS</strong>都是是 CSS 预处理器，是 CSS 上的一种抽象层，是一种特殊的 语法/语言 最终会编译成 CSS</p>
<p>​        <strong>less</strong>是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数.。less 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可一在服务端运行(需要借助 Node.js)。</p>
<p><strong>为什么要使用它们？</strong></p>
<ol>
<li>结构清晰，便于扩展。</li>
<li>可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。</li>
<li>可以轻松实现多重继承。</li>
<li>完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li>
</ol>
<hr>
<h2 id="20-Js中-call-与-apply-区别"><a href="#20-Js中-call-与-apply-区别" class="headerlink" title="20.Js中.call()与.apply()区别"></a>20.Js中.call()与.apply()区别</h2><p><code>apply</code>接受两个参数，第一个参数指定了函数体内<code>this</code>对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，</p>
<p><code>apply</code>方法把这个集合中的元素作为参数传递给被调用的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([a,b,c])</span><br><span class="line">&#125;</span><br><span class="line">func.apply(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>

<p><code>call</code>传入的参数数量不固定，跟<code>apply</code>相同的是，第一个参数也是代表函数体内的<code>this</code>指向，从第二个参数开始往后，每个参数被依次传入函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([a,b,c])</span><br><span class="line">&#125;</span><br><span class="line">func.call(<span class="literal">null</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">// [3,4,5]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="21-为什么会造成跨域-请简述同源策略"><a href="#21-为什么会造成跨域-请简述同源策略" class="headerlink" title="21.为什么会造成跨域/请简述同源策略"></a>21.为什么会造成跨域/请简述同源策略</h2><p><strong>为什么会造成跨域</strong></p>
<p>​        因为浏览器的<strong>同源政策</strong>，就会产生跨域。比如说发送的异步请求是不同的两个源，就比如是不同的的两个端口或者不同的两个协议或者不同的域名。由于浏览器为了安全考虑，就会产生一个同源政策，不是同一个地方出来的是不允许进行交互的。</p>
<p><strong>简述同源策略</strong></p>
<p>​        <strong>同源策略</strong>是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。<br>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。</p>
<p>​        指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<hr>
<h2 id="22-This指向"><a href="#22-This指向" class="headerlink" title="22.This指向"></a>22.This指向</h2><ol>
<li><p>如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window。</p>
<blockquote>
<p>这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。</p>
</blockquote>
</li>
<li><p>如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。</p>
</li>
<li><p>一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。</p>
</li>
</ol>
<hr>
<h2 id="23-请输出三种减少页面加载时间的方式"><a href="#23-请输出三种减少页面加载时间的方式" class="headerlink" title="23.请输出三种减少页面加载时间的方式"></a>23.请输出三种减少页面加载时间的方式</h2><ol>
<li>优化图片 </li>
<li>图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）</li>
<li>优化CSS（压缩合并css，如margin-top,margin-left…)</li>
<li>网址后加斜杠，对服务器而言，不加斜杠服务器会多一次判断的过程，加斜杠就会直接返回网站设置的存放在网站根目录下的默认页面。</li>
<li>标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）</li>
<li>减少http请求（合并文件，合并图片）。</li>
</ol>
<hr>
<h2 id="24-什么是jsonp，工作原理是什么？他为什么不是真正的ajax"><a href="#24-什么是jsonp，工作原理是什么？他为什么不是真正的ajax" class="headerlink" title="24.什么是jsonp，工作原理是什么？他为什么不是真正的ajax"></a>24.什么是jsonp，工作原理是什么？他为什么不是真正的ajax</h2><p><strong>Jsonp其实就是一个跨域解决方案。</strong></p>
<p><strong>jsonp的原理</strong>:就是利用浏览器可以动态地插入一段js并执行的特点完成的。</p>
<p><strong>为什么不是真正的 ajax?</strong>   </p>
<p><strong>ajax的核心</strong>：通过<code>XmlHttpRequest</code>获取非本页内容，</p>
<p><strong>jsonp的核心</strong>：动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。</p>
<p><strong>相同点：</strong></p>
<p>​        ajax和jsonp的调用方式很像，目的一样，都是请求url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；</p>
<p><strong>不同点：</strong></p>
<ol>
<li><p>实质不同<br>ajax的核心是通过xmlHttpRequest获取非本页内容</p>
<p>jsonp的核心是动态添加script标签调用服务器提供的js脚本</p>
</li>
<li><p>ajax通过服务端代理一样跨域</p>
<p>jsonp也不并不排斥同域的数据的获取</p>
</li>
<li><p>jsonp是一种方式或者说非强制性的协议</p>
<p>ajax也不一定非要用json格式来传递数据　</p>
</li>
<li><p>jsonp只支持get请求，ajax支持get和post请求</p>
</li>
</ol>
<hr>
<h2 id="25-请掌握2种以上数组去重的方式"><a href="#25-请掌握2种以上数组去重的方式" class="headerlink" title="25.请掌握2种以上数组去重的方式"></a>25.请掌握2种以上数组去重的方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> originalArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p><strong>方式1：(ES6的Set集合)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(originalArray));</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// -&gt; [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>方式2:(map集合)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = [];</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> originalArray) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!map.has(v)) &#123;</span><br><span class="line">        map.set(v, <span class="literal">true</span>);</span><br><span class="line">        result.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// -&gt; [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>方式3:(Includes)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> originalArray) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.includes(v)) &#123;</span><br><span class="line">        result.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// -&gt; [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>方式4:(前后对比)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; originalArray.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; originalArray.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (originalArray[i] === originalArray[j]) &#123;</span><br><span class="line">            originalArray.splice(j, <span class="number">1</span>);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(originalArray); <span class="comment">// -&gt; [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>方式5:(Filter过滤器)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> result = originalArray.filter(<span class="function"><span class="params">item</span> =&gt;</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span>:(obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>));</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// -&gt; [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="26-深浅拷贝是什么-如何实现？"><a href="#26-深浅拷贝是什么-如何实现？" class="headerlink" title="26.深浅拷贝是什么,如何实现？"></a>26.深浅拷贝是什么,如何实现？</h2><blockquote>
<p><strong>浅拷贝</strong>只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，</p>
<p><strong>深拷贝</strong>不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。</p>
<p><strong>浅拷贝</strong>只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p>
<p><strong>但深拷贝</strong>会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</p>
</blockquote>
<p>​        <strong>浅拷贝</strong>子对象复制父对象，父子对象发生关联，两者属性值指向同一内存空间。简单来讲，就是改变其中一个对象，另一个对象也会跟着改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],b = a;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b) <span class="comment">// [3,1,2] [3,1,2]</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>深拷贝</strong>拷贝对象各个层级的属性。简单的讲，就是复制出来的每个对象都有属于自己的内存空间，不会互相干扰。</p>
<p><strong>借用JSON对象的 parse（转JavaScript 对象） 和 stringify（转json字符串）</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line">    <span class="keyword">let</span> objClone = <span class="built_in">JSON</span>.parse(newObj);</span><br><span class="line">    <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="27-为什么js是弱类型语言"><a href="#27-为什么js是弱类型语言" class="headerlink" title="27.为什么js是弱类型语言"></a>27.为什么js是弱类型语言</h2><p>​        <strong>弱类型语言</strong>是相对强类型语言来说的。</p>
<p>​        在强类型语言中，变量类型有多种，例如<code>int</code> <code>char</code> <code>float</code> <code>boolean</code> 等不同的类型相互转换有时需要强制转换而javascript只有一种类型<code>var</code>，为变量赋值时会自动判断类型并进行转换，所以javascript是弱语言就体现在变量定义类型var上了 </p>
<hr>
<h2 id="28-怎么转换less为css"><a href="#28-怎么转换less为css" class="headerlink" title="28.怎么转换less为css"></a>28.怎么转换less为css</h2><p>​        <strong>Less</strong> 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。</p>
<ol>
<li>首先，你要确认你的电脑已经安装了node。</li>
<li>使用 npm 安装 lessc，命令行：<br><code>npm install -g less</code></li>
<li>然后，进入需要转换的less文件的目标位置。</li>
<li>最后，你只需输入以下两条命令：</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install -g less</span><br><span class="line">lessc less文件名.less 生成的css文件名.css</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="29-echarts使用最多的是什么"><a href="#29-echarts使用最多的是什么" class="headerlink" title="29.echarts使用最多的是什么"></a>29.echarts使用最多的是什么</h2><blockquote>
<p>​        商业级数据图表，它是一个纯JavaScript的图标库，兼容绝大部分的浏览器，底层依赖轻量级的canvas类库ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。创新的拖拽重计算、数据视图、值域漫游等特性大大增强了用户体验，赋予了用户对数据进行挖掘、整合的能力。</p>
</blockquote>
<p><strong>折线图（区域图）、柱状图（条状图）、散点图（气泡图）、K线图、饼图（环形图）</strong></p>
<p><strong>雷达图（填充雷达图）</strong></p>
<hr>
<h2 id="30-For循环与map循环有什么区别"><a href="#30-For循环与map循环有什么区别" class="headerlink" title="30.For循环与map循环有什么区别"></a>30.For循环与map循环有什么区别</h2><blockquote>
<p><strong>for</strong>:遍历对象自身的和继承的可枚举的属性，也就是说会包括那些原型链上的属性。如果想要仅迭代自身的属性，那么在使用 for…in</p>
<p><strong>forEach</strong>:只能遍历数组，不能中断，没有返回值(或认为返回值是undefined)</p>
<p><strong>map</strong>:只能遍历数组，不能中断，返回值是修改后的数组</p>
</blockquote>
<p><strong>forEach和map的区别</strong></p>
<p><strong>相同点</strong></p>
<ol>
<li>都是循环遍历数组中的每一项</li>
<li>forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item(当前每一项)，index(索引值)，arr(原数组)</li>
<li>匿名函数中的this都是指向window</li>
<li>只能遍历数组,都不会改变原数组</li>
</ol>
<p><strong>区别</strong><br><strong>map方法</strong></p>
<ol>
<li>map方法<strong>返回一个新的数组</strong>，数组中的元素为原始数组调用函数处理后的值。</li>
<li>map方法不会对空数组进行检测，map方法<strong>不会改变原始数组</strong>。</li>
<li>浏览器支持：chrome、Safari1.5+、opera都支持，IE9+,</li>
<li>若arr为空数组，则map方法返回的也是一个空数组。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;&#125;,thisValue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> str = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;原数组arr:&quot;</span>,arr); <span class="comment">//注意这里执行5次</span></span><br><span class="line">    <span class="keyword">return</span> item/<span class="number">2</span>;</span><br><span class="line">&#125;,<span class="built_in">this</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//[0,1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<p><strong>forEach方法</strong></p>
<ol>
<li>forEach方法用来调用数组的每个元素，将元素传给回调函数</li>
<li>forEach对于空数组是不会调用回调函数的。</li>
<li>无论arr是不是空数组，forEach返回的都是undefined。这个方法只是将数组中的每一项作为callback的参数执行一次。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;&#125;,<span class="built_in">this</span>)</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> str = arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line">    sum += item;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sum的值为：&quot;</span>,sum); <span class="comment">//0 2 6 12 20</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//window</span></span><br><span class="line">&#125;,<span class="built_in">this</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">//20</span></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="31-请写出一个简单的类与继承"><a href="#31-请写出一个简单的类与继承" class="headerlink" title="31.请写出一个简单的类与继承"></a>31.请写出一个简单的类与继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _this = <span class="built_in">this</span>; <span class="comment">// 声明一个 _this 指向当前的this</span></span><br><span class="line">	<span class="comment">// 定义一个类名为 myLike 的类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">myLike</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 定义一个 JS 构造器</span></span><br><span class="line">		<span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">			_this.type = type;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 创建实例方法</span></span><br><span class="line">		<span class="function"><span class="title">sayType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&#x27;我喜欢&#x27;</span> + _this.type);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建一个类名为 Programmer 的类的继承 myLike 类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">extends</span> <span class="title">myLike</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">			<span class="comment">// 直接调用父类构造器进行初始化操作</span></span><br><span class="line">			<span class="built_in">super</span>(type);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="title">program</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&quot;我是一个写代码的游戏主播&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 测试我刚创建的类</span></span><br><span class="line">	<span class="keyword">var</span> goPlay = <span class="keyword">new</span> myLike(<span class="string">&#x27;打游戏&#x27;</span>), <span class="comment">// 声明一个打游戏的对象</span></span><br><span class="line">		writeCode = <span class="keyword">new</span> Programmer(<span class="string">&#x27;写代码&#x27;</span>); <span class="comment">// 声明一个写代码的对象</span></span><br><span class="line">	<span class="comment">// 开始测试程序结果</span></span><br><span class="line">	goPlay.sayType(); <span class="comment">// 输出  我喜欢打游戏</span></span><br><span class="line">	writeCode.sayType(); <span class="comment">// 输出  我喜欢写代码</span></span><br><span class="line">	writeCode.program(); <span class="comment">// 输出  我是一个写代码的游戏主播</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="32-同步与异步的区别-阻塞与非阻塞区别"><a href="#32-同步与异步的区别-阻塞与非阻塞区别" class="headerlink" title="32.同步与异步的区别/阻塞与非阻塞区别"></a>32.同步与异步的区别/阻塞与非阻塞区别</h2><p>​        “阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。<br><strong>同步与异步</strong><br>​        同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication/ asynchronous communication)</p>
<p>​        所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p>
<p>​        而异步则是相反，<strong>调用在发出之后，这个调用就直接返回了，所以没有返回结果</strong>。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>典型的异步编程模型比如Node.js</p>
<blockquote>
<p>举个通俗的例子：<br>        你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
</blockquote>
<p><strong>阻塞与非阻塞</strong><br>        阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p>
<p>​        <strong>阻塞调用</strong>是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>​        <strong>非阻塞调用</strong>指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<blockquote>
<p>还是上面的例子，<br>        你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
</blockquote>
<hr>
<h2 id="33-重绘和回流是什么"><a href="#33-重绘和回流是什么" class="headerlink" title="33.重绘和回流是什么"></a>33.重绘和回流是什么</h2><p>​        引起DOM树结构变化，页面布局变化的行为叫<strong>回流</strong>，且回流<strong>一定</strong>伴随重绘。</p>
<p>​        只是样式的变化，不会引起DOM树变化，页面布局变化的行为叫<strong>重绘</strong>，且重绘<strong>不一定</strong>会便随回流。</p>
<hr>
<h2 id="34-http是什么？有什么特点"><a href="#34-http是什么？有什么特点" class="headerlink" title="34.http是什么？有什么特点"></a>34.http是什么？有什么特点</h2><p><strong>超文本</strong> <strong>传输</strong> <strong>协议</strong></p>
<p>特点:</p>
<ol>
<li>支持客户/服务器模式；</li>
<li>简单快速；</li>
<li>灵活；</li>
<li>无连接；(是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接)</li>
<li>无状态。(http协议没法保存客户机信息，也就没法区分每次请求的不同之处)</li>
</ol>
<hr>
<h2 id="35-HTTP协议和HTTPS区别"><a href="#35-HTTP协议和HTTPS区别" class="headerlink" title="35.HTTP协议和HTTPS区别"></a>35.HTTP协议和HTTPS区别</h2><ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的<strong>端口也不一样</strong>，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ol>
<hr>
<h2 id="36-原型和继承，prototype，call和apply继承的区别（第一个参数是相同的，第二个的区别在哪）"><a href="#36-原型和继承，prototype，call和apply继承的区别（第一个参数是相同的，第二个的区别在哪）" class="headerlink" title="36.原型和继承，prototype，call和apply继承的区别（第一个参数是相同的，第二个的区别在哪）"></a>36.原型和继承，prototype，call和apply继承的区别（第一个参数是相同的，第二个的区别在哪）</h2><p><strong>js继承的6种方式</strong></p>
<p>​        想要继承，就必须要提供个父类（继承谁，提供继承的属性）</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTkwNy85NDA4ODQtMjAxOTA3MTcxNjIwNTQyNjctMTIwMDIxMTI3Ni5wbmc?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述" style="zoom: 67%;" />

<p><strong>1. 原型链继承</strong></p>
<p><strong>核心：</strong></p>
<blockquote>
<p>将父类的实例作为子类的原型</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>子类的实例也是父类的实例</li>
<li>可以方便的继承父类型的原型中的方法，但是属性的继承无意义<br><strong>缺点：</strong></li>
<li>只执行一次，无法给属性传值</li>
<li>属性的继承无意义</li>
</ul>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDU5Mjc5NS02OTY0MWMzNGY1YTUwYmE4LlBORw?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述" style="zoom:67%;" />

<p><strong>2.借用构造函数继承</strong></p>
<p><strong>核心：</strong></p>
<p>在子类的内部调用父类，通过call改变父类中this的指向<br>等于是复制父类的实例属性给子类</p>
<p><strong>特点:</strong></p>
<p>创建子类实例时，可以向父类传递参数<br>可以实现多继承<br>可以方便的继承父类型的属性，但是无法继承原型中的方法<br><strong>缺点：</strong></p>
<p>实例并不是父类的实例，只是子类的实例<br>无法继承原型中的方法<br>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>
<p><strong>3.组合继承（组合原型链继承和借用构造函数继承）</strong></p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTkwNy85NDA4ODQtMjAxOTA3MTcxNjIxMzcwODQtMTIzNDYyMzEyMC5wbmc?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述" style="zoom:67%;" />

<p><strong>核心：</strong></p>
<blockquote>
<p>结合了两种模式的优点，传参和复用</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>可以继承父类原型上的属性，可以传参，可复用。</li>
<li>每个新实例引入的构造函数属性是私有的。</li>
</ul>
<p><strong>缺点：</strong> 调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</p>
<p><strong>4.原型式继承</strong></p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTkwNy85NDA4ODQtMjAxOTA3MTcxNjIxNDc1OTYtMTM2MzQ4NjU4Ni5wbmc?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述" style="zoom:67%;" />

<p><strong>核心：</strong></p>
<p>​        用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。</p>
<p><strong>特点：</strong> 类似于复制一个对象，用函数来包装。</p>
<p><strong>缺点：</strong></p>
<p>所有实例都会继承原型上的属性。<br>无法实现复用。（新实例属性都是后面添加的）</p>
<p><strong>5.寄生式继承</strong></p>
<p><strong>核心</strong><br>就是给原型式继承外面套了个壳子。</p>
<p><strong>特点：</strong> 没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。<br><strong>缺点：</strong> 没用到原型，无法复用。</p>
<p><strong>6.寄生组合式继承（常用）</strong><br><strong>核心：</strong></p>
<p>修复了组合继承的问题</p>
<p><strong>寄生</strong>:在函数内返回对象然后调用</p>
<p><strong>组合:</strong><br>1.函数的原型等于另一个实例。</p>
<p>2.在函数中用apply或者call引入另一个构造函数，可传参</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTkwNy85NDA4ODQtMjAxOTA3MTcxNjIyMjAyODUtMTQ3ODg4ODkzNi5wbmc?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述" style="zoom:67%;" />

<p><a href="#20.Js%E4%B8%AD.call()%E4%B8%8E.apply()%E5%8C%BA%E5%88%AB">call和apply继承的区别</a></p>
<hr>
<h2 id="37-数组的方法，字符串的方法，要知道每个的含义，掌握排序和去重的方法"><a href="#37-数组的方法，字符串的方法，要知道每个的含义，掌握排序和去重的方法" class="headerlink" title="37.数组的方法，字符串的方法，要知道每个的含义，掌握排序和去重的方法"></a>37.数组的方法，字符串的方法，要知道每个的含义，掌握排序和去重的方法</h2><p><a href="#10%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AF%B7%E7%AE%80%E8%BF%B0">数组的方法</a></p>
<p><strong>字符串的方法：</strong></p>
<p><strong>charAt()</strong> 返回指定位置的字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str_two.charAt(<span class="number">2</span>));  <span class="comment">//c</span></span><br></pre></td></tr></table></figure>

<p><strong>.length</strong> 返回字符串的长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str_two.length);<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p><strong>charCodeAt():</strong> 返回指定位置的字符 的Unicode编码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str_two.charCodeAt(<span class="number">3</span>));<span class="comment">//68</span></span><br></pre></td></tr></table></figure>

<p><strong>fromCharCode():</strong> 接受一个UniCode编码， 返回对应的字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">68</span>));<span class="comment">//D</span></span><br></pre></td></tr></table></figure>

<p><strong>replace():</strong> 替换</p>
<blockquote>
<p>1.想替换哪个字符串，就用哪个字符串来调用<br>2.参数1是被替换的目标， 参数2是替换的新内容<br>3.会将替换后的字符串，整体返回</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(str_two.replace(&quot;a&quot;,&quot;A&quot;));//AbcDg</span><br></pre></td></tr></table></figure>

<p><strong>substring()</strong> : 提取 介于两个下标之间的 字符串 包头不包尾 (和数组slice相似)</p>
<blockquote>
<p>参数1： 开始下标 参数2： 结束下标</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str_two.substring(<span class="number">0</span>,<span class="number">2</span>));<span class="comment">//ab</span></span><br></pre></td></tr></table></figure>

<p><strong>substr()</strong>: 可在字符串中 从开始位置截取指定长度的字符串 (和数组splice相似)</p>
<blockquote>
<p>参数1： 开始位置， 参数2 ： 指定长度</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str_two.substr(<span class="number">0</span>,<span class="number">3</span>));<span class="comment">//abc</span></span><br></pre></td></tr></table></figure>

<p><strong>split()</strong>:方法用于把一个字符串 分割成字符串数组(本质上就是个数组，只是存的都是字符串罢了)</p>
<blockquote>
<p>参数1 ：分割的依据<br>参数2：(可选参数)分割后 返回的长度<br>(超出实际大小，按照实际大小算。 小于实际大小的话，按照指定长度返回，超出的不返回)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;Where are you from?&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(s.split(<span class="string">&quot; &quot;</span>,<span class="number">2</span>));<span class="comment">//[&quot;Where&quot;, &quot;are&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>slice():</strong> 方法 可提取指定范围 的字符串</p>
<blockquote>
<p>参数1： 开始范围, 参数2： 结束范围 包头不包尾</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s.slice(<span class="number">0</span>,<span class="number">4</span>)); <span class="comment">//wher</span></span><br></pre></td></tr></table></figure>

<p><strong>indexOf()</strong>: 方法可返回指定字符 的对应下标 (首先出现的)<br>如果没有 ： 返回 -1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   用indexof（）去重：</span></span><br><span class="line">     <span class="keyword">var</span> arr_new= <span class="string">&quot;jintianbucuo&quot;</span>;    </span><br><span class="line">                <span class="keyword">var</span> arr_two=[];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr_new.length;i++) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(arr_two.indexOf(arr_new[i])==-<span class="number">1</span>)&#123;</span><br><span class="line">                           arr_two.push(arr_new[i]);</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">console</span>.log(arr_two.join(<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>lastIndexOf()</strong>: 返回指定字符 最后出现的位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s.lastIndexOf(<span class="string">&#x27; &#x27;</span>));<span class="comment">//19</span></span><br></pre></td></tr></table></figure>

<p>需要谁改变，就由谁来调用这个方法<br><strong>toLowerCase() :</strong> 把字符串转换为小写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s.toLowerCase());</span><br></pre></td></tr></table></figure>

<p><strong>toUpperCase() :</strong> 把字符串转换为大写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s.toUpperCase());</span><br></pre></td></tr></table></figure>

<p><strong>用splice（）去重：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arr</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;a.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]==a[j])&#123;</span><br><span class="line">                     a.splice(j,<span class="number">1</span>);</span><br><span class="line">                   --j;</span><br><span class="line">                   </span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">            &#125; <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> d=[<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>];</span><br><span class="line">         <span class="built_in">console</span>.log(arr(d));</span><br></pre></td></tr></table></figure>

<p><strong>数组的排序：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>];           </span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++) &#123;</span><br><span class="line">                   <span class="keyword">if</span>(arr[i]&gt;arr[j])&#123;</span><br><span class="line">                       <span class="keyword">var</span> mm=arr[i];</span><br><span class="line">                        arr[i]=arr[j];</span><br><span class="line">                        arr[j]=mm;</span><br><span class="line">                     &#125;      </span><br><span class="line">                  &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="38-箭头函数与普通函数的区别"><a href="#38-箭头函数与普通函数的区别" class="headerlink" title="38.箭头函数与普通函数的区别"></a>38.箭头函数与普通函数的区别</h2><p><strong>一.外形不同</strong>：</p>
<p>​        箭头函数使用箭头定义，普通函数中没有<br>代码实例如下：</p>
<p><strong>二.箭头函数都是匿名函数</strong><br>        普通函数可以有匿名函数，也可以有具体名函数，但是箭头函数都是匿名函数。<br>代码实例如下：</p>
<p><strong>三.箭头函数不能用于构造函数，不能使用new</strong><br>        普通函数可以用于构造函数，以此创建对象实例。<br>代码实例如下：</p>
<p><strong>四.箭头函数中this的指向不同</strong><br>        在普通函数中，this总是指向调用它的对象，如果用作构造函数，this指向创建的对象实例。<br>1.箭头函数本身不创建this<br>        也可以说箭头函数本身没有this，但是它在声明时可以捕获其所在上下文的this供自己使用。<br>注意：this一旦被捕获，就不再发生变化</p>
<hr>
<h2 id="39-什么是js内存泄露？"><a href="#39-什么是js内存泄露？" class="headerlink" title="39.什么是js内存泄露？"></a>39.什么是js内存泄露？</h2><p>​        指由于疏忽或者错误造成程序未能释放已经不再使用的内存，从而造成内存上的浪费。</p>
<p><strong>原因：</strong></p>
<p>1） 意外的全局变量引起的内存泄露</p>
<p>2）闭包引起的内存泄露</p>
<p>3）没有清理的DOM元素引用</p>
<p>4）被遗忘的定时器或者回调</p>
<p>5）子元素存在引起的内存泄露</p>
<p>6）IE7/8引用计数使用循环引用产生的问题</p>
<p><strong>怎样避免内存泄露</strong></p>
<p>1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；</p>
<p>2）注意程序逻辑，避免“死循环”之类的 ；</p>
<p>3）避免创建过多的对象 原则：不用了的东西要及时归还。</p>
<hr>
<h2 id="40-你如何对网站的文件和资源进行优化？"><a href="#40-你如何对网站的文件和资源进行优化？" class="headerlink" title="40.你如何对网站的文件和资源进行优化？"></a>40.你如何对网站的文件和资源进行优化？</h2><ol>
<li><p>文件合并（目的是减少http请求）</p>
</li>
<li><p>文件压缩，减少文件下载的体积。</p>
</li>
<li><p>使用 CDN （内容分发网络）来托管资源</p>
</li>
<li><p>使用缓存。</p>
</li>
<li><p>精简优化自己的css和js代码</p>
</li>
</ol>
<hr>
<h2 id="41-请简述ajax的执行过程-以及常见的HTTP状态码"><a href="#41-请简述ajax的执行过程-以及常见的HTTP状态码" class="headerlink" title="41.请简述ajax的执行过程 以及常见的HTTP状态码"></a>41.请简述ajax的执行过程 以及常见的HTTP状态码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//步骤一:创建异步对象</span></span><br><span class="line"><span class="keyword">var</span> xmlHTTP = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">//步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端</span></span><br><span class="line">xmlHTTP.open(method, url, isAsync)</span><br><span class="line"><span class="comment">//步骤三:发送请求</span></span><br><span class="line">xmlHTTP.send();</span><br><span class="line"><span class="comment">//步骤四:注册事件 onreadystatechange 状态改变就会调用</span></span><br><span class="line">xmlHTTP.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span> &amp;&amp; xmlHTTP.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">//步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的</span></span><br><span class="line">       <span class="built_in">console</span>.log(xmlHTTP.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>xmlHttp.readyState的五种状态</strong><br><strong>0</strong> ：请求未初始化，XMLHttpRequest对象已经创建，但还没有调用open()方法。</p>
<p><strong>1</strong> ：请求已建立，已经调用open() 方法，但尚未发送请求。</p>
<p><strong>2</strong> ： 请求已发送，正在处理中（通常现在可以从响应中获取内容头）</p>
<p><strong>3</strong> ： 请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。</p>
<p><strong>4</strong> ：响应完成，已经接收到了全部数据，并且连接已经关闭。</p>
</blockquote>
<p><strong>常见的HTTP状态码</strong><br><strong>200</strong> ： OK 客户端请求成功</p>
<p><strong>400</strong> ： Bad Request 客户端请求有语法错误，不能被服务器所理解</p>
<p><strong>401</strong> ： Unauthorized 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</p>
<p><strong>403</strong> ： Forbidden 服务器收到请求，但是拒绝提供服务</p>
<p><strong>404</strong> ： Not Found 请求资源不存在，eg：输入了错误的URL</p>
<p><strong>500</strong> ： Internal Server Error 服务器发生不可预期的错误</p>
<p><strong>503</strong> ： Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
<hr>
<h2 id="42-预加载和懒加载的区别，预加载在什么时间加载合适"><a href="#42-预加载和懒加载的区别，预加载在什么时间加载合适" class="headerlink" title="42.预加载和懒加载的区别，预加载在什么时间加载合适"></a>42.预加载和懒加载的区别，预加载在什么时间加载合适</h2><p>​        <strong>预加载</strong>是指在页面加载完成之前，提前将所需资源下载，之后使用的时候从缓存中调用；</p>
<p>​        <strong>懒加载</strong>是延迟加载，按照一定的条件或者需求等到满足条件的时候再加载对应的资源</p>
<p>​        <strong>预加载</strong>增加了服务器压力，换来的是用户体验的提升，典型例子是在一个图片较多的网页中，如果使用了预加载就可以避免网页加载出来是时，图片的位置一片空白（图片可能还没加载出来），造成不好的用户体验；</p>
<p>​        <strong>懒加载</strong>的作用减少不要的请求，缓解了服务器压力</p>
<p><strong>懒加载的原理</strong></p>
<p>​        原理很简单，先把img的src指向空或者一个小图片，图片真实的地址存储在img一个自定义的属性里,<code>&lt; img src=”” data-src=”http://real.com/real.jpg” /&gt;</code>,等到此图片出现在视野范围内了，获取img元素，把data-src里的值赋给src。这样做能防止页面一次性向服务器响应大量请求导致服务器响应慢，页面卡顿或崩溃等问题。</p>
<p><strong>优点</strong>：页面加载速度快、可以减轻服务器的压力、节约了流量,用户体验好</p>
<p><strong>预加载的原理</strong></p>
<p>​        提前加载图片，当用户需要查看时可直接从本地缓存中渲染</p>
<p><strong>意义</strong>：预加载可以说是牺牲服务器前端性能，换取更好的用户体验，这样可以使用户的操作得到最快的反映。</p>
<hr>
<h2 id="43-Jquery选择器有哪些"><a href="#43-Jquery选择器有哪些" class="headerlink" title="43.Jquery选择器有哪些"></a>43.Jquery选择器有哪些</h2><ol>
<li><p><strong>jquery基本选择器</strong></p>
<p>通过元素<u>id</u>、<u>class</u>和<u>标签名</u>来查找DOM元素。</p>
<p><code>$(&quot; &quot;)</code></p>
</li>
<li><p><strong>jquery层次选择器</strong></p>
<p>层次选择器通过DOM元素间的层次关系来获取元素</p>
<table>
<thead>
<tr>
<th><code>$(&quot;form input&quot;)</code></th>
<th>选择所有的form元素中的input元素</th>
</tr>
</thead>
<tbody><tr>
<td><code>$(&quot;#main &gt; *&quot;)</code></td>
<td>选择id值为main的所有的子元素</td>
</tr>
<tr>
<td><code>$(&quot;label + input&quot;)</code></td>
<td>选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素</td>
</tr>
<tr>
<td><code>$(&quot;#prev ~ div&quot;)</code></td>
<td>同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签</td>
</tr>
</tbody></table>
</li>
<li><p><strong>jquery过滤选择器</strong></p>
<p>分为<strong>基本过滤，内容过滤，可见性过滤，属性过滤，子元素过滤和表单对象属性过滤选择器</strong>共六种选择器</p>
<p><strong>（1）jquery基本过滤选择器</strong></p>
<p>过滤选择器是根据某类过滤规则进行元素的匹配，书写时都以(:)开头；简单过滤选择器是过滤选择器中使用最广泛的一种。</p>
<p><code>$(&quot;tr:first&quot;)</code>：选择所有tr元素的第一个</p>
<p><code>$(&quot;tr:last&quot;)</code>：选择所有tr元素的最后一个</p>
<p><code>$(&quot;input:not(:checked) + span&quot;)</code> ：过滤掉：checked的选择器的所有的input元素</p>
<p><code>$(&quot;tr:even&quot;)</code>：选择所有的tr元素的第0，2，4… …个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始）</p>
<p><code>$(&quot;tr:odd&quot;)</code>：选择所有的tr元素的第1，3，5… …个元素</p>
<p><code>$(&quot;td:eq(2)&quot;)</code>：选择所有的td元素中序号为2的那个td元素</p>
<p><code>$(&quot;td:gt(4)&quot;)</code> ：选择td元素中序号大于4的所有td元素</p>
<p><code>$(&quot;td:ll(4)&quot;)</code>：选择td元素中序号小于4的所有的td元素</p>
<p><code>$(&quot;:header&quot;)</code>：匹配如 h1, h2, h3之类的标题元素.这个是专门用来获取h1,h2这样的标题元素</p>
<p><code>$(&quot;div:animated&quot;)</code>：匹配所有正在执行动画效果的元素</p>
<p><strong>（2）jquery内容过滤选择器</strong></p>
<p>内容过滤选择器的过滤规则主要体现在它所包含的子元素和文本内容上。</p>
<p><code>$(&quot;div:contains(&#39;John&#39;)&quot;)</code> ：选择所有div中含有John文本的元素</p>
<p><code>$(&quot;td:empty&quot;)</code> ：选择所有的为空（也不包括文本节点）的td元素的数组</p>
<p><code>$(&quot;div:has(p)&quot;)</code> ：选择所有含有p标签的div元素</p>
<p><code>$(&quot;td:parent&quot;)</code>：选择所有的以td为父节点的元素数组</p>
<p><strong>（3）jquery可见性过滤选择器</strong></p>
<p>可见度过滤选择器是根据元素的可见和不可见状态来选择相应的元素。</p>
<p><code>$(&quot;div:hidden&quot;)</code>：选择所有的被hidden的div元素</p>
<p><code>$(&quot;div:visible&quot;)</code>：选择所有的可视化的div元素</p>
<p><strong>（4）jquery属性过滤选择器</strong></p>
<p>属性过滤选择器的过滤规则是通过元素的属性来获取相应的元素。</p>
<p><code>$(&quot;div[id]&quot;)</code>： 选择所有含有id属性的div元素</p>
<p><code>$(&quot;input[name=&#39;newsletter&#39;]&quot;)</code>：选择所有的name属性等于’newsletter’的input元素</p>
<p><code>$(&quot;input[name!=&#39;newsletter&#39;]&quot;)</code> ：选择所有的name属性不等于’newsletter’的input元素</p>
<p><code>$(&quot;input[name^=&#39;news&#39;]&quot;)</code>： 选择所有的name属性以’news’开头的input元素</p>
<p><code>$(&quot;input[name$=&#39;news&#39;]&quot;)</code> ：选择所有的name属性以’news’结尾的input元素</p>
<p><code>$(&quot;input[name*=&#39;man&#39;]&quot;)</code> ：选择所有的name属性包含’news’的input元素</p>
<p><strong>（5）jquery子元素过滤选择器</strong></p>
<p><code>$(&quot;ul li:nth-child(2)&quot;)</code>,<code>$(&quot;ul li:nth-child(odd)&quot;)</code>,<code>$(&quot;ul li:nth-child(3n + 1)&quot;)</code> ：匹配其父元素下的第N个子或奇偶元素.这个选择器和之前说的基础过滤(Basic Filters)中的eq() 有些类似,不同的地方就是前者是从0开始,后者是从1开始。</p>
<p><code>$(&quot;div span:first-child&quot;)</code>：返回所有的div元素的第一个子节点的数组</p>
<p><code>$(&quot;div span:last-child&quot;)</code>：返回所有的div元素的最后一个节点的数组</p>
<p><code>$(&quot;div button:only-child&quot;)</code> ：返回所有的div中只有唯一一个子节点的所有子节点的数组</p>
<p><strong>（6） jquery表单对象属性过滤选择器</strong></p>
<p>此选择器主要对所选择的表单元素进行过滤。</p>
<p><code>$(&quot;:enabled&quot;)</code>：选择所有的可操作的表单元素</p>
<p><code>$(&quot;:disabled&quot;)</code>：选择所有的不可操作的表单元素</p>
<p><code>$(&quot;:checked&quot;)</code>：选择所有的被checked的表单元素</p>
<p><code>$(&quot;select option:selected&quot;)</code>：选择所有的select 的子元素中被selected的元素</p>
<p><code>$(&quot;input[@ name =S_03_22]&quot;).parent().prev().text()</code>：选取一个 name 为”S_03_22”的input text框的上一个td的text值</p>
<p><code>$(&quot;input[@ name ^=&#39;S_&#39;]&quot;).not(&quot;[@ name $=&#39;_R&#39;]&quot;)</code>：名字以”S_ “开始，并且不是以”_R”结尾的</p>
<p><code>$(&quot;input[@ name =radio_01][@checked]&quot;).val()</code>：一个名为 radio_01的radio所选的值</p>
<p><code>$(&quot;A B&quot;)</code>：查找A元素下面的所有子节点，包括非直接子节点</p>
<p><code>$(&quot;A&gt;B&quot;)</code> ：查找A元素下面的直接子节点</p>
<p><code>$(&quot;A+B&quot;)</code> ：查找A元素后面的兄弟节点，包括非直接子节点</p>
<p><code>$(&quot;A~B&quot;)</code> ：查找A元素后面的兄弟节点，不包括非直接子节点</p>
</li>
<li><p><strong>jquery表单选择器</strong></p>
<p><code>$(&quot;:input&quot;)</code> ：选择所有的表单输入元素，包括input, textarea, select 和 button</p>
<p><code>$(&quot;:text&quot;)</code> ： 选择所有的text input元素</p>
<p><code>$(&quot;:password&quot;)</code>： 选择所有的password input元素</p>
<p><code>$(&quot;:radio&quot;)</code> ：选择所有的radio input元素</p>
<p><code>$(&quot;:checkbox&quot;)</code> ：选择所有的checkbox input元素</p>
<p><code>$(&quot;:submit&quot;)</code> ：选择所有的submit input元素</p>
<p><code>$(&quot;:image&quot;)</code> ： 选择所有的image input元素</p>
<p><code>$(&quot;:reset&quot;)</code> ：选择所有的reset input元素</p>
<p><code>$(&quot;:button&quot;)</code> ：选择所有的button input元素</p>
<p><code>$(&quot;:file&quot;)</code> ：选择所有的file input元素</p>
<p><code>$(&quot;:hidden&quot;)</code>：选择所有类型为hidden的input元素或表单的隐藏域</p>
</li>
</ol>
<hr>
<h2 id="44-Jquery插入节点的方法"><a href="#44-Jquery插入节点的方法" class="headerlink" title="44.Jquery插入节点的方法"></a>44.Jquery插入节点的方法</h2><p><code>append()</code>:向每个匹配的元素内部追加内容</p>
<p><code>prepend()</code>: 向每个匹配的元素内部前置内容</p>
<p><code>appendTo()</code>: 将所有匹配的元素追加到指定元素中，实际上，使用该方法是颠倒了常规的$(A).append(B)的操作，即不是将B追加到A中，而是将A追加到B中</p>
<p><code>prependTo()</code>: 将所有匹配的元素前置到指定的元素中。实际上，使用该方法是颠倒了常规的$(A).prepend(B)的操作，即不是将B前置到A中，而是将A前置到B中</p>
<p><code>after()</code>:在每个匹配的元素之后插入内容</p>
<p><code>insertAfter()</code>:将所有匹配的元素插入到指定元素的后面。实际上，使用该方法是颠倒了常规的$(A).after(B)的操作，即不是讲B插入到A后面，而是将A插入到B后面</p>
<p><code>before()</code>    在每个匹配的元素之前插入内容</p>
<p><code>insertBefore()</code>:将所有匹配的元素插入到指定的元素的前面。实际上，使用该方法是颠倒了常规的$(A).before(B)的操作，即不是将B插入到A前面，而是将A插入到B前面</p>
<hr>
<h2 id="45-Js的函数节流和函数防抖的区别"><a href="#45-Js的函数节流和函数防抖的区别" class="headerlink" title="45.Js的函数节流和函数防抖的区别"></a>45.Js的函数节流和函数防抖的区别</h2><p>​        <strong>函数节流</strong>是指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。</p>
<p>​        函数节流应用的<strong>实际场景</strong>，多数在监听页面元素滚动事件的时候会用到。因为滚动事件，是一个高频触发的事件。以下是监听页面元素滚动的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数节流</span></span><br><span class="line"><span class="keyword">var</span> canRun = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;throttle&quot;</span>).onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!canRun)&#123;</span><br><span class="line">        <span class="comment">// 判断是否已空闲，如果在执行中，则直接return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   canRun = <span class="literal">false</span>;</span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&quot;函数节流&quot;</span>);</span><br><span class="line">       canRun = <span class="literal">true</span>;</span><br><span class="line">   &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​        函数节流的<strong>要点</strong>是，声明一个变量当标志位，记录当前代码是否在执行。</p>
<blockquote>
<p>如果空闲，则可以正常触发方法执行。</p>
<p>如果代码正在执行，则取消这次方法执行，直接return。</p>
</blockquote>
<p>​        <strong>函数防抖</strong>是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。</p>
<p>​        函数防抖的<strong>应用场景</strong>，最常见的就是用户注册时候的手机号码验证和邮箱验证了。只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，再弹出提示语。以下还是以页面元素滚动监听的例子，来进行解析：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数防抖</span></span><br><span class="line"><span class="keyword">var</span> timer = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;debounce&quot;</span>).onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 清除未执行的代码，重置回初始化状态</span></span><br><span class="line">timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;函数防抖&quot;</span>);</span><br><span class="line">&#125;, <span class="number">300</span>);</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>​        函数防抖的<strong>要点</strong>，也是需要一个<code>setTimeout</code>来辅助实现。延迟执行需要跑的代码。</p>
<blockquote>
<p>如果方法多次触发，则把上次记录的延迟执行代码用clearTimeout清掉，重新开始。</p>
<p>如果计时完毕，没有方法进来访问触发，则执行代码。</p>
</blockquote>
<hr>
<h2 id="46-Get和post不同"><a href="#46-Get和post不同" class="headerlink" title="46.Get和post不同"></a>46.Get和post不同</h2><table>
<thead>
<tr>
<th>请求方式区别</th>
<th align="center">get</th>
<th align="center">post</th>
</tr>
</thead>
<tbody><tr>
<td>用途</td>
<td align="center">从服务器获取数据</td>
<td align="center">向服务器提交数据</td>
</tr>
<tr>
<td>参数传递</td>
<td align="center">参数拼接在URL上，xxx?id=1234&amp;name=zhagnsan</td>
<td align="center">参数封装在消息主体中一起提交到服务器</td>
</tr>
<tr>
<td>传输数据量</td>
<td align="center">传送的数据量较小，不能大于2KB（URL 的最大长度是 2048 个字符）。</td>
<td align="center">参数封装在消息主体中一起提交到服务器</td>
</tr>
<tr>
<td>安全性</td>
<td align="center">与 POST 相比，GET的安全性较差，因为所发送的数据是 URL 的一部分。(在发送密码或其他敏感信息时绝不要使用 GET )</td>
<td align="center">POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td>
</tr>
<tr>
<td>书签</td>
<td align="center">可收藏为书签</td>
<td align="center">不可收藏为书签</td>
</tr>
<tr>
<td>缓存</td>
<td align="center">能被缓存</td>
<td align="center">不能缓存</td>
</tr>
<tr>
<td>编码类型</td>
<td align="center">application/x-www-form-urlencoded</td>
<td align="center">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码</td>
</tr>
<tr>
<td>历史</td>
<td align="center">参数保留在浏览器历史中</td>
<td align="center">参数不会保存在浏览器历史中</td>
</tr>
<tr>
<td>可见性</td>
<td align="center">数据在URL中对所有人都是可见的</td>
<td align="center">数据不会显示在URL中</td>
</tr>
</tbody></table>
<hr>
<h2 id="47-什么是csrf攻击"><a href="#47-什么是csrf攻击" class="headerlink" title="47.什么是csrf攻击"></a>47.什么是csrf攻击</h2><p>​        CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫<strong>跨站请求伪造</strong>。</p>
<p>​        一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。</p>
<hr>
<h2 id="48-Js数据类型的分类"><a href="#48-Js数据类型的分类" class="headerlink" title="48.Js数据类型的分类"></a>48.Js数据类型的分类</h2><ol>
<li><p><strong>基本数据类型 （值类型）</strong></p>
<ul>
<li> 数字number</li>
<li> 字符串string</li>
<li> 布尔 boolean</li>
<li> null</li>
<li> undefined</li>
</ul>
</li>
<li><p><strong>引用数据类型</strong></p>
<ul>
<li><p>对象object</p>
</li>
<li><p>函数function</p>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="49-Js中手写一个深拷贝"><a href="#49-Js中手写一个深拷贝" class="headerlink" title="49.Js中手写一个深拷贝"></a>49.Js中手写一个深拷贝</h2><ol>
<li>数组中map方法通过制定函数对数组进行操作，并将处理结果返回，结果以新数组的形式返回，不会修改原数组</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line">	<span class="keyword">let</span> obj = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">	<span class="keyword">let</span> newobj = obj.map(<span class="function"><span class="keyword">function</span>(<span class="params">itme, index</span>) </span>&#123;</span><br><span class="line">		<span class="comment">//给obj的每一项加一</span></span><br><span class="line">		<span class="keyword">return</span> itme + <span class="number">1</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">let</span> newobjb = obj</span><br><span class="line">	<span class="built_in">console</span>.log(obj) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">	<span class="comment">//深拷贝</span></span><br><span class="line">	<span class="built_in">console</span>.log(newobj) <span class="comment">//[2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将数组先转成JSON字符串，再转成JSON对象，实现深拷贝。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> objc = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">	<span class="keyword">let</span> objv = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(objc))</span><br><span class="line">	<span class="built_in">console</span>.log(objc)</span><br><span class="line">	objv.push(<span class="number">100</span>) <span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line">	<span class="built_in">console</span>.log(objv) <span class="comment">//[1, 2, 3, 4, 100]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="50-什么时候用深拷贝-浅拷贝"><a href="#50-什么时候用深拷贝-浅拷贝" class="headerlink" title="50.什么时候用深拷贝 /浅拷贝"></a>50.什么时候用深拷贝 /浅拷贝</h2><p>​        想要不改变原值的时候用深拷贝，反之用浅拷贝</p>
<blockquote>
<p>​        无论深浅，都是需要的。当深拷贝发生时，通常表明存在着一个“聚合关系”，而浅拷贝发生时，通常表明存在着一个“相识关系”。 </p>
<p>举个简单的例子：</p>
<p>​        当你实现一个Composite  Pattern，你通常都会实现一个深拷贝(如果需要拷贝的话)，很少有要求同的Composite共享Leaf的； </p>
<p>而当你实现一个Observer  Pattern时，如果你需要拷贝Observer,你大概不会去拷贝Subject，这时就要实现个浅拷贝。 </p>
<p>是深拷贝还是浅拷贝，并不是取决于时间效率、空间效率或是语言等等，而是取决于哪一个是逻辑上正确的。  </p>
</blockquote>
<hr>
<h2 id="51-如何遍历一个多维数组"><a href="#51-如何遍历一个多维数组" class="headerlink" title="51.如何遍历一个多维数组"></a>51.如何遍历一个多维数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历多维数组</span></span><br><span class="line">	<span class="keyword">var</span> newarr = [];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">typeof</span> arr[i] !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">				<span class="comment">// console.log(arr[i])</span></span><br><span class="line">				newarr.push(arr[i])</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				demo(arr[i])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> newarr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(demo([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>],</span><br><span class="line">		[<span class="number">6</span>, <span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>, [<span class="number">10</span>, <span class="number">11</span>]]]</span><br><span class="line">	])) <span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="52-区别2种类型的容器"><a href="#52-区别2种类型的容器" class="headerlink" title="52.区别2种类型的容器"></a>52.区别2种类型的容器</h2><p><strong>1).</strong> <strong>数组容器</strong>:用来保存有序的多个数据(如列表数据), 数据的标识是下标,我们通过下标来操作对应的数据</p>
<p><strong>2).对象容器</strong>:用来保存无序的多个数据,多个数据的标识是属性名,我们通过属性名来操作属性值数据</p>
<hr>
<h2 id="53-说说开发中常用的ES6新语法"><a href="#53-说说开发中常用的ES6新语法" class="headerlink" title="53.说说开发中常用的ES6新语法"></a>53.说说开发中常用的ES6新语法</h2><p><strong>定义变量/常量</strong>: const/let</p>
<p><strong>解构赋值</strong>: <code>let &#123;a, b&#125; = this.props / import &#123;aa&#125; from &#39;xxx&#39; / function f (&#123;name&#125;) &#123;&#125;</code></p>
<p><strong>对象的简洁表达</strong>: <code>&#123;a, b, c () &#123;&#125;&#125;</code></p>
<p><strong>箭头函数</strong>: </p>
<p>   <strong>组件的自定义方法</strong>: <code>xxx = () =&gt; &#123;&#125;</code></p>
<p>   <strong>匿名函数作为实参</strong></p>
<p>   <strong>优点</strong>:</p>
<ul>
<li><p>简洁</p>
</li>
<li><p>没有自己的this,使用引用this查找的是外部this</p>
</li>
</ul>
<p><strong>扩展运算符</strong>: …<br><strong>类</strong>: class/extends/constructor/super<br><strong>ES6模块化</strong>: export/default/import<br><strong>异步</strong>: promise, async/await</p>
<hr>
<h2 id="54-说说你对事件处理机制的理解"><a href="#54-说说你对事件处理机制的理解" class="headerlink" title="54.说说你对事件处理机制的理解"></a>54.说说你对事件处理机制的理解</h2><ol>
<li><p><strong>js事件机制</strong></p>
<p>js中事件的发生包括捕获和冒泡两个阶段，两个阶段的传播顺序为</p>
<p><strong>捕获</strong>：从最外边父元素节点传递至发生事件的元素节点，即由外到内；</p>
<p><strong>冒泡</strong>：从发生事件的元素节点传递至最外边父元素节点，即由内到外；</p>
</li>
<li><p><strong>事件监听</strong></p>
</li>
</ol>
<p>对事件的监听执行一般有一下三种方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.在HTML中对事件进行绑定；</span></span><br><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span> οnclick=<span class="string">&quot;myClick()&quot;</span>&gt;点击&lt;/button&gt;</span><br><span class="line"><span class="comment">//2.在js中对DOM元素进行事件绑定；</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>).onclick = myClick;</span><br><span class="line"><span class="comment">//3.利用监听函数addEventListener(&quot;事件名&quot;,function()&#123;&#125;,false)；</span></span><br></pre></td></tr></table></figure>

<p><code>removeEventListenter(&quot;事件名&quot;,Fun,false)</code>用于解除事件的绑定监听，与addEventListener对应，用法相同</p>
<p>但是这种方法在IE8及其低版本浏览器中不能兼容，可以使用<code>attachEvent(&quot;事件名&quot;,Fun)</code>来进行绑定，因为浏览器</p>
<p>不支持捕获事件，所以没有第三个参数。detachEvent(“事件名”,Fun)与之对应为解除绑定。</p>
<p>一般的事件用法：</p>
<p><img src="images/20170711111746920.jpg" alt="img"></p>
<ol start="3">
<li><p><strong>如何阻止浏览器的默认事件的发生</strong></p>
<p>​    对于前两种的事件，如果想阻止后面的操作的话，只需要在你需要阻止的位置加上一个 return false;</p>
</li>
</ol>
<p>对第三种情况绑定的事件，阻止默认事件，需要用到<code>event.preventDefault()；</code></p>
<p><img src="images/20170711114905188.jpg" alt="img"></p>
<hr>
<h2 id="55-async-await"><a href="#55-async-await" class="headerlink" title="55.async/await?"></a>55.async/await?</h2><p><strong>1). 作用</strong></p>
<p>​    简化pormise的使用(不用再使用then()来指定成功或失败的回调函数)</p>
<p>​    以同步编码的方式实现异步流程(没有回调函数)</p>
<p><strong>2). 哪里使用await?</strong></p>
<p>​    在返回promise对象的表达式左侧, 为了直接得到异步返回的结果, 而不是promsie对象</p>
<p><strong>3). 哪里使用async?</strong></p>
<p>​    使用了await的函数定义左侧</p>
<hr>
<h2 id="56-用数组的相关方法实现以下业务需求"><a href="#56-用数组的相关方法实现以下业务需求" class="headerlink" title="56.用数组的相关方法实现以下业务需求"></a>56.用数组的相关方法实现以下业务需求</h2><blockquote>
<p>公司前后招聘了10个员工(性别,年龄, 月薪各不相同),有以下需求</p>
<p>1). 列表显示所有员工的所有信息  <code>forEach</code></p>
<p>2). 对员工进行年薪降序列表显示  <code>sort()</code></p>
<p>3). 得到男员工的总月薪: <code>reduce()</code></p>
<p>4). 查找一个月薪只比12000高一点点的员工: <code>find()</code></p>
<p>5). 查找出所有月薪高于12000的员工: <strong>filter()</strong></p>
<p>6). 列表显示所有员工的姓名/性别和年薪: <code>map()</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> employees = [</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">salary</span>: <span class="number">10000</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;B&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">salary</span>: <span class="number">12000</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;C&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">salary</span>: <span class="number">13000</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;D&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">salary</span>: <span class="number">12500</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;E&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">salary</span>: <span class="number">14000</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;F&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">salary</span>: <span class="number">16000</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;G&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span>, <span class="attr">salary</span>: <span class="number">9000</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;H&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">salary</span>: <span class="number">11000</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;I&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span>, <span class="attr">salary</span>: <span class="number">13200</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;J&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span>, <span class="attr">salary</span>: <span class="number">15000</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//1). </span></span><br><span class="line">employees.forEach(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">//2). </span></span><br><span class="line">employees.sort(<span class="function">(<span class="params">e1, e2</span>) =&gt;</span> e2.salary-e1.salary)</span><br><span class="line"><span class="comment">//3). </span></span><br><span class="line">employees.reduce(<span class="function">(<span class="params">preTotal, e</span>) =&gt;</span> preTotal + (e.sex==<span class="string">&#x27;男&#x27;</span>?e.salary:<span class="number">0</span>), <span class="number">0</span>)</span><br><span class="line"><span class="comment">//4). </span></span><br><span class="line">employees.find(<span class="function"><span class="params">e</span> =&gt;</span> e.salary&gt;<span class="number">1200</span> &amp;&amp; e.salary&lt;<span class="number">1400</span> &amp;&amp; e.sex===<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="comment">//5). </span></span><br><span class="line">employees.filter(<span class="function"><span class="params">e</span> =&gt;</span> e.salary&gt;<span class="number">1200</span>)</span><br><span class="line"><span class="comment">//6). </span></span><br><span class="line">employees.map(<span class="function"><span class="params">e</span> =&gt;</span> (&#123;<span class="string">&#x27;姓名/性别&#x27;</span>: <span class="string">`<span class="subst">$&#123;e.name&#125;</span>/<span class="subst">$&#123;e.sex&#125;</span>`</span>, <span class="string">&#x27;年薪&#x27;</span>: e.salary*<span class="number">12</span>&#125;))</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="57-说说你对cookie的理解-分类-创建-保存-使用"><a href="#57-说说你对cookie的理解-分类-创建-保存-使用" class="headerlink" title="57.说说你对cookie的理解(分类, 创建, 保存, 使用)"></a>57.说说你对cookie的理解(分类, 创建, 保存, 使用)</h2><p><strong>cookie</strong>由<code>key</code>和<code>value</code>组成的文本小数据</p>
<p><strong>分类</strong>: 会话cookie和持久化cookie</p>
<p><strong>由服务器端创建</strong>: <code>res.cookie(key, value, &#123;maxAge: 1000&#125;)</code></p>
<p><strong>由浏览器端保存</strong>: 浏览器接收到新的cookie会自动保存(内存/文件)</p>
<p><strong>使用</strong>: 浏览器发送请求时自动携带对应的cookie, 服务器端通过req读取: <code>req.cookies.key</code></p>
<hr>
<h2 id="58-内存结构图-原型结构图"><a href="#58-内存结构图-原型结构图" class="headerlink" title="58.内存结构图(原型结构图)"></a>58.内存结构图(原型结构图)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> fn1 = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure>

<img src="images/wps1.jpg" alt="img" style="zoom:50%;" />

<hr>
<h2 id="59-说说你对变量提升与函数提升的理解"><a href="#59-说说你对变量提升与函数提升的理解" class="headerlink" title="59.说说你对变量提升与函数提升的理解"></a>59.说说你对变量提升与函数提升的理解</h2><p><strong>变量提升</strong>: 在变量定义语句前就可以读取到变量, 值为undefined</p>
<p><strong>函数提升</strong>: 在函数定义语句前就可以调用函数</p>
<p><strong>原因</strong>: JS引擎在运行全局代码或执行函数前有预处理/解析</p>
<hr>
<h2 id="60-说说原型链的理解"><a href="#60-说说原型链的理解" class="headerlink" title="60.说说原型链的理解"></a>60.说说原型链的理解</h2><p><strong>作用</strong>: 原型链用于查找对象的属性</p>
<p><strong>什么</strong>: 实例对象上都会有一个隐式原型属性(<code>__proto__</code>), 它指向的就是原型对象, 而原型对象也有<code>__proto__</code>属性指向它的原型对象</p>
<p><strong>为什么<code>__proto__</code>指向的是原型对象?</strong></p>
<ul>
<li>   构造函数对象上有显式原型属性(<code>prototype</code>), 它指向的就是原型对象</li>
<li>   实例对象的<code>__proto__</code>属性被赋值为构造函数的prototype属性值</li>
</ul>
<hr>
<h2 id="61-说说你对作用域链的理解"><a href="#61-说说你对作用域链的理解" class="headerlink" title="61.说说你对作用域链的理解"></a>61.说说你对作用域链的理解</h2><ol>
<li><p><strong>作用</strong>: 作用链用来查找变量</p>
</li>
<li><p><strong>什么</strong>: 多个由内向外作用域形成的链</p>
</li>
<li><p><strong>作用域</strong>: 一块代码区域, </p>
<p>​    <strong>分类</strong>：全局作用域和函数/局部作用域, ES6有了块作用域</p>
</li>
</ol>
<hr>
<h2 id="62-说说你对闭包的理解"><a href="#62-说说你对闭包的理解" class="headerlink" title="62.说说你对闭包的理解"></a>62.说说你对闭包的理解</h2><ol>
<li><p><strong>如何产生闭包?</strong></p>
<p>​    2个函数嵌套</p>
<p>   内部函数引用了外部函数内的局部变量</p>
<p>   执行外部函数</p>
</li>
<li><p><strong>是什么?</strong></p>
<p>包含了那个局部变量的容器</p>
<p>它被内部函数对象引用着</p>
</li>
<li><p><strong>作用?</strong></p>
<p>​    延长局部变量的生命周期</p>
<p>   使函数外部可以多次间接操作到函数内部的数据</p>
</li>
<li><p><strong>应用?</strong></p>
<p>循环遍历加监听</p>
<p>IIFE定义模块</p>
<p>jQuery内部</p>
</li>
<li><p><strong>代码演示:</strong></p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         a++</span><br><span class="line">         <span class="built_in">console</span>.log(a)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fn2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> f = fn1()</span><br><span class="line">   f()</span><br><span class="line">   f()</span><br><span class="line">   f = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="63-JS事件循环机制-图"><a href="#63-JS事件循环机制-图" class="headerlink" title="63.JS事件循环机制(图)"></a>63.JS事件循环机制(图)</h2><img src="images/wps2.jpg" alt="img" style="zoom:50%;" />

<hr>
<h2 id="64-比较函数的call-apply-bind"><a href="#64-比较函数的call-apply-bind" class="headerlink" title="64.比较函数的call()/apply()/bind()"></a>64.比较函数的call()/apply()/bind()</h2><ol>
<li><p><code>call(obj, param1, param2)/apply(obj, [[param1, param2])</code></p>
<p>调用/执行函数</p>
<p>只是强制指定函数中的this为第一个参数指定的对象</p>
<p>如果函数执行需要传参数, call是依次传递, apply需要封装成数组传递</p>
</li>
<li><p><code>bind()</code></p>
<p>返回一个新函数, 不会自动执行, 需要手动执行</p>
<p>强制指定函数中的this为第一个参数指定的对象</p>
<p>新函数内部会原样调用原函数</p>
</li>
</ol>
<hr>
<h2 id="65-debug调试"><a href="#65-debug调试" class="headerlink" title="65.debug调试"></a>65.debug调试</h2><ol>
<li><p><strong>调试的目的</strong></p>
<p>​     查找bug: 不断缩小可疑代码的范围</p>
<p>​     查看程序的运行流程(用于熟悉新接手项目的代码)</p>
</li>
<li><p><strong>如何开启调试模式</strong></p>
<p>​     添加语debugger句: 程序运行前     此方式用打包后才运行的项目</p>
<p>​     添加(打)断点: 程序运行前或者过程中   此方式用运行源码js</p>
</li>
<li><p><strong>如何进行调试操作</strong></p>
<p><code>resume</code>: 恢复程序执行(可能执行完或者进入下一个断点处)</p>
<p><code>step ove</code>: 单步跳转, 尝试执行完当前语句, 进入下一条(如果内部有断点, 自动进入内部断点处)</p>
<p><code>step into</code>: 跳入, 进入当前调用函数内部</p>
<p><code>step out</code>: 跳出, 一次性执行完当前函数后面所有语句,并出去</p>
<p><code>deactivate breakpoints</code>: 使所有断点暂时失效     </p>
<p><code>call stack</code>: 显示是程序函数调用的过程<br> <code>scop</code>: 当前执行环境对应的作用域中包含的变量数据<br> <code>breakpoints</code>: 断点列表</p>
</li>
</ol>
<hr>
<h2 id="66-说说你对回调函数的理解"><a href="#66-说说你对回调函数的理解" class="headerlink" title="66.说说你对回调函数的理解"></a>66.说说你对回调函数的理解</h2><ol>
<li><p><strong>什么函数才是回调函数</strong></p>
<p>你定义的</p>
<p>你没有直接调用</p>
<p>它最终执行了</p>
</li>
<li><p><strong>回调函数相关的3个问题</strong></p>
<p>什么时候执行</p>
<p>用来做什么的</p>
<p>函数中的this是谁</p>
</li>
</ol>
<hr>
<h2 id="67-详细说明如何判断函数中的this"><a href="#67-详细说明如何判断函数中的this" class="headerlink" title="67.详细说明如何判断函数中的this"></a>67.详细说明如何判断函数中的this</h2><ol>
<li><p><strong>正常情况</strong>: 执行函数的方式决定了函数中的this</p>
<p><strong>直接调用</strong>: <code>fn()</code>       window</p>
<p><strong>new调用</strong>: <code>new fn()</code>   新创建的对象 </p>
<p><strong>对象调用</strong>: <code>obj.fn()</code>   obj对象</p>
<p><strong>call/apply调用</strong>: <code>fn.call(obj)</code>   第一个参数指定的对象</p>
</li>
<li><p><strong>特别情况</strong>:</p>
<p><strong>bind()返回的函数</strong>: <code>fn2 = fn.bind(obj)</code> fn2()第一个参数指定的对象</p>
<p><strong>箭头函数</strong>: 使用的外部的this(内部没有自己的this) <code>fn = () =&gt; &#123;&#125; fn()</code></p>
<p><strong>回调函数</strong></p>
<p>​      <strong>定时器回调/ajax回调/数组遍历相关方法回调</strong>: window</p>
<p>​      <strong>dom事件监听回调</strong>: dom元素</p>
<p>​      <strong>组件生命周期回调</strong>: 组件对象</p>
</li>
<li><p>在开发我们经常会利用<strong>箭头函数/bind()来改变this的指向</strong></p>
</li>
</ol>
<hr>
<h2 id="68-区别localStorage和sessionStorage-session与cookie"><a href="#68-区别localStorage和sessionStorage-session与cookie" class="headerlink" title="68.区别localStorage和sessionStorage, session与cookie"></a>68.区别localStorage和sessionStorage, session与cookie</h2><ol>
<li><strong>localStorage</strong>: 浏览器端持久化存储, 关闭浏览还存在, 最大5MB(基本没限制了)</li>
<li><strong>sessionStorage</strong>: 浏览器端内存存储, 关闭浏览器不存在</li>
<li><strong>session</strong>: 服务器端创建, 服务器端保存, 依赖于cookie</li>
<li><strong>cookie</strong>: 服务器端创建, 浏览器端保存, 请求携带对应cookie, 长度和数量有限制(4kb)</li>
</ol>
<hr>
<h2 id="69-关于2个引用变量指向同一个对象的2个问题"><a href="#69-关于2个引用变量指向同一个对象的2个问题" class="headerlink" title="69.关于2个引用变量指向同一个对象的2个问题"></a>69.关于2个引用变量指向同一个对象的2个问题</h2><ol>
<li>2个引用变量指向同个对象, 通过一个引用变量改变对象内部的数据, 另一个引用变量看到的新的</li>
<li>2个引用变量指向同个对象, 让一个引用变量指向一个新的对象, 另一个引用变量看到的还是原来的对象</li>
</ol>
<hr>
<h2 id="70-console-log-a-b-的查找流程"><a href="#70-console-log-a-b-的查找流程" class="headerlink" title="70.console.log(a.b)的查找流程"></a>70.console.log(a.b)的查找流程</h2><ol>
<li>先查找a, 沿着作用域链查找, 找不到报错(变量未定义)</li>
<li>找到后查找对象上的b属性, 查找原型链, 如果找不到返回undefined</li>
</ol>
<hr>
<h2 id="71-为什么要深拷贝、浅拷贝？"><a href="#71-为什么要深拷贝、浅拷贝？" class="headerlink" title="71.为什么要深拷贝、浅拷贝？"></a>71.为什么要深拷贝、浅拷贝？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">age</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a.age = <span class="number">2</span> <span class="comment">// 操作a也会影响b</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">//从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="72-手写深度克隆"><a href="#72-手写深度克隆" class="headerlink" title="72.手写深度克隆"></a>72.手写深度克隆</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度克隆：对象/数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化变量，获取目标数据的类型</span></span><br><span class="line">    <span class="keyword">let</span> result, targetClass = getTargetClass(target);</span><br><span class="line">    <span class="comment">// 2. 判断目标的类型</span></span><br><span class="line">    <span class="keyword">if</span>(targetClass === <span class="string">&#x27;Object&#x27;</span>)&#123; <span class="comment">// 对象</span></span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(targetClass === <span class="string">&#x27;Array&#x27;</span>)&#123;  <span class="comment">// 数组</span></span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 遍历目标数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> target)&#123;</span><br><span class="line">        <span class="comment">// 获取每一项值</span></span><br><span class="line">        <span class="keyword">let</span> item = target[key];</span><br><span class="line">        <span class="comment">// 4. 判断每一项数据的类型</span></span><br><span class="line">        <span class="keyword">if</span>(getTargetClass(item) === <span class="string">&#x27;Object&#x27;</span> || getTargetClass(item) === <span class="string">&#x27;Array&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">// 无论是对象还是数组，都可以result[key]取值</span></span><br><span class="line">            <span class="comment">// item = &#123;name: &#x27;kobe&#x27;&#125;  item[]</span></span><br><span class="line">            result[key] = deepClone(item);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result[key] = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个判断数据类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTargetClass</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>, -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="73-ES6中共有五种针对对象遍历的方法？"><a href="#73-ES6中共有五种针对对象遍历的方法？" class="headerlink" title="73.ES6中共有五种针对对象遍历的方法？"></a>73.ES6中共有五种针对对象遍历的方法？</h2><ol>
<li><code>for in</code><pre><code>for in 循环遍历对象自身的和继承的可枚举的属性（不含Symbol属性）
</code></pre>
</li>
<li><code>Object.keys(obj)</code><br>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）</li>
<li><code>Object.getOwnPropertyNames(obj)</code><br>返回一个数组，包含对象自身的所有属性（不含Symbol属性，但包括不可枚举属性）</li>
<li><code>Object.getOwnPropertySymbols(obj)</code><br>返回一个数组，包含对象自身所有的Symbol属性</li>
<li><code>Reflect.ownKeys(obj)</code><br>返回一个数组，包含对象自身的所有属性，不论属性名是Symbol或字符串，也不管是否可枚举。</li>
</ol>
<hr>
<h2 id="74-什么是同源策略？"><a href="#74-什么是同源策略？" class="headerlink" title="74.什么是同源策略？"></a>74.什么是同源策略？</h2><ol>
<li><strong>同源策略</strong>是由Netscape提出的一个著名的安全策略，现在所有支持JavaScript 的浏览器都会使用这个策略。</li>
<li>Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</li>
<li>所谓<strong>同源</strong>是指：协议，域名（IP），端口必须要完全相同<br>即：<strong>协议、域名（IP）、端口都相同</strong>，才能算是在同一个域里。</li>
</ol>
<hr>
<h2 id="75-非同源受到了哪些限制？"><a href="#75-非同源受到了哪些限制？" class="headerlink" title="75.非同源受到了哪些限制？"></a>75.非同源受到了哪些限制？</h2><ol>
<li>Cookie不能读取；</li>
<li>DOM无法获得；</li>
<li>Ajax请求不能发送</li>
</ol>
<hr>
<h2 id="76-JSONP解决跨域"><a href="#76-JSONP解决跨域" class="headerlink" title="76.JSONP解决跨域"></a>76.JSONP解决跨域</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.前端写法</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//1. 创建一个script标签</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//2. 设置回调函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">window</span>.getData = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="built_in">console</span>.log(data); <span class="comment">//拿到数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//3. 设置script标签src属性，填写跨域请求的地址</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			script.src = <span class="string">&#x27;http://localhost:3000/jsonp?callback=getData&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//4. 将script标签添加到body中生效</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">document</span>.body.appendChild(script);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//5.不影响整体DOM结构，删除script标签</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">document</span>.body.removeChild(script);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"><span class="comment">//2.后端写法</span></span><br><span class="line">app.get(<span class="string">&#x27;/jsonp&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//解构赋值获取请求参数</span></span><br><span class="line"><span class="keyword">const</span> &#123;callback&#125; = req.query</span><br><span class="line"><span class="comment">//去数据库查找对应数据</span></span><br><span class="line"><span class="keyword">const</span> data = [&#123;<span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&#x27;jerry&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;];</span><br><span class="line">res.send(callback + <span class="string">&#x27;(&#x27;</span> + <span class="built_in">JSON</span>.stringify(data) + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="77-Cors解决跨域？"><a href="#77-Cors解决跨域？" class="headerlink" title="77.Cors解决跨域？"></a>77.Cors解决跨域？</h2><p>以Node为例：<br><code>res.set(&#39;Access-Control-Allow-Origin&#39;, &#39;http://localhost:63342&#39;);</code></p>
<p>存在安全问题<br>以上两种凡是解决跨域， 第三种使用代理工具 反向代理工具</p>
<hr>
<h2 id="78-函数防抖"><a href="#78-函数防抖" class="headerlink" title="78.函数防抖"></a>78.函数防抖</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防抖（一段时间会等，然后带着一起做了）</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> timerId = <span class="literal">null</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">const</span> context = <span class="built_in">this</span></span><br><span class="line">         <span class="keyword">if</span>(timerId)&#123;<span class="built_in">window</span>.clearTimeout(timerId)&#125;</span><br><span class="line">         timerId = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">             fn.apply(context, <span class="built_in">arguments</span>)</span><br><span class="line">             timerId = <span class="literal">null</span></span><br><span class="line">         &#125;,delay)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="79-函数节流"><a href="#79-函数节流" class="headerlink" title="79.函数节流"></a>79.函数节流</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节流（一段时间执行一次之后，就不执行第二次）</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> canUse = <span class="literal">true</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(canUse)&#123;</span><br><span class="line">             fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">             canUse = <span class="literal">false</span></span><br><span class="line">             <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>canUse = <span class="literal">true</span>, delay)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="80-手写ajax"><a href="#80-手写ajax" class="headerlink" title="80.手写ajax"></a>80.手写ajax</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"> request.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/a/b/c?name=ff&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"> request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(request.readyState === <span class="number">4</span> &amp;&amp; request.status === <span class="number">200</span>) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(request.responseText);</span><br><span class="line">   &#125;&#125;;</span><br><span class="line"> request.send();</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试题总结</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>原生JS</tag>
      </tags>
  </entry>
</search>
