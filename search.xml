<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/article/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>this关键字详解(JavaScript)</title>
    <url>/article/ffff4ce0.html</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>this关键字是JavaScript中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数的作用域中。对于那些没有投入时间学习this机制的JavaScript开发者来说，this的绑定一直是一件非常令人困惑的事。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-7da713b01b0f0829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="二、了解this"><a href="#二、了解this" class="headerlink" title="二、了解this"></a>二、了解this</h2><p><strong>学习this的第一步是明白this既不指向函数自身也不指向函数的词法作用域</strong>，你也许被这样的解释误导过，但其实它们都是错误的。随着函数使用场合的不同，this的值会发生变化。但总有一条原则就是<strong>JS中的this代表的是当前行为执行的主体</strong>，在JS中主要研究的都是函数中的this，但并不是说只有在函数里才有this，<strong>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用</strong>。如何的区分this呢？</p>
<h2 id="三、this到底是谁"><a href="#三、this到底是谁" class="headerlink" title="三、this到底是谁"></a>三、this到底是谁</h2><p>这要分情况讨论，常见有五种情况：</p>
<h3 id="1、函数执行时首先看函数名前面是否有”-”，有的话，”-”前面是谁-this就是谁；没有的话this就是window"><a href="#1、函数执行时首先看函数名前面是否有”-”，有的话，”-”前面是谁-this就是谁；没有的话this就是window" class="headerlink" title="1、函数执行时首先看函数名前面是否有”.”，有的话，”.”前面是谁,this就是谁；没有的话this就是window"></a>1、函数执行时首先看函数名前面是否有”.”，有的话，”.”前面是谁,this就是谁；没有的话this就是window</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">fn</span>:fn&#125;;</span><br><span class="line">fn();<span class="comment">//this-&gt;window</span></span><br><span class="line">obj.fn();<span class="comment">//this-&gt;obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     fn();<span class="comment">//this-&gt;window</span></span><br><span class="line">&#125;</span><br><span class="line">sum();</span><br><span class="line"><span class="keyword">var</span> oo=&#123;</span><br><span class="line"> <span class="attr">sum</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//this-&gt;oo</span></span><br><span class="line">       fn()；<span class="comment">//this-&gt;window</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">oo.sum();</span><br></pre></td></tr></table></figure>

<h3 id="2、自执行函数中的this永远是window"><a href="#2、自执行函数中的this永远是window" class="headerlink" title="2、自执行函数中的this永远是window"></a>2、自执行函数中的this永远是window</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//this-&gt;window &#125;)();</span></span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//this-&gt;window &#125;();</span></span><br></pre></td></tr></table></figure>

<h3 id="3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素，除了IE6-8下使用attachEvent（IE一个著名的bug）"><a href="#3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素，除了IE6-8下使用attachEvent（IE一个著名的bug）" class="headerlink" title="3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素，除了IE6~8下使用attachEvent（IE一个著名的bug）"></a>3、给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素，除了IE6~8下使用attachEvent（IE一个著名的bug）</h3><ul>
<li>  DOM零级事件绑定</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//this-&gt;oDiv</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>  DOM二级事件绑定</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//this-&gt;oDiv</span></span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>  在IE6~8下使用attachEvent，默认的this就是指的window对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oDiv.attachEvent(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">//this-&gt;window</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们大多数时候，遇到事件绑定，如下面例子这种，对于IE6~8下使用attachEvent不必太较真</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>).onclick=fn;<span class="comment">//fn中的this就是#divl</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>).onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//this-&gt;#div1</span></span><br><span class="line">fn();<span class="comment">//this-&gt;window</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h3 id="4、在构造函数模式中，类中-函数体中-出现的this-xxx-xxx中的this是当前类的一个实例"><a href="#4、在构造函数模式中，类中-函数体中-出现的this-xxx-xxx中的this是当前类的一个实例" class="headerlink" title="4、在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例"></a>4、在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateJsPerson</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="comment">//浏览器默认创建的对象就是我们的实例p1-&gt;this</span></span><br><span class="line"><span class="built_in">this</span>.name=name;<span class="comment">//-&gt;p1.name=name</span></span><br><span class="line"><span class="built_in">this</span>.age=age;</span><br><span class="line"><span class="built_in">this</span>.writeJs=<span class="function"><span class="keyword">function</span>（）</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;my name is&quot;</span>+<span class="built_in">this</span>.name +<span class="string">&quot;,i can write Js&quot;</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="comment">//浏览器再把创建的实例默认的进行返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> CreateJsPerson(<span class="string">&quot;尹华芝&quot;</span>,<span class="number">48</span>);</span><br></pre></td></tr></table></figure>

<p>必须要注意一点：<strong>类中某一个属性值(方法)，方法中的this需要看方法执行的时候，前面是否有”.”,才能知道this是谁</strong>。大家不妨看下接下来的这个例子，就可明白是啥意思。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.x=<span class="number">100</span>；<span class="comment">//this-&gt;f1</span></span><br><span class="line"><span class="built_in">this</span>.getX=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.x);<span class="comment">//this-&gt;需要看getX执行的时候才知道</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1=<span class="keyword">new</span> Fn;</span><br><span class="line">f1.getX();<span class="comment">//-&gt;方法中的this是f1，所以f1.x=100</span></span><br><span class="line"><span class="keyword">var</span> ss=f1.getX;</span><br><span class="line">ss();<span class="comment">//-&gt;方法中的this是window -&gt;undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="5-call、apply和bind"><a href="#5-call、apply和bind" class="headerlink" title="5.call、apply和bind"></a>5.call、apply和bind</h3><p>我们先来看一个问题，想在下面的例子中this绑定obj,怎么实现？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>:<span class="string">&quot;浪里行舟&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//this=&gt;window</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">obj.fn();<span class="comment">//-&gt;Uncaught TypeError:obj.fn is not a function</span></span><br></pre></td></tr></table></figure>

<p>如果直接绑定obj.fn(),程序就会报错。这里我们应该用fn.call(obj)就可以实现this绑定obj,接下来我们详细介绍下call方法：</p>
<ul>
<li>  <strong>call方法的作用:</strong></li>
</ul>
<p><strong>①首先我们让原型上的call方法执行，在执行call方法的时候，我们让fn方法中的this变为第一个参数值obj；然后再把fn这个函数执行。</strong></p>
<p><strong>②call还可以传值，在严格模式下和非严格模式下，得到值不一样。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在非严格模式下</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>:<span class="string">&quot;浪里行舟 &quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(num1+num2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn.call(<span class="number">100</span>,<span class="number">200</span>);<span class="comment">//this-&gt;100 num1=200 num2=undefined</span></span><br><span class="line">fn.call(obj,<span class="number">100</span>,<span class="number">200</span>);<span class="comment">//this-&gt;obj num1=100 num2=200</span></span><br><span class="line">fn.call();<span class="comment">//this-&gt;window</span></span><br><span class="line">fn.call(<span class="literal">null</span>);<span class="comment">//this-&gt;window</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>);<span class="comment">//this-&gt;window</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//严格模式下 </span></span><br><span class="line">fn.call();<span class="comment">//在严格模式下this-&gt;undefined</span></span><br><span class="line">fn.call(<span class="literal">null</span>);<span class="comment">// 在严格模式 下this-&gt;null</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>);<span class="comment">//在严格模式下this-&gt;undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>apply和call方法的作用是一模一样的，都是用来改变方法的this关键字并且把方法<br>  执行，而且在严格模式下和非严格模式下对于第一个参数是null/undefined这种情况的规<br>  律也是一样的。</strong></li>
</ul>
<p>两者唯一的区别：call在给fn传递参数的时候，是一个个的传递值的，而apply不是一个个传，而是把要给fn传递的参数值统一的放在一个数组中进行操作。但是也相当子一个个的给fn的形参赋值。<strong>总结一句话:call第二个参数开始接受一个参数列表,apply第二个参数开始接受一个参数数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj,<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">fn.apply(obj,[<span class="number">100</span>,<span class="number">200</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>bind：这个方法在IE6～8下不兼容，和call/apply类似都是用来改变this关键字的</strong>，但是和这两者有明显区别：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//-&gt;改变this和执行fn函数是一起都完成了</span></span><br><span class="line">fn.bind(obj,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//-&gt;只是改变了fn中的this为obj，并且给fn传递了两个参数值1、2，</span></span><br><span class="line">                     但是此时并没有把fn这个函数执行</span><br><span class="line"><span class="keyword">var</span> tempFn=fn.bind(obj,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">tempFn(); <span class="comment">//这样才把fn这个函数执行</span></span><br></pre></td></tr></table></figure>

<p><strong>bind体现了预处理思想：事先把fn的this改变为我们想要的结果，并且把对应的参数值也准备好，以后要用到了，直接的执行即可。</strong></p>
<p><strong>call和apply直接执行函数，而bind需要再一次调用。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;</span><br><span class="line">      <span class="attr">name</span> : <span class="string">&quot;Cherry&quot;</span>,</span><br><span class="line">      <span class="attr">fn</span> : <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log( a + b)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b.bind(a,<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-521e048b0cfefa1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上述代码没有执行，bind返回改变了上下文的一个函数，我们必须要手动去调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">b.bind(a,<span class="number">1</span>,<span class="number">2</span>)() <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p><strong>必须要声明一点：遇到第五种情况（call apply和bind),前面四种全部让步。</strong></p>
<h2 id="四、箭头函数this指向"><a href="#四、箭头函数this指向" class="headerlink" title="四、箭头函数this指向"></a>四、箭头函数this指向</h2><p>箭头函数正如名称所示那样使用一个“箭头”(=&gt;)来定义函数的新语法，但它优于传统的函数,主要体现两点：<strong>更简短的函数并且不绑定this</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.birth; <span class="comment">// this指向window或undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，箭头函数完全修复了this的指向，<strong>箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this</strong>。</p>
<p>换句话说，<strong>箭头函数的this看外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>测试箭头函数this_1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>测试箭头函数this_2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">   </span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> obj = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">age</span>: <span class="number">39</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            btn1.onclick = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//obj</span></span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    obj.getName();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-4a9944d597a4ba4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上例中，由于箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。其实可以简化为如下代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span><br><span class="line">     <span class="keyword">let</span> obj = &#123;</span><br><span class="line">         <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">         <span class="attr">age</span>: <span class="number">39</span>,</span><br><span class="line">         <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">obj.getName();</span><br></pre></td></tr></table></figure>

<p>那假如上一层并不存在函数，this指向又是谁？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>测试箭头函数this_1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>测试箭头函数this_2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">   </span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> btn2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> obj = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">age</span>: <span class="number">39</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">getName</span>: <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            btn2.onclick = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    obj.getName();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-1ab98cd1d45cc459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上例中，虽然存在两个箭头函数，其实this取决于最外层的箭头函数,由于obj是个对象而非函数，所以this指向为Window对象</p>
<p>由于this在箭头函数中已经按照词法作用域绑定了，所以，<strong>用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params">year</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function">(<span class="params">y</span>) =&gt;</span> y - <span class="built_in">this</span>.birth; <span class="comment">// this.birth仍是1990</span></span><br><span class="line">        <span class="keyword">return</span> fn.call(&#123;<span class="attr">birth</span>:<span class="number">2000</span>&#125;, year);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(<span class="number">2018</span>); <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>this关键字</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>原型与原型链详解</title>
    <url>/article/81e0994.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>与大部分面向对象语言不同，ES6之前并没有引入类（class）的概念，JavaScript并非通过类而是直接通过构造函数来创建实例。在介绍原型和原型链之前，我们有必要先复习一下构造函数的知识。</p>
<h2 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h2><p><strong>构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例。构造函数模式中拥有了类和实例的概念，并且实例和实例之间是相互独立的，即实例识别。</strong></p>
<p>构造函数就是一个普通的函数，创建方式和普通函数没有区别，<strong>不同的是构造函数习惯上首字母大写</strong>。另外就是调用方式的不同，普通函数是直接调用，<strong>而构造函数需要使用new关键字来调用</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">	<span class="built_in">this</span>.age = age</span><br><span class="line">	<span class="built_in">this</span>.gender = gender</span><br><span class="line">	<span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">	<span class="built_in">this</span>.age = age</span><br><span class="line">	<span class="built_in">this</span>.gender = gender</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">4</span>, <span class="string">&quot;雄&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(per);<span class="comment">//当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(dog);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/15543f1ae9cfe7e95d30522f2bb5d254.png"></p>
<p>每创建一个Person构造函数，在Person构造函数中，为每一个对象都添加了一个sayName方法，也就是说构造函数每执行一次就会创建一个新的sayName方法。这样就导致了构造函数执行一次就会创建一个新的方法，执行10000次就会创建10000个新的方法，而10000个方法都是一摸一样的，为什么不把这个方法单独放到一个地方，并让所有的实例都可以访问到呢?这就需要原型(<code>prototype</code>)</p>
<h2 id="二、原型"><a href="#二、原型" class="headerlink" title="二、原型"></a>二、原型</h2><p><strong>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个<code>prototype</code>属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。</strong></p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/67e633b1b48eb146b188536fa57cbf5f.png"></p>
<p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p>
<h2 id="三、原型链"><a href="#三、原型链" class="headerlink" title="三、原型链"></a>三、原型链</h2><h3 id="1-proto-和constructor"><a href="#1-proto-和constructor" class="headerlink" title="1.__proto__和constructor"></a>1.<code>__proto__</code>和<code>constructor</code></h3><p><strong>每一个对象数据类型(普通的对象、实例、<code>prototype</code>……)也天生自带一个属性<code>__proto__</code>，属性值是当前实例所属类的原型(<code>prototype</code>)。原型对象中有一个属性<code>constructor</code>, 它指向函数对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype)<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor===Person)<span class="comment">//true</span></span><br><span class="line"><span class="comment">//顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/80a10906001b2a310b8697c821284637.png"></p>
<h3 id="2-何为原型链"><a href="#2-何为原型链" class="headerlink" title="2.何为原型链"></a>2.何为原型链</h3><p><strong>在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链</strong>。</p>
<p>举例说明:person → Person → Object ，普通人继承人类，人类继承对象类</p>
<p><strong>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。</strong></p>
<p>我们可以使用对象的<code>hasOwnProperty()</code>来检查对象自身中是否含有该属性；使用<code>in</code>检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.a = <span class="number">123</span>;</span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.a)<span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span><span class="keyword">in</span> person)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>person实例中没有a这个属性，从 person 对象中找不到 a 属性就会从 person 的原型也就是 <code>person.__proto__</code> ，也就是 Person.prototype中查找，很幸运地得到a的值为123。那假如 <code>person.__proto__</code>中也没有该属性，又该如何查找？</p>
<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层Object为止。<strong>Object是JS中所有对象数据类型的基类(最顶层的类)在Object.prototype上没有<code>__proto__</code>这个属性。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0fc9b5cc09056eb5010086ccf23f1ed2.png" alt="img"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>关于响应式布局，你必须要知道的</title>
    <url>/article/4fb4f5da.html</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>响应式 Web 设计可以让一个网站同时适配多种设备和多个屏幕，可以让网站的布局和功能随用户的使用环境（屏幕大小、输入方式、设备/浏览器能力）而变化。本文主要介绍一些响应式布局容易忽略但又很重要的知识点。</p>
<h2 id="二、视口"><a href="#二、视口" class="headerlink" title="二、视口"></a>二、视口</h2><p><strong>移动前端中常说的 viewport （视口）就是浏览器中用于呈现网页的区域。视口通常并不等于屏幕大小，特别是可以缩放浏览器窗口的情况下</strong>。手机端与 PC 端视口存在差异，电脑端的视口宽度等于分辨率，而移动端的视口宽度跟分辨率没有关系,宽度默认值是设备厂家指定的。iOS, Android 基本都将这个视口分辨率设置为 980px。</p>
<h4 id="1-为什么手机端视口要设为-980px"><a href="#1-为什么手机端视口要设为-980px" class="headerlink" title="1.为什么手机端视口要设为 980px?"></a>1.为什么手机端视口要设为 980px?</h4><p>当年乔布斯设想：苹果手机如果在市场上火爆了，但是各个网站还没有来得及制作手机端网页，那么用户不得不用手机访问电脑版的网页，<strong>如何用小屏幕访问大屏幕的页面也同样可读呢</strong>？乔帮主就想着为手机固定一个视口宽度，让手机的视口宽度等于世界上绝大多数 PC 网页的版心宽度，就是 980px。这样，用手机访问电脑版网页的时候，旁边刚好没有留白。不过页面缩放后文字会变得非常小，用户需要手动放大缩小才能看清楚，体验非常差。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-61b9f61766c2cfc0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PC端页面在手机上显示效果"></p>
<h4 id="2-约束视口"><a href="#2-约束视口" class="headerlink" title="2.约束视口"></a>2.约束视口</h4><p>为了解决前面的问题，可以在网页的中添加下面这行代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">width=device-width   视口为设备宽度（就是人设置的一个宽度）//不设置的话默认为980px</span><br><span class="line">initial-scale=1.0    初始化的视口大小是1.0倍</span><br><span class="line">maximum-scale=1.0    最大的倍数是1.0倍</span><br><span class="line">user-scalable=0      不允许缩放视口</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个视口的标签告诉浏览器怎么渲染网页。在这里，标签想表达的意思是：按照设备的宽度（device-width）来渲染网页内容。事实上，在支持这个标签的设备上给你看一看效果，你就明白了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-aa0a7fa4ea5860a2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="约束视口后"></p>
<p>不错呀！用户体验大大改善！！！<br>此时如果用 document.documentElement.clientWidth 来测试浏览器屏幕宽度，你会发现当前视口宽度等于手机屏幕的宽度，约数后的视口宽度都是在 320~480 之间（手机竖直使用的时候）。<br>这个视口的尺寸，是手机厂商设置的，能够保证我们的文字比如 16px，在自己的这个视口下清晰、大小刚刚合适。所以<strong>大屏幕的手机的约束视口 &gt; 小屏幕手机的约束视口。这就能够保证我们的网页可以用 px 写字号、写行高</strong>。<br><strong>需要注意的是：约束之后的视口宽度，不是自己的分辨率！！每个手机的分辨率，都要比自己的视口宽度大得多得多！</strong></p>
<p><strong>最最重要的一句话：前端开发工程师，丝毫不关心手机的分辨率，我们只关心视口。</strong></p>
<h2 id="三、图片"><a href="#三、图片" class="headerlink" title="三、图片"></a>三、图片</h2><p>人们常说说“一图胜千言”，确实如此。我们网页中关于松饼的文字介绍再多，也没有图片有吸引力。下面我们就在页面上方添加一张松饼的图片（2000 像素宽），效果类似引诱用户往下看的大题图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-ffe488f2924e7dcf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加图片后"></p>
<p>哇，真是好大一张图，它让整个网页看起来都失衡了，水平方向上图片溢出了。不行，必须解决这个问题。可以用 CSS 给图片指定固定宽度，<strong>但问题是我们想让它能在不同大小的屏幕中自动缩放</strong>。比如，我们例子中的 iPhone 屏幕宽度为 320 像素，如果我们把图片设置成 320 像素宽，那么 iPhone 屏幕旋转后又怎么办呢？这时候 320 像素变成了 480 像素。<br>解决方案很简单，只要一行 CSS 代码就可以让图片随容器宽度自动缩放:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line"> <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回到手机上，刷新页面，结果比较符合预期了。<br>这里声明 max-width 规则，就是要保证所有图片最大显示为其自身的 100%（即最大只可以显示为自身那么大）。<strong>此时，如果包含图片的元素（比如包含图片的 body 或 div）比图片固有宽度小，图片会缩放占满最大可用空间</strong>。</p>
<h4 id="为什么不用-width-100"><a href="#为什么不用-width-100" class="headerlink" title="为什么不用 width:100%?"></a>为什么不用 width:100%?</h4><p>要实现图片的自动缩放，也可以使用更通用的 width 属性，比如 width:100%。然而，这条规则在这里并不适用。因为这条规则会导致它显示得跟它的容器一样宽。<strong>在容器比图片宽得多的情况下，图片会被无谓地拉伸。</strong></p>
<h2 id="四、手机浏览器内核"><a href="#四、手机浏览器内核" class="headerlink" title="四、手机浏览器内核"></a>四、手机浏览器内核</h2><p>在移动端，仅有四个独立的浏览器内核，分别为微软的 Trident、火狐的 Gecko、开源内核 Webkit、Opera 的 Presto。<br>目前微软的 Trident 在移动终端上主要为 WP7、8 系统内置浏览器。Opera 的 Presto 内核主要为 Opera Mobile、OperaMini、欧朋浏览器以及欧朋 HD Beta 版。<strong>Webkit 内核的适用范围则较为广泛，Android 原生浏览器、苹果的 Safari、谷歌 Chrome(Android4.0 使用)都是基于 Webkit 开源内核开发的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">兼容的前缀：</span><br><span class="line">1	-ms-</span><br><span class="line">2	-moz-</span><br><span class="line">3	-o-</span><br><span class="line">4	-webkit-</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>中国用户的浏览器市场份额：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-65700ebe6311e394?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="近一年中国用户的浏览器市场份额"></p>
<p>UC、Android 内置、Chrome、Safari、QQ Browser 都是 webkit 内核，从图上看占了绝大部分的市场份额。<br>所以一定要伺候好-webkit-。 有的公司干脆只兼容-webkit-，别的兼容比如-ms-都不写。</p>
<h2 id="五、流式布局"><a href="#五、流式布局" class="headerlink" title="五、流式布局"></a>五、流式布局</h2><p><strong>百分比布局也叫作流式布局、弹性盒布局。手机网页没有版心，都左右撑满。</strong></p>
<p><strong>百分比能够设置的属性是 width、height、padding、margin。其他属性比如 border、font-size 不能用百分比设置的。</strong></p>
<ul>
<li>  如果用百分比写 width，那么指的是父元素 width 的百分之多少。</li>
<li>  如果用百分比写 height，那么指的是父元素 height 的百分之多少。</li>
<li>  如果用百分比写 padding，那么指的是父元素 width 的百分之多少，无论是水平的 padding 还是竖直的 padding。</li>
<li>  如果用百分比写 margin，那么指的是父元素 width 的百分之多少，无论是水平的 margin 还是竖直的 margin。</li>
<li>  不能用百分比写 border 的宽度</li>
</ul>
<p>接下来我们看一个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">padding</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">padding</span>:<span class="number">10%</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">/*此时p的真实宽度是多少？*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-6cd6772e448675b0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p的盒模型图"></p>
<p>此时 p 的真实宽度是 140px*190px</p>
<h2 id="六、媒体查询"><a href="#六、媒体查询" class="headerlink" title="六、媒体查询"></a>六、媒体查询</h2><h4 id="1-为什么响应式-Web-设计需要媒体查询"><a href="#1-为什么响应式-Web-设计需要媒体查询" class="headerlink" title="1.为什么响应式 Web 设计需要媒体查询"></a>1.为什么响应式 Web 设计需要媒体查询</h4><p><strong>CSS3 媒体查询可以让我们针对特定的设备能力或条件为网页应用特定的 CSS 样式</strong>。如果没有媒体查询，光用 CSS 是无法大大修改网页外观的。这个模块让我们可以提前编写出适应很多不可预测因素的 CSS 规则，比如屏幕方向水平或垂直、视口或大或小等等。弹性布局虽然可以让设计适应较多场景，也包括某些尺寸的屏幕，但有时候确实不够用，因为我们还需要对布局进行更细致的调整。媒体查询让这一切成为可能，它就相当于 CSS 中基本的条件逻辑。</p>
<h4 id="2-媒体查询语法"><a href="#2-媒体查询语法" class="headerlink" title="2.媒体查询语法"></a>2.媒体查询语法</h4><p><strong>我们在媒体查询外面写的第一条规则，是“基本的”样式，它适用于任何设备。在此基础上，我们再为不同视口、不同能力的设备，渐进增加不同的视觉效果和功能。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: grey;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">1200px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">        <span class="attribute">background-color</span>: pink;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">700px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">1200px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">background-color</span>: blue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">700px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">background-color</span>: orange;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 @media 就表示媒体查询，查询现在看这个网页的设备是什么，以及它的宽度是多少。screen 表示看这个网页的设备是显示器，而不是残疾人听力设备、也不是打印机。后面用 and 符号罗列所有的可能性。<br>值得注意：<strong>媒体查询只能包裹选择器，不能包裹 k:v 对儿。</strong></p>
<p><strong>IE6、7、8 不支持媒体查询，也为了防止手机端的某些浏览器不支持媒体查询，所以不要把所有的选择器都放在媒体查询里面。</strong></p>
<h2 id="七、rem-响应式布局"><a href="#七、rem-响应式布局" class="headerlink" title="七、rem 响应式布局"></a>七、rem 响应式布局</h2><blockquote>
<p>rem 响应式布局思想</p>
</blockquote>
<ol>
<li> 一般不要给元素设置具体的宽度,但是对于一些小图标可以设定具体宽度值</li>
<li> 高度值可以设置固定值,设计稿有多大,我们就严格写多大</li>
<li> 所有设置的固定值都用 REM 做单位(首先在 HTML 中设置一个基准值：PX 和 REM 的对应比例,然后在效果图上获取 PX 值,布局的时候转化为 REM 值)</li>
<li> JS 获取真实屏幕的宽度,让其除以设计稿的宽度,算出比例,把之前的基准值按照比例进行重新的设定,这样项目就可以在移动端自适应了</li>
</ol>
<blockquote>
<p>什么是 rem,它与 em 有何区别</p>
</blockquote>
<p><strong>rem:当前页面中元素的 REM 单位的样式值都是针对于 HTML 元素的 font-size 的值进行动态计算的</strong></p>
<p><strong>em:表示父元素的字号的倍数。(特例：在 text-indent 属性中，表示文字宽度)</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> body             →font-size:20px;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>   → font-size:2em;</span><br><span class="line">box1</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>  → font-size:2em;</span><br><span class="line">	box2</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span>  → font-size:2em;</span><br><span class="line">    	box3</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/24295319-89af7dfeb2b2c401?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="得到结果"></p>
<p>em 为单位的时候，font-size 属性是计算后继承，box1 计算出来是 40px。那么里面的 box2继承的是 40px。<strong>em 单位不仅仅可以用来设置字号，还可以设置任何盒模型的属性，比如 width、height、padding、margin、border</strong></p>
<p><strong>rem 有一点优势就是可以和媒体查询配合，实现响应式布局：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">320px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">14px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">360px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">16px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">400px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">18px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运用场景</p>
</blockquote>
<p>如果我们做的 H5 页面只在移动端访问，这是因为 REM 不兼容低版本的浏览器。而如果移动端和 PC 端公用一套代码，建议使用流式布局。</p>
<blockquote>
<p>如何做个 REM 响应式布局</p>
</blockquote>
<p><strong>1、从 UI 设计师拿到 PSD 设计稿,然后在样式中给 HTML 设定一个 font-size 的值，我们一般都设置一个方便后面计算的值，例如：100px</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">  font-size:100px;//1rem=100px</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2、写页面，写样式</strong><br>首先按照设计稿的尺寸来写样式，然后在写样式值的时候，需要把得到的像素值除以 100 计算出对应的 REM 的值。<br>值得注意的是：真实项目中外层盒子的宽度我们一般还是不写固定值，沿用流式布局法的思想，我们用百分比的方式布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin</span>:<span class="number">0</span>  <span class="number">0.2rem</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">3rem</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3、根据当前屏幕的宽度和设计稿的宽度来计算我们 HTML 的 font-size 的值</strong><br>例如：设计稿宽度为 640px,其中有一个部分是轮播图，它的尺寸是 600*300，在样式中给 HTML 设定一个 font-size 的值为 100px,则轮播图大小应该为 6rem×3rem，那如果手机屏幕宽度为 375px,其 font-size 应该设置为多少。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">375/640*100-&gt;fontsize=58.59375//此时轮播图能自适应手机屏幕大小</span><br></pre></td></tr></table></figure>

<p><strong>根据当前屏幕宽度和设计稿宽度的比例，动态计算一下当前宽度下的 fontsize 值应该是多少，如果 fontsize 的值改变了，之前设定的所有 REM 单位的值自动会跟着放大或者缩小</strong>。可以通过以下这段代码实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> desW=<span class="number">640</span>,</span></span><br><span class="line"><span class="javascript">winW=<span class="built_in">document</span>.documentElement.clientwidth,</span></span><br><span class="line"><span class="javascript">ratio=winW/desW;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.documentElement.style.fontSize=ratio*<span class="number">100</span>+<span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="javascript">&#125;();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但如果当前屏幕宽度大于设计稿宽度，图片会被拉长而失真，所以以上代码需要稍微做些修改：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//html部分</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">//js部分</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">~function()&#123;</span><br><span class="line">var desW=640,</span><br><span class="line">winW=document.documentElement.clientwidth,</span><br><span class="line">ratio=winW/desW;</span><br><span class="line">var oMain=document.getElementById(main&quot;)；</span><br><span class="line">if(winW&gt;desW)&#123;</span><br><span class="line">oMain.style.width=desW+&quot;px&quot;;</span><br><span class="line">oMain.style.margin=&quot;0 auto&quot;;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">document.documentElement.style.fontSize=ratio*100+&quot;px&quot;;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>响应式</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器存储</title>
    <url>/article/4df0e90e.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着移动网络的发展与演化，我们手机上现在除了有原生 App，还能跑“WebApp”——它即开即用，用完即走。一个优秀的 WebApp 甚至可以拥有和原生 App 媲美的功能和体验。WebApp 优异的性能表现，有一部分原因要归功于浏览器存储技术的提升。cookie存储数据的功能已经很难满足开发所需，逐渐被WebStorage、IndexedDB所取代，本文将介绍这几种存储方式的差异和优缺点。</p>
<h2 id="一、Cookie"><a href="#一、Cookie" class="headerlink" title="一、Cookie"></a>一、Cookie</h2><h3 id="1-Cookie的来源"><a href="#1-Cookie的来源" class="headerlink" title="1.Cookie的来源"></a>1.Cookie的来源</h3><p><strong>Cookie 的本职工作并非本地存储，而是“维持状态”</strong>。<br>因为<strong>HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存</strong>，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了Cookie。它就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。</p>
<p>我们可以把Cookie 理解为一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。</p>
<p>在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p>
<h3 id="2-什么是Cookie及应用场景"><a href="#2-什么是Cookie及应用场景" class="headerlink" title="2.什么是Cookie及应用场景"></a>2.什么是Cookie及应用场景</h3><p><strong>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储</strong>。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的set-cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/88a1801d209eabf4b1db25fed4ab204c.png"></p>
<p>如上图所示，<strong>Cookie 以键值对的形式存在</strong>。</p>
<p>典型的应用场景有：</p>
<ul>
<li><p>  记住密码，下次自动登录。</p>
</li>
<li><p>  购物车功能。</p>
</li>
<li><p>  记录用户浏览数据，进行商品（广告）推荐。</p>
</li>
</ul>
<h3 id="3-Cookie的原理及生成方式"><a href="#3-Cookie的原理及生成方式" class="headerlink" title="3.Cookie的原理及生成方式"></a>3.Cookie的原理及生成方式</h3><p>Cookie的原理<br><img src="https://img-blog.csdnimg.cn/img_convert/c897430d72b08689ed182f9f18f89654.png"></p>
<p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie信息发送给服务器，服务端会辨别用户身份，另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p>
<p>Cookie的生成方式主要有两种：</p>
<ul>
<li>  生成方式一：http response header中的set-cookie</li>
</ul>
<p>我们可以通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2018</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT;<span class="comment">//可以指定一个特定的过期时间（Expires）或有效期（Max-Age）</span></span><br></pre></td></tr></table></figure>

<p>当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</p>
<ul>
<li>  生成方式二：js中可以通过document.cookie可以读写cookie，以键值对的形式展示</li>
</ul>
<p>例如我们在掘金社区控制台输入以下三句代码，便可以在Chrome 的 Application 面板查看生成的cookie:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie=&quot;userName=hello&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie=&quot;gender=male&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie=&#x27;age=20;domain=.baidu.com&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/367a3e55cd823fa8c6490a8bbe3d47f8.png"></p>
<p>从上图中我们可以得出：</p>
<p><strong>Domain 标识指定了哪些域名可以接受Cookie</strong>。如果没有设置domain，就会自动绑定到执行语句的当前域。<br>如果设置为”.baidu.com”,则所有以”baidu.com”结尾的域名都可以访问该Cookie，所以在掘金社区上读取不到第三条代码存储Cookie值。</p>
<h3 id="4-Cookie的缺陷"><a href="#4-Cookie的缺陷" class="headerlink" title="4.Cookie的缺陷"></a>4.Cookie的缺陷</h3><ul>
<li>  Cookie 不够大</li>
</ul>
<p>Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。此外很多浏览器对一个站点的cookie个数也是有限制的。</p>
<p>这里需注意：各浏览器的cookie每一个<code>name=value</code>的value值大概在4k，所以4k并不是一个域名下所有的cookie共享的,而是一个name的大小。</p>
<ul>
<li>  过多的 Cookie 会带来巨大的性能浪费</li>
</ul>
<p>Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。</p>
<p>cookie是用来维护用户信息的，而域名(domain)下所有请求都会携带cookie，但对于静态文件的请求，携带cookie信息根本没有用，此时可以通过cdn（存储静态文件的）的域名和主站的域名分开来解决。</p>
<ul>
<li>  由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。</li>
</ul>
<h3 id="5-Cookie与安全"><a href="#5-Cookie与安全" class="headerlink" title="5.Cookie与安全"></a>5.Cookie与安全</h3><p>对于 cookie 来说，我们还需要注意安全性。<br><img src="https://img-blog.csdnimg.cn/img_convert/c2b2ddaa96d796e5305a99a1d826ef0a.png"></p>
<p>HttpOnly 不支持读写，浏览器不允许脚本操作document.cookie去更改cookie，<br>所以为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>

<p>标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p>
<p>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。</p>
<p><strong>HTML5中新增了本地存储的解决方案—-Web Storage，它分成两类：sessionStorage和localStorage</strong>。这样有了WebStorage后，cookie能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。</p>
<h2 id="二、LocalStorage"><a href="#二、LocalStorage" class="headerlink" title="二、LocalStorage"></a>二、LocalStorage</h2><h3 id="1-LocalStorage的特点"><a href="#1-LocalStorage的特点" class="headerlink" title="1.LocalStorage的特点"></a>1.LocalStorage的特点</h3><ul>
<li>  保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。</li>
<li>  大小为5M左右</li>
<li>  仅在客户端使用，不和服务端进行通信</li>
<li>  接口封装较好</li>
</ul>
<p>基于上面的特点，LocalStorage可以作为浏览器本地缓存方案，用来提升网页首屏渲染速度(根据第一请求返回时，将一些不变信息直接存储在本地)。</p>
<h3 id="2-存入-读取数据"><a href="#2-存入-读取数据" class="headerlink" title="2.存入/读取数据"></a>2.存入/读取数据</h3><p>localStorage保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。<br>存入数据使用setItem方法。它接受两个参数，第一个是键名，第二个是保存的数据。<br><code>localStorage.setItem(&quot;key&quot;,&quot;value&quot;);</code><br>读取数据使用getItem方法。它只有一个参数，就是键名。<br><code>var valueLocal = localStorage.getItem(&quot;key&quot;);</code></p>
<p>具体步骤，请看下面的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">if(window.localStorage)&#123;</span><br><span class="line">  localStorage.setItem（&#x27;name&#x27;,&#x27;world&#x27;）</span><br><span class="line">  localStorage.setItem（“gender&#x27;,&#x27;female&#x27;）</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> name=<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;name&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> gender=<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;gender&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;name&#x27;</span>).innerHTML=name</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;gender&#x27;</span>).innerHTML=gender</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3.使用场景"></a>3.使用场景</h3><p>LocalStorage在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 LocalStorage 来做。</p>
<p>这里给大家举个例子，考虑到 LocalStorage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：<br><img src="https://img-blog.csdnimg.cn/img_convert/d08269c01185f35b26be3750c8be86f2.png"></p>
<h2 id="三、sessionStorage"><a href="#三、sessionStorage" class="headerlink" title="三、sessionStorage"></a>三、sessionStorage</h2><p>sessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，<strong>即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享</strong>；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage的属性和方法与LocalStorage完全一样。</p>
<h3 id="1-sessionStorage的特点"><a href="#1-sessionStorage的特点" class="headerlink" title="1.sessionStorage的特点"></a>1.sessionStorage的特点</h3><ul>
<li>  会话级别的浏览器存储</li>
<li>  大小为5M左右</li>
<li>  仅在客户端使用，不和服务端进行通信</li>
<li>  接口封装较好</li>
</ul>
<p>基于上面的特点，sessionStorage 可以有效对表单信息进行维护，比如刷新时，表单信息不丢失。</p>
<h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h3><p>sessionStorage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 sessionStorage就主要是存储你本次会话的浏览足迹：<br><img src="https://img-blog.csdnimg.cn/img_convert/766e8aa98048064132011e2f3683bcd1.png"></p>
<p>lasturl 对应的就是你上一次访问的 URL 地址，这个地址是即时的。当你切换 URL 时，它随之更新，当你关闭页面时，留着它也确实没有什么意义了，干脆释放吧。这样的数据用 sessionStorage 来处理再合适不过。</p>
<h3 id="3-sessionStorage-、localStorage-和-cookie-之间的区别"><a href="#3-sessionStorage-、localStorage-和-cookie-之间的区别" class="headerlink" title="3.sessionStorage 、localStorage 和 cookie 之间的区别"></a>3.sessionStorage 、localStorage 和 cookie 之间的区别</h3><ul>
<li>  共同点：都是保存在浏览器端，且都遵循同源策略。</li>
<li>  不同点：在于生命周期与作用域的不同</li>
</ul>
<p>作用域：localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下<br><img src="https://img-blog.csdnimg.cn/img_convert/30482461b261171ee843eb9f98c6b30d.png"></p>
<p>生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</p>
<p>Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——<strong>它只能存储字符串</strong>，要想得到对象，我们还需要先对字符串进行一轮解析。</p>
<p>说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！</p>
<h2 id="四、IndexedDB"><a href="#四、IndexedDB" class="headerlink" title="四、IndexedDB"></a>四、IndexedDB</h2><p>IndexedDB 是一种低级API，**用于客户端存储大量结构化数据(包括文件和blobs)**。该API使用索引来实现对该数据的高性能搜索。IndexedDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。</p>
<h3 id="1-IndexedDB的特点"><a href="#1-IndexedDB的特点" class="headerlink" title="1.IndexedDB的特点"></a>1.IndexedDB的特点</h3><ul>
<li>  键值对储存。</li>
</ul>
<p>IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
<ul>
<li>  异步</li>
</ul>
<p>IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
<ul>
<li>  支持事务。</li>
</ul>
<p>IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
<ul>
<li>  同源限制</li>
</ul>
<p>IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
<ul>
<li>  储存空间大</li>
</ul>
<p>IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>
<ul>
<li>  支持二进制储存。</li>
</ul>
<p>IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>
<h3 id="2-IndexedDB的常见操作"><a href="#2-IndexedDB的常见操作" class="headerlink" title="2.IndexedDB的常见操作"></a>2.IndexedDB的常见操作</h3><p>在IndexedDB大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求——响应的模式。</p>
<ul>
<li>  建立打开IndexedDB —-<code>window.indexedDB.open(&quot;testDB&quot;)</code></li>
</ul>
<p>这条指令并不会返回一个DB对象的句柄，我们得到的是一个<code>IDBOpenDBRequest</code>对象，而我们希望得到的DB对象在其result属性中<br><img src="https://img-blog.csdnimg.cn/img_convert/a442775ca09c62b34a95977420a6a14d.png"></p>
<p>除了result，IDBOpenDBRequest接口定义了几个重要属性:</p>
<p>onerror: 请求失败的回调函数句柄</p>
<p>onsuccess:请求成功的回调函数句柄</p>
<p>onupgradeneeded:请求数据库版本变化句柄</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">openDB</span>(<span class="params">name</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> request=<span class="built_in">window</span>.indexedDB.open(name)<span class="comment">//建立打开IndexedDB</span></span></span><br><span class="line"><span class="javascript">request.onerror=<span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">&#x27;open indexdb error&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">request.onsuccess=<span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">myDB.db=e.target.result<span class="comment">//这是一个 IDBDatabase对象，这就是IndexedDB对象</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(myDB.db)<span class="comment">//此处就可以获取到db实例</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myDB=&#123;</span></span><br><span class="line"><span class="javascript"><span class="attr">name</span>:<span class="string">&#x27;testDB&#x27;</span>,</span></span><br><span class="line"><span class="javascript"><span class="attr">version</span>:<span class="string">&#x27;1&#x27;</span>,</span></span><br><span class="line"><span class="javascript"><span class="attr">db</span>:<span class="literal">null</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">openDB(myDB.name)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台得到一个 IDBDatabase对象，这就是IndexedDB对象<br><img src="https://img-blog.csdnimg.cn/img_convert/07eb89f08b4feb1b018735dc77e3f75a.png"></p>
<ul>
<li>  关闭IndexedDB—-<code>indexdb.close()</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function closeDB(db)&#123;</span><br><span class="line">    db.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  删除IndexedDB—-<code>window.indexedDB.deleteDatabase(indexdb)</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteDB</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  indexedDB.deleteDatabase(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-WebStorage、cookie-和-IndexedDB之间的区别"><a href="#3-WebStorage、cookie-和-IndexedDB之间的区别" class="headerlink" title="3.WebStorage、cookie 和 IndexedDB之间的区别"></a>3.WebStorage、cookie 和 IndexedDB之间的区别</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/3af7807f9d0222b50d94a1afa72070b9.png"></p>
<p>从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正是浏览器存储、缓存技术的出现和发展，为我们的前端应用带来了无限的转机。近年来基于存储、缓存技术的第三方库层出不绝，此外还衍生出了 PWA 这样优秀的 Web 应用模型。总结下本文几个核心观点：</p>
<ul>
<li>  Cookie 的本职工作并非本地存储，而是“维持状态”</li>
<li>  Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制，不与服务端发生通信</li>
<li>  IndexedDB 用于客户端存储大量结构化数据</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>浏览器存储</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-原生JS</title>
    <url>/article/f3e36dc4.html</url>
    <content><![CDATA[<h2 id="1-Js基本数据类型有哪些"><a href="#1-Js基本数据类型有哪些" class="headerlink" title="1.Js基本数据类型有哪些"></a>1.Js基本数据类型有哪些</h2><p>7种,<code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Null</code>、<code>undefined</code>、<code>object</code>、<code>symbol</code>。</p>
<blockquote>
<p>在ES5的时候，我们认知的数据类型是前6种。</p>
<p>ES6 中新增了一种 <code>Symbol</code> 。</p>
<p>这种类型的对象永不相等，即始创建的时候传入相同的值，可以解决属性名冲突的问题，做为标记。</p>
</blockquote>
<hr>
<h2 id="2-Ajax如何使用"><a href="#2-Ajax如何使用" class="headerlink" title="2.Ajax如何使用"></a>2.Ajax如何使用</h2><blockquote>
<p><strong>全称：</strong><code>Asynchronous Javascript And XML</code>(异步传输+js+xml)。</p>
<p>所谓<strong>异步</strong>，在这里简单地解释就是：</p>
<p>向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是<strong>不会</strong>发生整页刷新的，提高了用户体验</p>
</blockquote>
<ol>
<li>创建<code>XMLHttpRequest</code>对象,也就是创建一个异步调用对象.</li>
<li>创建一个新的<code>HTTP</code>请求,并指定该HTTP请求的方法、URL及验证信息.</li>
<li>设置响应<code>HTTP</code>请求状态变化的函数.</li>
<li>发送<code>HTTP</code>请求.</li>
<li>获取异步调用返回的数据.</li>
<li>使用<code>JavaScript</code>和<code>DOM</code>实现局部刷新.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp = <span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">xmlHttp.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;demo.php&#x27;</span>,<span class="string">&#x27;true&#x27;</span>); </span><br><span class="line">xmlHttp.send() </span><br><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">   <span class="keyword">if</span>(xmlHttp.readyState === <span class="number">4</span> &amp; xmlHttp.status === <span class="number">200</span>)&#123; </span><br><span class="line">       <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-如何判断一个数据是NaN"><a href="#3-如何判断一个数据是NaN" class="headerlink" title="3.如何判断一个数据是NaN"></a>3.如何判断一个数据是NaN</h2><p><strong>注意</strong>:NaN首先是一个<code>number</code>类型，然后同时又有着<code>not a number</code>的意义，而不仅仅只是表达着<code>不是&quot;number类型&quot;</code></p>
<p>关于NaN的一些操作：</p>
<ol>
<li><strong>isNaN(n)</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a  = <span class="literal">NaN</span> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(a))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>Object.is(n)</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a  = <span class="literal">NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(a,<span class="literal">NaN</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>封装成方法：NaN连自己本身都不相等，所以可以利用这个特性来判断这个值是不是NaN</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isNaNMethod = <span class="function"><span class="params">v</span>=&gt;</span>v!==v &amp;&amp; <span class="literal">true</span> </span><br><span class="line">   <span class="built_in">console</span>.log(isNaNMethod(<span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">console</span>.log(isNaNMethod(<span class="string">&#x27;sdsd&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line">   <span class="built_in">console</span>.log(isNaNMethod(<span class="number">3</span>)); <span class="comment">// false</span></span><br><span class="line">   <span class="built_in">console</span>.log(isNaNMethod(<span class="string">&#x27;3.233&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line">   <span class="keyword">let</span> bq = &#123;<span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>&#125;</span><br><span class="line">   <span class="built_in">console</span>.log(isNaNMethod(bq)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>判断数组中是否含有NaN</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">NaN</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="literal">NaN</span>))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：不能用indexOf判断数组中是否含有NaN</strong></p>
<hr>
<h2 id="4-Js中null与undefined区别"><a href="#4-Js中null与undefined区别" class="headerlink" title="4.Js中null与undefined区别"></a>4.Js中null与undefined区别</h2><p><strong>Null</strong> 只有一个值，是 null，代表一个<code>空对象指针</code>。</p>
<p><strong>Undefined</strong> 只有一个值，是undefined。</p>
<p>当一个声明了一个变量未初始化时，得到的就是undefined。undefined 是从 null 中派生出来的。</p>
<p><strong>简单理解</strong>就是：undefined 是没有定义的，null 是定义了但是为空。</p>
<hr>
<h2 id="5-闭包是什么-有什么特性-对页面会有什么影响"><a href="#5-闭包是什么-有什么特性-对页面会有什么影响" class="headerlink" title="5.闭包是什么?有什么特性?对页面会有什么影响?"></a>5.闭包是什么?有什么特性?对页面会有什么影响?</h2><p>​        闭包可以简单理解成”定义在一个函数内部的函数”。<strong>当其中一个内部函数在包含它们的外部函数之外被调用时</strong>，就会形成闭包。</p>
<p><strong>特点：</strong></p>
<ol>
<li>函数嵌套函数。</li>
<li>函数内部可以引用外部的参数和变量。</li>
<li>参数和变量不会被垃圾回收机制回收。</li>
</ol>
<p><strong>用处</strong></p>
<p> 常驻内存会增大内存的使用量使用不：</p>
<ol>
<li>读取函数内部的变量；</li>
<li>这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除。</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>变量长期驻扎在内存中；</li>
<li>避免全局变量的污染；</li>
<li>私有成员的存在 ；</li>
</ol>
<p><strong>缺点：</strong></p>
<p>会造成内存泄露</p>
<h2 id="6-事件委托是什么？如何确定事件源"><a href="#6-事件委托是什么？如何确定事件源" class="headerlink" title="6.事件委托是什么？如何确定事件源"></a>6.事件委托是什么？如何确定事件源</h2><p>事件委托还有一个名字叫事件代理，JS高程上讲：</p>
<p>​        <strong>事件委托</strong>就是利用事件冒泡，只制定一个事件处理程序，就可以管理某一类型的所有事件。</p>
<p>​        <strong>在事件中,当前操作的那个元素就是事件源</strong>。比如网页元素中a标签和input都有onclick事件，当点击a发生onclick事件时，事件源就是a标签，当点击input发送onclic事件是，事件源就是input。</p>
<p><strong>如何获取事件源那？？</strong></p>
<blockquote>
<p>IE下：window.event.srcElement </p>
<p>标准下：event.target</p>
</blockquote>
<p>由此可见，我们是通过事件对象获取到的事件源。</p>
<hr>
<h2 id="7-本地存储与cookie的区别"><a href="#7-本地存储与cookie的区别" class="headerlink" title="7.本地存储与cookie的区别"></a>7.本地存储与cookie的区别</h2><p><strong>1.Cookie</strong> </p>
<p>​        是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为<u>4KB</u>左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p>
<p><strong>2.localStorage</strong></p>
<p>​        是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你方案是种不错的选择。</p>
<p><strong>3.sessionStorage</strong></p>
<p>​        与localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但<strong>当页面关闭后，sessionStorage 中的数据就会被清空</strong>。</p>
<p><strong>三者的异同</strong></p>
<table>
<thead>
<tr>
<th><em><strong>特性</strong></em></th>
<th><strong>Cookie</strong></th>
<th><strong>localStorage</strong></th>
<th><strong>sessionStorage</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据的生命期</td>
<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>
<td>除非被清除，否则永久保存</td>
<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>
</tr>
<tr>
<td>存放数据大小</td>
<td>4K左右</td>
<td>一般为5MB</td>
<td></td>
</tr>
<tr>
<td>与服务器端通信</td>
<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>
<td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
<td></td>
</tr>
<tr>
<td>易用性</td>
<td>需要程序员自己封装，源生的Cookie接口不友好</td>
<td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
<td></td>
</tr>
</tbody></table>
<p>**相同点:**都保存在浏览器端，同源的</p>
<p><strong>不同点：</strong></p>
<p><strong>①传递方式不同</strong></p>
<blockquote>
<ul>
<li><p>​        cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。</p>
</li>
<li><p>​        sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
</li>
</ul>
</blockquote>
<p><strong>②数据大小不同</strong></p>
<blockquote>
<ul>
<li><p>​        cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。</p>
</li>
<li><p>​        存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。</p>
</li>
<li><p>​        sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
</li>
</ul>
</blockquote>
<p><strong>③数据有效期不同</strong></p>
<blockquote>
<ul>
<li><p>​        sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</p>
</li>
<li><p>​        localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</p>
</li>
<li><p>​        cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</p>
</li>
</ul>
</blockquote>
<p><strong>④作用域不同</strong></p>
<blockquote>
<ul>
<li><p>​        sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</p>
</li>
<li><p>​        localStorage在所有同源窗口中都是共享的；</p>
</li>
<li><p>​        cookie也是在所有同源窗口中都是共享的。</p>
</li>
<li><p>​        Web Storage支持事件通知机制，可以将数据更新的通知发送给监听者。</p>
</li>
<li><p>​        Web Storage的api接口使用更方便。</p>
</li>
</ul>
</blockquote>
<hr>
<h2 id="8-ES6新特性"><a href="#8-ES6新特性" class="headerlink" title="8.ES6新特性"></a>8.ES6新特性</h2><ul>
<li><p><em><strong>const和let</strong></em></p>
</li>
<li><p><em><strong>模板字符串</strong></em></p>
</li>
<li><p><em><strong>箭头函数</strong></em></p>
</li>
<li><p><em><strong>函数的参数默认值</strong></em></p>
</li>
<li><p><em><strong>对象和数组解构</strong></em></p>
</li>
<li><p><em><strong>for…of 和 for…in</strong></em></p>
</li>
<li><p><em><strong>ES6中的类</strong></em></p>
</li>
</ul>
<hr>
<h2 id="9-Let与var与const的区别"><a href="#9-Let与var与const的区别" class="headerlink" title="9.Let与var与const的区别"></a>9.Let与var与const的区别</h2><ul>
<li><p><strong>var声明的变量会挂载在window上,而let和const声明的变量不会;</strong></p>
</li>
<li><p><strong>声明变量存在变量提升,let和const不存在变量提升</strong></p>
</li>
<li><p><strong>let和const声明形成块作用域</strong></p>
</li>
<li><p><strong>同一作用域下let和const不能声明同名变量,而var可以</strong></p>
</li>
<li><p><strong>let暂存死区</strong></p>
</li>
</ul>
<hr>
<h2 id="10-数组方法有哪些请简述"><a href="#10-数组方法有哪些请简述" class="headerlink" title="10.数组方法有哪些请简述"></a>10.数组方法有哪些请简述</h2><p><em><strong>arr.push()</strong></em> <em><strong>从后面添加元素，返回值为添加完后的数组的长度</strong></em></p>
<p><em><strong>arr.pop()</strong></em> <em><strong>从后面删除元素，只能是一个，返回值是删除的元素</strong></em></p>
<p><em><strong>arr.shift()</strong></em> <em><strong>从前面删除元素，只能删除一个 返回值是删除的元素</strong></em></p>
<p><em><strong>arr.unshift()</strong></em> <em><strong>从前面添加元素, 返回值是添加完后的数组的长度</strong></em></p>
<p> <em><strong>arr.splice(i,n)</strong></em> <em><strong>删除从i(索引值)开始之后的那个元素。返回值是删除的元素</strong></em></p>
<p><em><strong>arr.concat()</strong></em> <em><strong>连接两个数组 返回值为连接后的新数组</strong></em></p>
<p><em><strong>str.split()</strong></em> <em><strong>将字符串转化为数组</strong></em></p>
<p> <em><strong>arr.sort()</strong></em> <em><strong>将数组进行排序,返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的</strong></em></p>
<p><em><strong>arr.reverse()</strong></em> <em><strong>将数组反转,返回值是反转后的数组</strong></em></p>
<p> <em><strong>arr.slice(start,end)</strong></em> <em><strong>切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组</strong></em></p>
<p> <em><strong>arr.forEach(callback)</strong></em> <em><strong>遍历数组,无return 即使有return，也不会返回任何值，并且会影响原来的数组</strong></em></p>
<p> <em><strong>arr.map(callback)</strong></em> <em><strong>映射数组(遍历数组),有return 返回一个新数组 。</strong></em></p>
<p> <em><strong>arr.filter(callback)</strong></em> <em><strong>过滤数组，返回一个满足要求的数组</strong></em> </p>
<hr>
<h2 id="11-Json如何新增-删除键值对"><a href="#11-Json如何新增-删除键值对" class="headerlink" title="11.Json如何新增/删除键值对"></a>11.Json如何新增/删除键值对</h2><p>(1)数据结构是Object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr=&#123;&#125;;</span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line">jsonStr[<span class="string">&quot;name1&quot;</span>]=<span class="string">&quot;yu&quot;</span>;</span><br><span class="line">jsonStr[<span class="string">&quot;name2&quot;</span>]=<span class="string">&quot;jin&quot;</span>;</span><br><span class="line">$.each(jsonStr,<span class="function"><span class="keyword">function</span>(<span class="params">_key</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Push结果：&quot;</span>+_key+<span class="string">&quot;==&quot;</span>+jsonStr[_key]+<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">$.each(jsonStr,<span class="function"><span class="keyword">function</span>(<span class="params">_key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> key = _key;</span><br><span class="line">    <span class="keyword">var</span> value = jsonStr[_key];</span><br><span class="line">    <span class="keyword">if</span>(_key==<span class="string">&quot;name1&quot;</span>)</span><br><span class="line">    &#123;  <span class="comment">//删除</span></span><br><span class="line"><span class="keyword">delete</span> jsonStr[_key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">$.each(jsonStr,<span class="function"><span class="keyword">function</span>(<span class="params">_key</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;删除后的结果：&quot;</span>+_key+<span class="string">&quot;==&quot;</span>+jsonStr[_key]+<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>(2)数据结构是Array</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;[&#123;&quot;name&quot;:&quot;aa&quot;,&quot;age&quot;:&quot;23&quot;&#125;]&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> array=<span class="built_in">JSON</span>.parse(str);</span><br><span class="line"><span class="comment">//新增</span></span><br><span class="line">array.push(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;dd&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;25&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="keyword">var</span> obj=array.firstOrDefault(</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.name==<span class="string">&#x27;bb&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">obj.age=<span class="number">25</span>;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">array.delete(</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.name==<span class="string">&#x27;cc&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//转为json字符串</span></span><br><span class="line">str=<span class="built_in">JSON</span>.stringify(array);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="12-什么是面向对象请简述"><a href="#12-什么是面向对象请简述" class="headerlink" title="12.什么是面向对象请简述"></a>12.什么是面向对象请简述</h2><p>首先，我们要明确，<strong>面向对象</strong>不是语法，是一个思想，是一种编程模式</p>
<p>**面向过程(POP)**：关注点在于做了什么，描述的是发展的过程。</p>
<p>**面向对象(OOP)**：关注点在于能做什么，描述的是对象与对象之间的关系。</p>
<p>面向对象的<strong>特点</strong>：继承、多态、封装</p>
<hr>
<h2 id="13-普通函数和构造函数去的区别"><a href="#13-普通函数和构造函数去的区别" class="headerlink" title="13.普通函数和构造函数去的区别"></a>13.普通函数和构造函数去的区别</h2><p><strong>构造函数</strong>:如用函数用来初始化(使用new运算符)一个新建的对象，我们称之为构造函数(constructor)</p>
<p><strong>普通函数</strong>:不使用new运算符的函数就是普通函数</p>
<p><strong>区别</strong>：</p>
<ol>
<li><p>构造函数也是一个普通函数，创建方式和普通函数一样，但构造函数习惯上<strong>首字母大写</strong></p>
</li>
<li><p>构造函数和普通函数的区别在于：调用方式不一样。作用也不一样（<strong>构造函数用来新建实例对象</strong>）</p>
</li>
<li><p>调用方式不一样。</p>
<p>a. 普通函数的调用方式：<strong>直接调用</strong> <code>person()</code>;</p>
<p>b.构造函数的调用方式：<strong>需要使用new关键字来调用</strong> <code>new Person()</code>;</p>
</li>
<li><p>构造函数的函数名与类名相同：<code>Person()</code> 这个构造函数，<code>Person</code> 既是函数名，也是这个对象的类名</p>
</li>
<li><p>构造函数内部可以使用<code>this</code>关键字；<strong>普通函数内部不建议使用</strong><code>this</code>，因为这时候<strong>this指向的是window全局对象</strong>，这样无意间就会为window添加了一些全局变量或函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,job,age</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.name=name;</span><br><span class="line">     <span class="built_in">this</span>.job=job;</span><br><span class="line">     <span class="built_in">this</span>.age=age;</span><br><span class="line">     <span class="built_in">this</span>.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">          alert(<span class="string">&quot;Hi&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure></li>
<li><p>构造函数的执行流程</p>
<ol>
<li><p>立刻在堆内存中创建一个新的对象<code>var p = &#123;&#125;;</code></p>
</li>
<li><p>将新建的对象设置为函数中的this</p>
</li>
<li><p>逐个执行函数中的代码</p>
</li>
<li><p>将新建的对象作为返回值</p>
</li>
</ol>
</li>
<li><p>普通函数例子：因为没有返回值，所以为undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> per = person(); </span><br><span class="line">consoLe.log(per);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li>
<li><p>构造函数例子：构造函数会马上创建一个新对象，并将该新对象作为返回值返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(per);<span class="comment">//[object object]</span></span><br></pre></td></tr></table></figure></li>
<li><p>用instanceof 可以检查一个对象是否是一个类的实例，是则返回true；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name , age , gender</span>)</span>&#123;</span><br><span class="line"><span class="comment">//往对象中添加属性和属性值</span></span><br><span class="line"><span class="built_in">this</span>.name = name ;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line"><span class="built_in">this</span>.gender = gender</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">&quot;张三”,18,&quot;</span>男<span class="string">&quot;);</span></span><br><span class="line"><span class="string">console.log(per);//[object object]  马上创建一个对象</span></span><br><span class="line"><span class="string">console.log(per.name);//&quot;</span>张三”</span><br><span class="line"><span class="built_in">console</span>.log(per.age);<span class="comment">//&quot;18&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(per <span class="keyword">instanceof</span> Person);<span class="comment">//&quot;true&quot; per为Person函数的实例，返回true</span></span><br></pre></td></tr></table></figure>

<p>​    所有对象都是Object对象的后代，所以任何对象和Object做instanceof都会返回true</p>
</li>
</ol>
<hr>
<h2 id="14-请简述原型-原型链-继承"><a href="#14-请简述原型-原型链-继承" class="headerlink" title="14.请简述原型/原型链/继承"></a>14.请简述原型/原型链/继承</h2><p>​        <strong>原型</strong>：<strong>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个<code>prototype</code>属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。</strong></p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>
<img src="https://img-blog.csdnimg.cn/img_convert/67e633b1b48eb146b188536fa57cbf5f.png" style="zoom:67%;" />

<p>​        <strong>原型对象</strong>就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p>
<p>​        <strong>隐式原型(<em>proto</em>)</strong>:上面说的这个原型是JavaScript中的内置属性<code>prototype</code>，此属性继承自object对象，在脚本中没有标准的方式访问<code>prototype</code>，但Firefox、Safari和Chrome在每个对象上都支持一个属性<code>_proto_</code>，隐式原型的作用是用来构成原型链，实现基于原型的继承</p>
<p>​        <strong>显示原型(prototype)</strong>:每一个函数在创建之后，便会拥有一个prototype属性，这个属性指向函数的原型对象，显示原型的作用是用来实现基于原型的继承与属性的共享</p>
<p>​        <strong>原型链</strong>:在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。<strong>如果在Object原型中依然没有找到，则返回undefined</strong></p>
<blockquote>
<ol>
<li>原型链解决的主要是继承问题</li>
<li>每个对象拥有一个原型对象，通过 proto 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null(<code>Object.proptotype.__proto__</code>指向的是null)。这种关系被称为原型链(prototype chain)，通过原型链一个对象可以拥有定义在其他对象中的属性和方法</li>
<li>构造函数 Parent、Parent.prototype 和 实例 p 的关系如下:(<code>p.__proto__ === Parent.prototype</code>)</li>
</ol>
</blockquote>
<hr>
<h2 id="15-Promise的理解"><a href="#15-Promise的理解" class="headerlink" title="15.Promise的理解"></a>15.Promise的理解</h2><p>​        Promise 是异步编程的一种解决方案：</p>
<ol>
<li>从语法上讲，promise是一个对象，从它可以获取异步操作的消息；</li>
<li>从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</li>
<li>promise有三种状态： **pending(等待态)<strong>，</strong>resolved(成功态)<strong>，</strong>rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。</li>
<li>在需要用到异步处理并且需要回调值时，但是promise<strong>本身并不是异步的</strong>。</li>
</ol>
<hr>
<h2 id="16-Promise在哪里使用过"><a href="#16-Promise在哪里使用过" class="headerlink" title="16.Promise在哪里使用过"></a>16.Promise在哪里使用过</h2><p>加载图片，ajax请求，vue接口请求</p>
<hr>
<h2 id="17-请简述async的用法"><a href="#17-请简述async的用法" class="headerlink" title="17.请简述async的用法"></a>17.请简述async的用法</h2><p><strong>(1)async函数的基本形式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"><span class="comment">//Class 的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cachePromise = caches.open(<span class="string">&#x27;avatars&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getAvatar</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="built_in">this</span>.cachePromise;</span><br><span class="line">    <span class="keyword">return</span> cache.match(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> Storage();</span><br><span class="line">storage.getAvatar(<span class="string">&#x27;jake&#x27;</span>).then(…);</span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>(2) async函数的返回值总是一个Promise</strong></p>
<p>​        无论async函数有无await操作，其总是返回一个Promise。</p>
<ol>
<li><p>没有显式return，相当于return Promise.resolve(undefined);</p>
</li>
<li><p>return非Promise的数据data，相当于return Promise.resolve(data);</p>
</li>
<li><p>return Promise, 会得到Promise对象本身</p>
<blockquote>
<p>​    async总是返回Promise，因此，其后面可以直接调用then方法，函数内部return返回的值，会成为then回调函数的参数函数内部抛出的错误，会被then的第二个函数或catch方法捕获到</p>
</blockquote>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正常返回值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    retrun <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v));<span class="comment">//hello world</span></span><br><span class="line"><span class="comment">//抛出错误</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">f().then(</span><br><span class="line">    <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v),</span><br><span class="line">    <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e) <span class="comment">//Error: 出错了</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="18-jQuery相关的知识"><a href="#18-jQuery相关的知识" class="headerlink" title="18.jQuery相关的知识"></a>18.jQuery相关的知识</h2><p> 见jquery</p>
<hr>
<h2 id="19-Css预处理sass-less是什么？为什么使用他们"><a href="#19-Css预处理sass-less是什么？为什么使用他们" class="headerlink" title="19.Css预处理sass less是什么？为什么使用他们"></a>19.Css预处理sass less是什么？为什么使用他们</h2><p>​        <strong>Sass 和 LESS</strong>都是是 CSS 预处理器，是 CSS 上的一种抽象层，是一种特殊的 语法/语言 最终会编译成 CSS</p>
<p>​        <strong>less</strong>是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数.。less 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可一在服务端运行(需要借助 Node.js)。</p>
<p><strong>为什么要使用它们？</strong></p>
<ol>
<li>结构清晰，便于扩展。</li>
<li>可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。</li>
<li>可以轻松实现多重继承。</li>
<li>完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li>
</ol>
<hr>
<h2 id="20-Js中-call-与-apply-区别"><a href="#20-Js中-call-与-apply-区别" class="headerlink" title="20.Js中.call()与.apply()区别"></a>20.Js中.call()与.apply()区别</h2><p><code>apply</code>接受两个参数，第一个参数指定了函数体内<code>this</code>对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，</p>
<p><code>apply</code>方法把这个集合中的元素作为参数传递给被调用的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([a,b,c])</span><br><span class="line">&#125;</span><br><span class="line">func.apply(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>

<p><code>call</code>传入的参数数量不固定，跟<code>apply</code>相同的是，第一个参数也是代表函数体内的<code>this</code>指向，从第二个参数开始往后，每个参数被依次传入函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([a,b,c])</span><br><span class="line">&#125;</span><br><span class="line">func.call(<span class="literal">null</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">// [3,4,5]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="21-为什么会造成跨域-请简述同源策略"><a href="#21-为什么会造成跨域-请简述同源策略" class="headerlink" title="21.为什么会造成跨域/请简述同源策略"></a>21.为什么会造成跨域/请简述同源策略</h2><p><strong>为什么会造成跨域</strong></p>
<p>​        因为浏览器的<strong>同源政策</strong>，就会产生跨域。比如说发送的异步请求是不同的两个源，就比如是不同的的两个端口或者不同的两个协议或者不同的域名。由于浏览器为了安全考虑，就会产生一个同源政策，不是同一个地方出来的是不允许进行交互的。</p>
<p><strong>简述同源策略</strong></p>
<p>​        <strong>同源策略</strong>是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。<br>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。</p>
<p>​        指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<hr>
<h2 id="22-This指向"><a href="#22-This指向" class="headerlink" title="22.This指向"></a>22.This指向</h2><ol>
<li><p>如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window。</p>
<blockquote>
<p>这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。</p>
</blockquote>
</li>
<li><p>如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。</p>
</li>
<li><p>一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。</p>
</li>
</ol>
<hr>
<h2 id="23-请输出三种减少页面加载时间的方式"><a href="#23-请输出三种减少页面加载时间的方式" class="headerlink" title="23.请输出三种减少页面加载时间的方式"></a>23.请输出三种减少页面加载时间的方式</h2><ol>
<li>优化图片 </li>
<li>图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）</li>
<li>优化CSS（压缩合并css，如margin-top,margin-left…)</li>
<li>网址后加斜杠，对服务器而言，不加斜杠服务器会多一次判断的过程，加斜杠就会直接返回网站设置的存放在网站根目录下的默认页面。</li>
<li>标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）</li>
<li>减少http请求（合并文件，合并图片）。</li>
</ol>
<hr>
<h2 id="24-什么是jsonp，工作原理是什么？他为什么不是真正的ajax"><a href="#24-什么是jsonp，工作原理是什么？他为什么不是真正的ajax" class="headerlink" title="24.什么是jsonp，工作原理是什么？他为什么不是真正的ajax"></a>24.什么是jsonp，工作原理是什么？他为什么不是真正的ajax</h2><p><strong>Jsonp其实就是一个跨域解决方案。</strong></p>
<p><strong>jsonp的原理</strong>:就是利用浏览器可以动态地插入一段js并执行的特点完成的。</p>
<p><strong>为什么不是真正的 ajax?</strong>   </p>
<p><strong>ajax的核心</strong>：通过<code>XmlHttpRequest</code>获取非本页内容，</p>
<p><strong>jsonp的核心</strong>：动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。</p>
<p><strong>相同点：</strong></p>
<p>​        ajax和jsonp的调用方式很像，目的一样，都是请求url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；</p>
<p><strong>不同点：</strong></p>
<ol>
<li><p>实质不同<br>ajax的核心是通过xmlHttpRequest获取非本页内容</p>
<p>jsonp的核心是动态添加script标签调用服务器提供的js脚本</p>
</li>
<li><p>ajax通过服务端代理一样跨域</p>
<p>jsonp也不并不排斥同域的数据的获取</p>
</li>
<li><p>jsonp是一种方式或者说非强制性的协议</p>
<p>ajax也不一定非要用json格式来传递数据　</p>
</li>
<li><p>jsonp只支持get请求，ajax支持get和post请求</p>
</li>
</ol>
<hr>
<h2 id="25-请掌握2种以上数组去重的方式"><a href="#25-请掌握2种以上数组去重的方式" class="headerlink" title="25.请掌握2种以上数组去重的方式"></a>25.请掌握2种以上数组去重的方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> originalArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p><strong>方式1：(ES6的Set集合)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(originalArray));</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// -&gt; [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>方式2:(map集合)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = [];</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> originalArray) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!map.has(v)) &#123;</span><br><span class="line">        map.set(v, <span class="literal">true</span>);</span><br><span class="line">        result.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// -&gt; [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>方式3:(Includes)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> originalArray) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.includes(v)) &#123;</span><br><span class="line">        result.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// -&gt; [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>方式4:(前后对比)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; originalArray.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; originalArray.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (originalArray[i] === originalArray[j]) &#123;</span><br><span class="line">            originalArray.splice(j, <span class="number">1</span>);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(originalArray); <span class="comment">// -&gt; [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>方式5:(Filter过滤器)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> result = originalArray.filter(<span class="function"><span class="params">item</span> =&gt;</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span>:(obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>));</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// -&gt; [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="26-深浅拷贝是什么-如何实现？"><a href="#26-深浅拷贝是什么-如何实现？" class="headerlink" title="26.深浅拷贝是什么,如何实现？"></a>26.深浅拷贝是什么,如何实现？</h2><blockquote>
<p><strong>浅拷贝</strong>只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，</p>
<p><strong>深拷贝</strong>不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。</p>
<p><strong>浅拷贝</strong>只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p>
<p><strong>但深拷贝</strong>会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</p>
</blockquote>
<p>​        <strong>浅拷贝</strong>子对象复制父对象，父子对象发生关联，两者属性值指向同一内存空间。简单来讲，就是改变其中一个对象，另一个对象也会跟着改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],b = a;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b) <span class="comment">// [3,1,2] [3,1,2]</span></span><br></pre></td></tr></table></figure>

<p>​        <strong>深拷贝</strong>拷贝对象各个层级的属性。简单的讲，就是复制出来的每个对象都有属于自己的内存空间，不会互相干扰。</p>
<p><strong>借用JSON对象的 parse（转JavaScript 对象） 和 stringify（转json字符串）</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line">    <span class="keyword">let</span> objClone = <span class="built_in">JSON</span>.parse(newObj);</span><br><span class="line">    <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a=[<span class="number">0</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="27-为什么js是弱类型语言"><a href="#27-为什么js是弱类型语言" class="headerlink" title="27.为什么js是弱类型语言"></a>27.为什么js是弱类型语言</h2><p>​        <strong>弱类型语言</strong>是相对强类型语言来说的。</p>
<p>​        在强类型语言中，变量类型有多种，例如<code>int</code> <code>char</code> <code>float</code> <code>boolean</code> 等不同的类型相互转换有时需要强制转换而javascript只有一种类型<code>var</code>，为变量赋值时会自动判断类型并进行转换，所以javascript是弱语言就体现在变量定义类型var上了 </p>
<hr>
<h2 id="28-怎么转换less为css"><a href="#28-怎么转换less为css" class="headerlink" title="28.怎么转换less为css"></a>28.怎么转换less为css</h2><p>​        <strong>Less</strong> 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。</p>
<ol>
<li>首先，你要确认你的电脑已经安装了node。</li>
<li>使用 npm 安装 lessc，命令行：<br><code>npm install -g less</code></li>
<li>然后，进入需要转换的less文件的目标位置。</li>
<li>最后，你只需输入以下两条命令：</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install -g less</span><br><span class="line">lessc less文件名.less 生成的css文件名.css</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="29-echarts使用最多的是什么"><a href="#29-echarts使用最多的是什么" class="headerlink" title="29.echarts使用最多的是什么"></a>29.echarts使用最多的是什么</h2><blockquote>
<p>​        商业级数据图表，它是一个纯JavaScript的图标库，兼容绝大部分的浏览器，底层依赖轻量级的canvas类库ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。创新的拖拽重计算、数据视图、值域漫游等特性大大增强了用户体验，赋予了用户对数据进行挖掘、整合的能力。</p>
</blockquote>
<p><strong>折线图（区域图）、柱状图（条状图）、散点图（气泡图）、K线图、饼图（环形图）</strong></p>
<p><strong>雷达图（填充雷达图）</strong></p>
<hr>
<h2 id="30-For循环与map循环有什么区别"><a href="#30-For循环与map循环有什么区别" class="headerlink" title="30.For循环与map循环有什么区别"></a>30.For循环与map循环有什么区别</h2><blockquote>
<p><strong>for</strong>:遍历对象自身的和继承的可枚举的属性，也就是说会包括那些原型链上的属性。如果想要仅迭代自身的属性，那么在使用 for…in</p>
<p><strong>forEach</strong>:只能遍历数组，不能中断，没有返回值(或认为返回值是undefined)</p>
<p><strong>map</strong>:只能遍历数组，不能中断，返回值是修改后的数组</p>
</blockquote>
<p><strong>forEach和map的区别</strong></p>
<p><strong>相同点</strong></p>
<ol>
<li>都是循环遍历数组中的每一项</li>
<li>forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item(当前每一项)，index(索引值)，arr(原数组)</li>
<li>匿名函数中的this都是指向window</li>
<li>只能遍历数组,都不会改变原数组</li>
</ol>
<p><strong>区别</strong><br><strong>map方法</strong></p>
<ol>
<li>map方法<strong>返回一个新的数组</strong>，数组中的元素为原始数组调用函数处理后的值。</li>
<li>map方法不会对空数组进行检测，map方法<strong>不会改变原始数组</strong>。</li>
<li>浏览器支持：chrome、Safari1.5+、opera都支持，IE9+,</li>
<li>若arr为空数组，则map方法返回的也是一个空数组。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;&#125;,thisValue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> str = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;原数组arr:&quot;</span>,arr); <span class="comment">//注意这里执行5次</span></span><br><span class="line">    <span class="keyword">return</span> item/<span class="number">2</span>;</span><br><span class="line">&#125;,<span class="built_in">this</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//[0,1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<p><strong>forEach方法</strong></p>
<ol>
<li>forEach方法用来调用数组的每个元素，将元素传给回调函数</li>
<li>forEach对于空数组是不会调用回调函数的。</li>
<li>无论arr是不是空数组，forEach返回的都是undefined。这个方法只是将数组中的每一项作为callback的参数执行一次。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;&#125;,<span class="built_in">this</span>)</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> str = arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line">    sum += item;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;sum的值为：&quot;</span>,sum); <span class="comment">//0 2 6 12 20</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//window</span></span><br><span class="line">&#125;,<span class="built_in">this</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum);<span class="comment">//20</span></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="31-请写出一个简单的类与继承"><a href="#31-请写出一个简单的类与继承" class="headerlink" title="31.请写出一个简单的类与继承"></a>31.请写出一个简单的类与继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _this = <span class="built_in">this</span>; <span class="comment">// 声明一个 _this 指向当前的this</span></span><br><span class="line">	<span class="comment">// 定义一个类名为 myLike 的类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">myLike</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 定义一个 JS 构造器</span></span><br><span class="line">		<span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">			_this.type = type;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 创建实例方法</span></span><br><span class="line">		<span class="function"><span class="title">sayType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&#x27;我喜欢&#x27;</span> + _this.type);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建一个类名为 Programmer 的类的继承 myLike 类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">extends</span> <span class="title">myLike</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="title">constructor</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">			<span class="comment">// 直接调用父类构造器进行初始化操作</span></span><br><span class="line">			<span class="built_in">super</span>(type);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="title">program</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&quot;我是一个写代码的游戏主播&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 测试我刚创建的类</span></span><br><span class="line">	<span class="keyword">var</span> goPlay = <span class="keyword">new</span> myLike(<span class="string">&#x27;打游戏&#x27;</span>), <span class="comment">// 声明一个打游戏的对象</span></span><br><span class="line">		writeCode = <span class="keyword">new</span> Programmer(<span class="string">&#x27;写代码&#x27;</span>); <span class="comment">// 声明一个写代码的对象</span></span><br><span class="line">	<span class="comment">// 开始测试程序结果</span></span><br><span class="line">	goPlay.sayType(); <span class="comment">// 输出  我喜欢打游戏</span></span><br><span class="line">	writeCode.sayType(); <span class="comment">// 输出  我喜欢写代码</span></span><br><span class="line">	writeCode.program(); <span class="comment">// 输出  我是一个写代码的游戏主播</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="32-同步与异步的区别-阻塞与非阻塞区别"><a href="#32-同步与异步的区别-阻塞与非阻塞区别" class="headerlink" title="32.同步与异步的区别/阻塞与非阻塞区别"></a>32.同步与异步的区别/阻塞与非阻塞区别</h2><p>​        “阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。<br><strong>同步与异步</strong><br>​        同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication/ asynchronous communication)</p>
<p>​        所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p>
<p>​        而异步则是相反，<strong>调用在发出之后，这个调用就直接返回了，所以没有返回结果</strong>。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>典型的异步编程模型比如Node.js</p>
<blockquote>
<p>举个通俗的例子：<br>        你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
</blockquote>
<p><strong>阻塞与非阻塞</strong><br>        阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p>
<p>​        <strong>阻塞调用</strong>是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>​        <strong>非阻塞调用</strong>指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<blockquote>
<p>还是上面的例子，<br>        你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
</blockquote>
<hr>
<h2 id="33-重绘和回流是什么"><a href="#33-重绘和回流是什么" class="headerlink" title="33.重绘和回流是什么"></a>33.重绘和回流是什么</h2><p>​        引起DOM树结构变化，页面布局变化的行为叫<strong>回流</strong>，且回流<strong>一定</strong>伴随重绘。</p>
<p>​        只是样式的变化，不会引起DOM树变化，页面布局变化的行为叫<strong>重绘</strong>，且重绘<strong>不一定</strong>会便随回流。</p>
<hr>
<h2 id="34-http是什么？有什么特点"><a href="#34-http是什么？有什么特点" class="headerlink" title="34.http是什么？有什么特点"></a>34.http是什么？有什么特点</h2><p><strong>超文本</strong> <strong>传输</strong> <strong>协议</strong></p>
<p>特点:</p>
<ol>
<li>支持客户/服务器模式；</li>
<li>简单快速；</li>
<li>灵活；</li>
<li>无连接；(是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接)</li>
<li>无状态。(http协议没法保存客户机信息，也就没法区分每次请求的不同之处)</li>
</ol>
<hr>
<h2 id="35-HTTP协议和HTTPS区别"><a href="#35-HTTP协议和HTTPS区别" class="headerlink" title="35.HTTP协议和HTTPS区别"></a>35.HTTP协议和HTTPS区别</h2><ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的<strong>端口也不一样</strong>，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ol>
<hr>
<h2 id="36-原型和继承，prototype，call和apply继承的区别（第一个参数是相同的，第二个的区别在哪）"><a href="#36-原型和继承，prototype，call和apply继承的区别（第一个参数是相同的，第二个的区别在哪）" class="headerlink" title="36.原型和继承，prototype，call和apply继承的区别（第一个参数是相同的，第二个的区别在哪）"></a>36.原型和继承，prototype，call和apply继承的区别（第一个参数是相同的，第二个的区别在哪）</h2><p><strong>js继承的6种方式</strong></p>
<p>​        想要继承，就必须要提供个父类（继承谁，提供继承的属性）</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTkwNy85NDA4ODQtMjAxOTA3MTcxNjIwNTQyNjctMTIwMDIxMTI3Ni5wbmc?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述" style="zoom: 67%;" />

<p><strong>1. 原型链继承</strong></p>
<p><strong>核心：</strong></p>
<blockquote>
<p>将父类的实例作为子类的原型</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>子类的实例也是父类的实例</li>
<li>可以方便的继承父类型的原型中的方法，但是属性的继承无意义<br><strong>缺点：</strong></li>
<li>只执行一次，无法给属性传值</li>
<li>属性的继承无意义</li>
</ul>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDU5Mjc5NS02OTY0MWMzNGY1YTUwYmE4LlBORw?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述" style="zoom:67%;" />

<p><strong>2.借用构造函数继承</strong></p>
<p><strong>核心：</strong></p>
<p>在子类的内部调用父类，通过call改变父类中this的指向<br>等于是复制父类的实例属性给子类</p>
<p><strong>特点:</strong></p>
<p>创建子类实例时，可以向父类传递参数<br>可以实现多继承<br>可以方便的继承父类型的属性，但是无法继承原型中的方法<br><strong>缺点：</strong></p>
<p>实例并不是父类的实例，只是子类的实例<br>无法继承原型中的方法<br>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>
<p><strong>3.组合继承（组合原型链继承和借用构造函数继承）</strong></p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTkwNy85NDA4ODQtMjAxOTA3MTcxNjIxMzcwODQtMTIzNDYyMzEyMC5wbmc?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述" style="zoom:67%;" />

<p><strong>核心：</strong></p>
<blockquote>
<p>结合了两种模式的优点，传参和复用</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>可以继承父类原型上的属性，可以传参，可复用。</li>
<li>每个新实例引入的构造函数属性是私有的。</li>
</ul>
<p><strong>缺点：</strong> 调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</p>
<p><strong>4.原型式继承</strong></p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTkwNy85NDA4ODQtMjAxOTA3MTcxNjIxNDc1OTYtMTM2MzQ4NjU4Ni5wbmc?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述" style="zoom:67%;" />

<p><strong>核心：</strong></p>
<p>​        用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。</p>
<p><strong>特点：</strong> 类似于复制一个对象，用函数来包装。</p>
<p><strong>缺点：</strong></p>
<p>所有实例都会继承原型上的属性。<br>无法实现复用。（新实例属性都是后面添加的）</p>
<p><strong>5.寄生式继承</strong></p>
<p><strong>核心</strong><br>就是给原型式继承外面套了个壳子。</p>
<p><strong>特点：</strong> 没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。<br><strong>缺点：</strong> 没用到原型，无法复用。</p>
<p><strong>6.寄生组合式继承（常用）</strong><br><strong>核心：</strong></p>
<p>修复了组合继承的问题</p>
<p><strong>寄生</strong>:在函数内返回对象然后调用</p>
<p><strong>组合:</strong><br>1.函数的原型等于另一个实例。</p>
<p>2.在函数中用apply或者call引入另一个构造函数，可传参</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvOTQwODg0LzIwMTkwNy85NDA4ODQtMjAxOTA3MTcxNjIyMjAyODUtMTQ3ODg4ODkzNi5wbmc?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述" style="zoom:67%;" />

<p><a href="#20.Js%E4%B8%AD.call()%E4%B8%8E.apply()%E5%8C%BA%E5%88%AB">call和apply继承的区别</a></p>
<hr>
<h2 id="37-数组的方法，字符串的方法，要知道每个的含义，掌握排序和去重的方法"><a href="#37-数组的方法，字符串的方法，要知道每个的含义，掌握排序和去重的方法" class="headerlink" title="37.数组的方法，字符串的方法，要知道每个的含义，掌握排序和去重的方法"></a>37.数组的方法，字符串的方法，要知道每个的含义，掌握排序和去重的方法</h2><p><a href="#10%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AF%B7%E7%AE%80%E8%BF%B0">数组的方法</a></p>
<p><strong>字符串的方法：</strong></p>
<p><strong>charAt()</strong> 返回指定位置的字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str_two.charAt(<span class="number">2</span>));  <span class="comment">//c</span></span><br></pre></td></tr></table></figure>

<p><strong>.length</strong> 返回字符串的长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str_two.length);<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p><strong>charCodeAt():</strong> 返回指定位置的字符 的Unicode编码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str_two.charCodeAt(<span class="number">3</span>));<span class="comment">//68</span></span><br></pre></td></tr></table></figure>

<p><strong>fromCharCode():</strong> 接受一个UniCode编码， 返回对应的字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">68</span>));<span class="comment">//D</span></span><br></pre></td></tr></table></figure>

<p><strong>replace():</strong> 替换</p>
<blockquote>
<p>1.想替换哪个字符串，就用哪个字符串来调用<br>2.参数1是被替换的目标， 参数2是替换的新内容<br>3.会将替换后的字符串，整体返回</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(str_two.replace(&quot;a&quot;,&quot;A&quot;));//AbcDg</span><br></pre></td></tr></table></figure>

<p><strong>substring()</strong> : 提取 介于两个下标之间的 字符串 包头不包尾 (和数组slice相似)</p>
<blockquote>
<p>参数1： 开始下标 参数2： 结束下标</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str_two.substring(<span class="number">0</span>,<span class="number">2</span>));<span class="comment">//ab</span></span><br></pre></td></tr></table></figure>

<p><strong>substr()</strong>: 可在字符串中 从开始位置截取指定长度的字符串 (和数组splice相似)</p>
<blockquote>
<p>参数1： 开始位置， 参数2 ： 指定长度</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(str_two.substr(<span class="number">0</span>,<span class="number">3</span>));<span class="comment">//abc</span></span><br></pre></td></tr></table></figure>

<p><strong>split()</strong>:方法用于把一个字符串 分割成字符串数组(本质上就是个数组，只是存的都是字符串罢了)</p>
<blockquote>
<p>参数1 ：分割的依据<br>参数2：(可选参数)分割后 返回的长度<br>(超出实际大小，按照实际大小算。 小于实际大小的话，按照指定长度返回，超出的不返回)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;Where are you from?&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(s.split(<span class="string">&quot; &quot;</span>,<span class="number">2</span>));<span class="comment">//[&quot;Where&quot;, &quot;are&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>slice():</strong> 方法 可提取指定范围 的字符串</p>
<blockquote>
<p>参数1： 开始范围, 参数2： 结束范围 包头不包尾</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s.slice(<span class="number">0</span>,<span class="number">4</span>)); <span class="comment">//wher</span></span><br></pre></td></tr></table></figure>

<p><strong>indexOf()</strong>: 方法可返回指定字符 的对应下标 (首先出现的)<br>如果没有 ： 返回 -1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   用indexof（）去重：</span></span><br><span class="line">     <span class="keyword">var</span> arr_new= <span class="string">&quot;jintianbucuo&quot;</span>;    </span><br><span class="line">                <span class="keyword">var</span> arr_two=[];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr_new.length;i++) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(arr_two.indexOf(arr_new[i])==-<span class="number">1</span>)&#123;</span><br><span class="line">                           arr_two.push(arr_new[i]);</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">console</span>.log(arr_two.join(<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>lastIndexOf()</strong>: 返回指定字符 最后出现的位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s.lastIndexOf(<span class="string">&#x27; &#x27;</span>));<span class="comment">//19</span></span><br></pre></td></tr></table></figure>

<p>需要谁改变，就由谁来调用这个方法<br><strong>toLowerCase() :</strong> 把字符串转换为小写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s.toLowerCase());</span><br></pre></td></tr></table></figure>

<p><strong>toUpperCase() :</strong> 把字符串转换为大写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s.toUpperCase());</span><br></pre></td></tr></table></figure>

<p><strong>用splice（）去重：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arr</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;a.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]==a[j])&#123;</span><br><span class="line">                     a.splice(j,<span class="number">1</span>);</span><br><span class="line">                   --j;</span><br><span class="line">                   </span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">            &#125; <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> d=[<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>];</span><br><span class="line">         <span class="built_in">console</span>.log(arr(d));</span><br></pre></td></tr></table></figure>

<p><strong>数组的排序：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>];           </span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++) &#123;</span><br><span class="line">                   <span class="keyword">if</span>(arr[i]&gt;arr[j])&#123;</span><br><span class="line">                       <span class="keyword">var</span> mm=arr[i];</span><br><span class="line">                        arr[i]=arr[j];</span><br><span class="line">                        arr[j]=mm;</span><br><span class="line">                     &#125;      </span><br><span class="line">                  &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="38-箭头函数与普通函数的区别"><a href="#38-箭头函数与普通函数的区别" class="headerlink" title="38.箭头函数与普通函数的区别"></a>38.箭头函数与普通函数的区别</h2><p><strong>一.外形不同</strong>：</p>
<p>​        箭头函数使用箭头定义，普通函数中没有<br>代码实例如下：</p>
<p><strong>二.箭头函数都是匿名函数</strong><br>        普通函数可以有匿名函数，也可以有具体名函数，但是箭头函数都是匿名函数。<br>代码实例如下：</p>
<p><strong>三.箭头函数不能用于构造函数，不能使用new</strong><br>        普通函数可以用于构造函数，以此创建对象实例。<br>代码实例如下：</p>
<p><strong>四.箭头函数中this的指向不同</strong><br>        在普通函数中，this总是指向调用它的对象，如果用作构造函数，this指向创建的对象实例。<br>1.箭头函数本身不创建this<br>        也可以说箭头函数本身没有this，但是它在声明时可以捕获其所在上下文的this供自己使用。<br>注意：this一旦被捕获，就不再发生变化</p>
<hr>
<h2 id="39-什么是js内存泄露？"><a href="#39-什么是js内存泄露？" class="headerlink" title="39.什么是js内存泄露？"></a>39.什么是js内存泄露？</h2><p>​        指由于疏忽或者错误造成程序未能释放已经不再使用的内存，从而造成内存上的浪费。</p>
<p><strong>原因：</strong></p>
<p>1） 意外的全局变量引起的内存泄露</p>
<p>2）闭包引起的内存泄露</p>
<p>3）没有清理的DOM元素引用</p>
<p>4）被遗忘的定时器或者回调</p>
<p>5）子元素存在引起的内存泄露</p>
<p>6）IE7/8引用计数使用循环引用产生的问题</p>
<p><strong>怎样避免内存泄露</strong></p>
<p>1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；</p>
<p>2）注意程序逻辑，避免“死循环”之类的 ；</p>
<p>3）避免创建过多的对象 原则：不用了的东西要及时归还。</p>
<hr>
<h2 id="40-你如何对网站的文件和资源进行优化？"><a href="#40-你如何对网站的文件和资源进行优化？" class="headerlink" title="40.你如何对网站的文件和资源进行优化？"></a>40.你如何对网站的文件和资源进行优化？</h2><ol>
<li><p>文件合并（目的是减少http请求）</p>
</li>
<li><p>文件压缩，减少文件下载的体积。</p>
</li>
<li><p>使用 CDN （内容分发网络）来托管资源</p>
</li>
<li><p>使用缓存。</p>
</li>
<li><p>精简优化自己的css和js代码</p>
</li>
</ol>
<hr>
<h2 id="41-请简述ajax的执行过程-以及常见的HTTP状态码"><a href="#41-请简述ajax的执行过程-以及常见的HTTP状态码" class="headerlink" title="41.请简述ajax的执行过程 以及常见的HTTP状态码"></a>41.请简述ajax的执行过程 以及常见的HTTP状态码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//步骤一:创建异步对象</span></span><br><span class="line"><span class="keyword">var</span> xmlHTTP = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">//步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端</span></span><br><span class="line">xmlHTTP.open(method, url, isAsync)</span><br><span class="line"><span class="comment">//步骤三:发送请求</span></span><br><span class="line">xmlHTTP.send();</span><br><span class="line"><span class="comment">//步骤四:注册事件 onreadystatechange 状态改变就会调用</span></span><br><span class="line">xmlHTTP.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span> &amp;&amp; xmlHTTP.status == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">//步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的</span></span><br><span class="line">       <span class="built_in">console</span>.log(xmlHTTP.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>xmlHttp.readyState的五种状态</strong><br><strong>0</strong> ：请求未初始化，XMLHttpRequest对象已经创建，但还没有调用open()方法。</p>
<p><strong>1</strong> ：请求已建立，已经调用open() 方法，但尚未发送请求。</p>
<p><strong>2</strong> ： 请求已发送，正在处理中（通常现在可以从响应中获取内容头）</p>
<p><strong>3</strong> ： 请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。</p>
<p><strong>4</strong> ：响应完成，已经接收到了全部数据，并且连接已经关闭。</p>
</blockquote>
<p><strong>常见的HTTP状态码</strong><br><strong>200</strong> ： OK 客户端请求成功</p>
<p><strong>400</strong> ： Bad Request 客户端请求有语法错误，不能被服务器所理解</p>
<p><strong>401</strong> ： Unauthorized 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</p>
<p><strong>403</strong> ： Forbidden 服务器收到请求，但是拒绝提供服务</p>
<p><strong>404</strong> ： Not Found 请求资源不存在，eg：输入了错误的URL</p>
<p><strong>500</strong> ： Internal Server Error 服务器发生不可预期的错误</p>
<p><strong>503</strong> ： Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
<hr>
<h2 id="42-预加载和懒加载的区别，预加载在什么时间加载合适"><a href="#42-预加载和懒加载的区别，预加载在什么时间加载合适" class="headerlink" title="42.预加载和懒加载的区别，预加载在什么时间加载合适"></a>42.预加载和懒加载的区别，预加载在什么时间加载合适</h2><p>​        <strong>预加载</strong>是指在页面加载完成之前，提前将所需资源下载，之后使用的时候从缓存中调用；</p>
<p>​        <strong>懒加载</strong>是延迟加载，按照一定的条件或者需求等到满足条件的时候再加载对应的资源</p>
<p>​        <strong>预加载</strong>增加了服务器压力，换来的是用户体验的提升，典型例子是在一个图片较多的网页中，如果使用了预加载就可以避免网页加载出来是时，图片的位置一片空白（图片可能还没加载出来），造成不好的用户体验；</p>
<p>​        <strong>懒加载</strong>的作用减少不要的请求，缓解了服务器压力</p>
<p><strong>懒加载的原理</strong></p>
<p>​        原理很简单，先把img的src指向空或者一个小图片，图片真实的地址存储在img一个自定义的属性里,<code>&lt; img src=”” data-src=”http://real.com/real.jpg” /&gt;</code>,等到此图片出现在视野范围内了，获取img元素，把data-src里的值赋给src。这样做能防止页面一次性向服务器响应大量请求导致服务器响应慢，页面卡顿或崩溃等问题。</p>
<p><strong>优点</strong>：页面加载速度快、可以减轻服务器的压力、节约了流量,用户体验好</p>
<p><strong>预加载的原理</strong></p>
<p>​        提前加载图片，当用户需要查看时可直接从本地缓存中渲染</p>
<p><strong>意义</strong>：预加载可以说是牺牲服务器前端性能，换取更好的用户体验，这样可以使用户的操作得到最快的反映。</p>
<hr>
<h2 id="43-Jquery选择器有哪些"><a href="#43-Jquery选择器有哪些" class="headerlink" title="43.Jquery选择器有哪些"></a>43.Jquery选择器有哪些</h2><ol>
<li><p><strong>jquery基本选择器</strong></p>
<p>通过元素<u>id</u>、<u>class</u>和<u>标签名</u>来查找DOM元素。</p>
<p><code>$(&quot; &quot;)</code></p>
</li>
<li><p><strong>jquery层次选择器</strong></p>
<p>层次选择器通过DOM元素间的层次关系来获取元素</p>
<table>
<thead>
<tr>
<th><code>$(&quot;form input&quot;)</code></th>
<th>选择所有的form元素中的input元素</th>
</tr>
</thead>
<tbody><tr>
<td><code>$(&quot;#main &gt; *&quot;)</code></td>
<td>选择id值为main的所有的子元素</td>
</tr>
<tr>
<td><code>$(&quot;label + input&quot;)</code></td>
<td>选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素</td>
</tr>
<tr>
<td><code>$(&quot;#prev ~ div&quot;)</code></td>
<td>同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签</td>
</tr>
</tbody></table>
</li>
<li><p><strong>jquery过滤选择器</strong></p>
<p>分为<strong>基本过滤，内容过滤，可见性过滤，属性过滤，子元素过滤和表单对象属性过滤选择器</strong>共六种选择器</p>
<p><strong>（1）jquery基本过滤选择器</strong></p>
<p>过滤选择器是根据某类过滤规则进行元素的匹配，书写时都以(:)开头；简单过滤选择器是过滤选择器中使用最广泛的一种。</p>
<p><code>$(&quot;tr:first&quot;)</code>：选择所有tr元素的第一个</p>
<p><code>$(&quot;tr:last&quot;)</code>：选择所有tr元素的最后一个</p>
<p><code>$(&quot;input:not(:checked) + span&quot;)</code> ：过滤掉：checked的选择器的所有的input元素</p>
<p><code>$(&quot;tr:even&quot;)</code>：选择所有的tr元素的第0，2，4… …个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始）</p>
<p><code>$(&quot;tr:odd&quot;)</code>：选择所有的tr元素的第1，3，5… …个元素</p>
<p><code>$(&quot;td:eq(2)&quot;)</code>：选择所有的td元素中序号为2的那个td元素</p>
<p><code>$(&quot;td:gt(4)&quot;)</code> ：选择td元素中序号大于4的所有td元素</p>
<p><code>$(&quot;td:ll(4)&quot;)</code>：选择td元素中序号小于4的所有的td元素</p>
<p><code>$(&quot;:header&quot;)</code>：匹配如 h1, h2, h3之类的标题元素.这个是专门用来获取h1,h2这样的标题元素</p>
<p><code>$(&quot;div:animated&quot;)</code>：匹配所有正在执行动画效果的元素</p>
<p><strong>（2）jquery内容过滤选择器</strong></p>
<p>内容过滤选择器的过滤规则主要体现在它所包含的子元素和文本内容上。</p>
<p><code>$(&quot;div:contains(&#39;John&#39;)&quot;)</code> ：选择所有div中含有John文本的元素</p>
<p><code>$(&quot;td:empty&quot;)</code> ：选择所有的为空（也不包括文本节点）的td元素的数组</p>
<p><code>$(&quot;div:has(p)&quot;)</code> ：选择所有含有p标签的div元素</p>
<p><code>$(&quot;td:parent&quot;)</code>：选择所有的以td为父节点的元素数组</p>
<p><strong>（3）jquery可见性过滤选择器</strong></p>
<p>可见度过滤选择器是根据元素的可见和不可见状态来选择相应的元素。</p>
<p><code>$(&quot;div:hidden&quot;)</code>：选择所有的被hidden的div元素</p>
<p><code>$(&quot;div:visible&quot;)</code>：选择所有的可视化的div元素</p>
<p><strong>（4）jquery属性过滤选择器</strong></p>
<p>属性过滤选择器的过滤规则是通过元素的属性来获取相应的元素。</p>
<p><code>$(&quot;div[id]&quot;)</code>： 选择所有含有id属性的div元素</p>
<p><code>$(&quot;input[name=&#39;newsletter&#39;]&quot;)</code>：选择所有的name属性等于’newsletter’的input元素</p>
<p><code>$(&quot;input[name!=&#39;newsletter&#39;]&quot;)</code> ：选择所有的name属性不等于’newsletter’的input元素</p>
<p><code>$(&quot;input[name^=&#39;news&#39;]&quot;)</code>： 选择所有的name属性以’news’开头的input元素</p>
<p><code>$(&quot;input[name$=&#39;news&#39;]&quot;)</code> ：选择所有的name属性以’news’结尾的input元素</p>
<p><code>$(&quot;input[name*=&#39;man&#39;]&quot;)</code> ：选择所有的name属性包含’news’的input元素</p>
<p><strong>（5）jquery子元素过滤选择器</strong></p>
<p><code>$(&quot;ul li:nth-child(2)&quot;)</code>,<code>$(&quot;ul li:nth-child(odd)&quot;)</code>,<code>$(&quot;ul li:nth-child(3n + 1)&quot;)</code> ：匹配其父元素下的第N个子或奇偶元素.这个选择器和之前说的基础过滤(Basic Filters)中的eq() 有些类似,不同的地方就是前者是从0开始,后者是从1开始。</p>
<p><code>$(&quot;div span:first-child&quot;)</code>：返回所有的div元素的第一个子节点的数组</p>
<p><code>$(&quot;div span:last-child&quot;)</code>：返回所有的div元素的最后一个节点的数组</p>
<p><code>$(&quot;div button:only-child&quot;)</code> ：返回所有的div中只有唯一一个子节点的所有子节点的数组</p>
<p><strong>（6） jquery表单对象属性过滤选择器</strong></p>
<p>此选择器主要对所选择的表单元素进行过滤。</p>
<p><code>$(&quot;:enabled&quot;)</code>：选择所有的可操作的表单元素</p>
<p><code>$(&quot;:disabled&quot;)</code>：选择所有的不可操作的表单元素</p>
<p><code>$(&quot;:checked&quot;)</code>：选择所有的被checked的表单元素</p>
<p><code>$(&quot;select option:selected&quot;)</code>：选择所有的select 的子元素中被selected的元素</p>
<p><code>$(&quot;input[@ name =S_03_22]&quot;).parent().prev().text()</code>：选取一个 name 为”S_03_22”的input text框的上一个td的text值</p>
<p><code>$(&quot;input[@ name ^=&#39;S_&#39;]&quot;).not(&quot;[@ name $=&#39;_R&#39;]&quot;)</code>：名字以”S_ “开始，并且不是以”_R”结尾的</p>
<p><code>$(&quot;input[@ name =radio_01][@checked]&quot;).val()</code>：一个名为 radio_01的radio所选的值</p>
<p><code>$(&quot;A B&quot;)</code>：查找A元素下面的所有子节点，包括非直接子节点</p>
<p><code>$(&quot;A&gt;B&quot;)</code> ：查找A元素下面的直接子节点</p>
<p><code>$(&quot;A+B&quot;)</code> ：查找A元素后面的兄弟节点，包括非直接子节点</p>
<p><code>$(&quot;A~B&quot;)</code> ：查找A元素后面的兄弟节点，不包括非直接子节点</p>
</li>
<li><p><strong>jquery表单选择器</strong></p>
<p><code>$(&quot;:input&quot;)</code> ：选择所有的表单输入元素，包括input, textarea, select 和 button</p>
<p><code>$(&quot;:text&quot;)</code> ： 选择所有的text input元素</p>
<p><code>$(&quot;:password&quot;)</code>： 选择所有的password input元素</p>
<p><code>$(&quot;:radio&quot;)</code> ：选择所有的radio input元素</p>
<p><code>$(&quot;:checkbox&quot;)</code> ：选择所有的checkbox input元素</p>
<p><code>$(&quot;:submit&quot;)</code> ：选择所有的submit input元素</p>
<p><code>$(&quot;:image&quot;)</code> ： 选择所有的image input元素</p>
<p><code>$(&quot;:reset&quot;)</code> ：选择所有的reset input元素</p>
<p><code>$(&quot;:button&quot;)</code> ：选择所有的button input元素</p>
<p><code>$(&quot;:file&quot;)</code> ：选择所有的file input元素</p>
<p><code>$(&quot;:hidden&quot;)</code>：选择所有类型为hidden的input元素或表单的隐藏域</p>
</li>
</ol>
<hr>
<h2 id="44-Jquery插入节点的方法"><a href="#44-Jquery插入节点的方法" class="headerlink" title="44.Jquery插入节点的方法"></a>44.Jquery插入节点的方法</h2><p><code>append()</code>:向每个匹配的元素内部追加内容</p>
<p><code>prepend()</code>: 向每个匹配的元素内部前置内容</p>
<p><code>appendTo()</code>: 将所有匹配的元素追加到指定元素中，实际上，使用该方法是颠倒了常规的$(A).append(B)的操作，即不是将B追加到A中，而是将A追加到B中</p>
<p><code>prependTo()</code>: 将所有匹配的元素前置到指定的元素中。实际上，使用该方法是颠倒了常规的$(A).prepend(B)的操作，即不是将B前置到A中，而是将A前置到B中</p>
<p><code>after()</code>:在每个匹配的元素之后插入内容</p>
<p><code>insertAfter()</code>:将所有匹配的元素插入到指定元素的后面。实际上，使用该方法是颠倒了常规的$(A).after(B)的操作，即不是讲B插入到A后面，而是将A插入到B后面</p>
<p><code>before()</code>    在每个匹配的元素之前插入内容</p>
<p><code>insertBefore()</code>:将所有匹配的元素插入到指定的元素的前面。实际上，使用该方法是颠倒了常规的$(A).before(B)的操作，即不是将B插入到A前面，而是将A插入到B前面</p>
<hr>
<h2 id="45-Js的函数节流和函数防抖的区别"><a href="#45-Js的函数节流和函数防抖的区别" class="headerlink" title="45.Js的函数节流和函数防抖的区别"></a>45.Js的函数节流和函数防抖的区别</h2><p>​        <strong>函数节流</strong>是指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。</p>
<p>​        函数节流应用的<strong>实际场景</strong>，多数在监听页面元素滚动事件的时候会用到。因为滚动事件，是一个高频触发的事件。以下是监听页面元素滚动的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数节流</span></span><br><span class="line"><span class="keyword">var</span> canRun = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;throttle&quot;</span>).onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!canRun)&#123;</span><br><span class="line">        <span class="comment">// 判断是否已空闲，如果在执行中，则直接return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   canRun = <span class="literal">false</span>;</span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&quot;函数节流&quot;</span>);</span><br><span class="line">       canRun = <span class="literal">true</span>;</span><br><span class="line">   &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​        函数节流的<strong>要点</strong>是，声明一个变量当标志位，记录当前代码是否在执行。</p>
<blockquote>
<p>如果空闲，则可以正常触发方法执行。</p>
<p>如果代码正在执行，则取消这次方法执行，直接return。</p>
</blockquote>
<p>​        <strong>函数防抖</strong>是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。</p>
<p>​        函数防抖的<strong>应用场景</strong>，最常见的就是用户注册时候的手机号码验证和邮箱验证了。只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，再弹出提示语。以下还是以页面元素滚动监听的例子，来进行解析：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数防抖</span></span><br><span class="line"><span class="keyword">var</span> timer = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;debounce&quot;</span>).onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 清除未执行的代码，重置回初始化状态</span></span><br><span class="line">timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;函数防抖&quot;</span>);</span><br><span class="line">&#125;, <span class="number">300</span>);</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>​        函数防抖的<strong>要点</strong>，也是需要一个<code>setTimeout</code>来辅助实现。延迟执行需要跑的代码。</p>
<blockquote>
<p>如果方法多次触发，则把上次记录的延迟执行代码用clearTimeout清掉，重新开始。</p>
<p>如果计时完毕，没有方法进来访问触发，则执行代码。</p>
</blockquote>
<hr>
<h2 id="46-Get和post不同"><a href="#46-Get和post不同" class="headerlink" title="46.Get和post不同"></a>46.Get和post不同</h2><table>
<thead>
<tr>
<th>请求方式区别</th>
<th align="center">get</th>
<th align="center">post</th>
</tr>
</thead>
<tbody><tr>
<td>用途</td>
<td align="center">从服务器获取数据</td>
<td align="center">向服务器提交数据</td>
</tr>
<tr>
<td>参数传递</td>
<td align="center">参数拼接在URL上，xxx?id=1234&amp;name=zhagnsan</td>
<td align="center">参数封装在消息主体中一起提交到服务器</td>
</tr>
<tr>
<td>传输数据量</td>
<td align="center">传送的数据量较小，不能大于2KB（URL 的最大长度是 2048 个字符）。</td>
<td align="center">参数封装在消息主体中一起提交到服务器</td>
</tr>
<tr>
<td>安全性</td>
<td align="center">与 POST 相比，GET的安全性较差，因为所发送的数据是 URL 的一部分。(在发送密码或其他敏感信息时绝不要使用 GET )</td>
<td align="center">POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td>
</tr>
<tr>
<td>书签</td>
<td align="center">可收藏为书签</td>
<td align="center">不可收藏为书签</td>
</tr>
<tr>
<td>缓存</td>
<td align="center">能被缓存</td>
<td align="center">不能缓存</td>
</tr>
<tr>
<td>编码类型</td>
<td align="center">application/x-www-form-urlencoded</td>
<td align="center">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码</td>
</tr>
<tr>
<td>历史</td>
<td align="center">参数保留在浏览器历史中</td>
<td align="center">参数不会保存在浏览器历史中</td>
</tr>
<tr>
<td>可见性</td>
<td align="center">数据在URL中对所有人都是可见的</td>
<td align="center">数据不会显示在URL中</td>
</tr>
</tbody></table>
<hr>
<h2 id="47-什么是csrf攻击"><a href="#47-什么是csrf攻击" class="headerlink" title="47.什么是csrf攻击"></a>47.什么是csrf攻击</h2><p>​        CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫<strong>跨站请求伪造</strong>。</p>
<p>​        一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。</p>
<hr>
<h2 id="48-Js数据类型的分类"><a href="#48-Js数据类型的分类" class="headerlink" title="48.Js数据类型的分类"></a>48.Js数据类型的分类</h2><ol>
<li><p><strong>基本数据类型 （值类型）</strong></p>
<ul>
<li> 数字number</li>
<li> 字符串string</li>
<li> 布尔 boolean</li>
<li> null</li>
<li> undefined</li>
</ul>
</li>
<li><p><strong>引用数据类型</strong></p>
<ul>
<li><p>对象object</p>
</li>
<li><p>函数function</p>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="49-Js中手写一个深拷贝"><a href="#49-Js中手写一个深拷贝" class="headerlink" title="49.Js中手写一个深拷贝"></a>49.Js中手写一个深拷贝</h2><ol>
<li>数组中map方法通过制定函数对数组进行操作，并将处理结果返回，结果以新数组的形式返回，不会修改原数组</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line">	<span class="keyword">let</span> obj = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">	<span class="keyword">let</span> newobj = obj.map(<span class="function"><span class="keyword">function</span>(<span class="params">itme, index</span>) </span>&#123;</span><br><span class="line">		<span class="comment">//给obj的每一项加一</span></span><br><span class="line">		<span class="keyword">return</span> itme + <span class="number">1</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">let</span> newobjb = obj</span><br><span class="line">	<span class="built_in">console</span>.log(obj) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">	<span class="comment">//深拷贝</span></span><br><span class="line">	<span class="built_in">console</span>.log(newobj) <span class="comment">//[2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将数组先转成JSON字符串，再转成JSON对象，实现深拷贝。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> objc = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">	<span class="keyword">let</span> objv = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(objc))</span><br><span class="line">	<span class="built_in">console</span>.log(objc)</span><br><span class="line">	objv.push(<span class="number">100</span>) <span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line">	<span class="built_in">console</span>.log(objv) <span class="comment">//[1, 2, 3, 4, 100]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="50-什么时候用深拷贝-浅拷贝"><a href="#50-什么时候用深拷贝-浅拷贝" class="headerlink" title="50.什么时候用深拷贝 /浅拷贝"></a>50.什么时候用深拷贝 /浅拷贝</h2><p>​        想要不改变原值的时候用深拷贝，反之用浅拷贝</p>
<blockquote>
<p>​        无论深浅，都是需要的。当深拷贝发生时，通常表明存在着一个“聚合关系”，而浅拷贝发生时，通常表明存在着一个“相识关系”。 </p>
<p>举个简单的例子：</p>
<p>​        当你实现一个Composite  Pattern，你通常都会实现一个深拷贝(如果需要拷贝的话)，很少有要求同的Composite共享Leaf的； </p>
<p>而当你实现一个Observer  Pattern时，如果你需要拷贝Observer,你大概不会去拷贝Subject，这时就要实现个浅拷贝。 </p>
<p>是深拷贝还是浅拷贝，并不是取决于时间效率、空间效率或是语言等等，而是取决于哪一个是逻辑上正确的。  </p>
</blockquote>
<hr>
<h2 id="51-如何遍历一个多维数组"><a href="#51-如何遍历一个多维数组" class="headerlink" title="51.如何遍历一个多维数组"></a>51.如何遍历一个多维数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历多维数组</span></span><br><span class="line">	<span class="keyword">var</span> newarr = [];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">typeof</span> arr[i] !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">				<span class="comment">// console.log(arr[i])</span></span><br><span class="line">				newarr.push(arr[i])</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				demo(arr[i])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> newarr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(demo([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>],</span><br><span class="line">		[<span class="number">6</span>, <span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>, [<span class="number">10</span>, <span class="number">11</span>]]]</span><br><span class="line">	])) <span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="52-区别2种类型的容器"><a href="#52-区别2种类型的容器" class="headerlink" title="52.区别2种类型的容器"></a>52.区别2种类型的容器</h2><p><strong>1).</strong> <strong>数组容器</strong>:用来保存有序的多个数据(如列表数据), 数据的标识是下标,我们通过下标来操作对应的数据</p>
<p><strong>2).对象容器</strong>:用来保存无序的多个数据,多个数据的标识是属性名,我们通过属性名来操作属性值数据</p>
<hr>
<h2 id="53-说说开发中常用的ES6新语法"><a href="#53-说说开发中常用的ES6新语法" class="headerlink" title="53.说说开发中常用的ES6新语法"></a>53.说说开发中常用的ES6新语法</h2><p><strong>定义变量/常量</strong>: const/let</p>
<p><strong>解构赋值</strong>: <code>let &#123;a, b&#125; = this.props / import &#123;aa&#125; from &#39;xxx&#39; / function f (&#123;name&#125;) &#123;&#125;</code></p>
<p><strong>对象的简洁表达</strong>: <code>&#123;a, b, c () &#123;&#125;&#125;</code></p>
<p><strong>箭头函数</strong>: </p>
<p>   <strong>组件的自定义方法</strong>: <code>xxx = () =&gt; &#123;&#125;</code></p>
<p>   <strong>匿名函数作为实参</strong></p>
<p>   <strong>优点</strong>:</p>
<ul>
<li><p>简洁</p>
</li>
<li><p>没有自己的this,使用引用this查找的是外部this</p>
</li>
</ul>
<p><strong>扩展运算符</strong>: …<br><strong>类</strong>: class/extends/constructor/super<br><strong>ES6模块化</strong>: export/default/import<br><strong>异步</strong>: promise, async/await</p>
<hr>
<h2 id="54-说说你对事件处理机制的理解"><a href="#54-说说你对事件处理机制的理解" class="headerlink" title="54.说说你对事件处理机制的理解"></a>54.说说你对事件处理机制的理解</h2><ol>
<li><p><strong>js事件机制</strong></p>
<p>js中事件的发生包括捕获和冒泡两个阶段，两个阶段的传播顺序为</p>
<p><strong>捕获</strong>：从最外边父元素节点传递至发生事件的元素节点，即由外到内；</p>
<p><strong>冒泡</strong>：从发生事件的元素节点传递至最外边父元素节点，即由内到外；</p>
</li>
<li><p><strong>事件监听</strong></p>
</li>
</ol>
<p>对事件的监听执行一般有一下三种方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.在HTML中对事件进行绑定；</span></span><br><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span> οnclick=<span class="string">&quot;myClick()&quot;</span>&gt;点击&lt;/button&gt;</span><br><span class="line"><span class="comment">//2.在js中对DOM元素进行事件绑定；</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>).onclick = myClick;</span><br><span class="line"><span class="comment">//3.利用监听函数addEventListener(&quot;事件名&quot;,function()&#123;&#125;,false)；</span></span><br></pre></td></tr></table></figure>

<p><code>removeEventListenter(&quot;事件名&quot;,Fun,false)</code>用于解除事件的绑定监听，与addEventListener对应，用法相同</p>
<p>但是这种方法在IE8及其低版本浏览器中不能兼容，可以使用<code>attachEvent(&quot;事件名&quot;,Fun)</code>来进行绑定，因为浏览器</p>
<p>不支持捕获事件，所以没有第三个参数。detachEvent(“事件名”,Fun)与之对应为解除绑定。</p>
<p>一般的事件用法：</p>
<p><img src="images/20170711111746920.jpg" alt="img"></p>
<ol start="3">
<li><p><strong>如何阻止浏览器的默认事件的发生</strong></p>
<p>​    对于前两种的事件，如果想阻止后面的操作的话，只需要在你需要阻止的位置加上一个 return false;</p>
</li>
</ol>
<p>对第三种情况绑定的事件，阻止默认事件，需要用到<code>event.preventDefault()；</code></p>
<p><img src="images/20170711114905188.jpg" alt="img"></p>
<hr>
<h2 id="55-async-await"><a href="#55-async-await" class="headerlink" title="55.async/await?"></a>55.async/await?</h2><p><strong>1). 作用</strong></p>
<p>​    简化pormise的使用(不用再使用then()来指定成功或失败的回调函数)</p>
<p>​    以同步编码的方式实现异步流程(没有回调函数)</p>
<p><strong>2). 哪里使用await?</strong></p>
<p>​    在返回promise对象的表达式左侧, 为了直接得到异步返回的结果, 而不是promsie对象</p>
<p><strong>3). 哪里使用async?</strong></p>
<p>​    使用了await的函数定义左侧</p>
<hr>
<h2 id="56-用数组的相关方法实现以下业务需求"><a href="#56-用数组的相关方法实现以下业务需求" class="headerlink" title="56.用数组的相关方法实现以下业务需求"></a>56.用数组的相关方法实现以下业务需求</h2><blockquote>
<p>公司前后招聘了10个员工(性别,年龄, 月薪各不相同),有以下需求</p>
<p>1). 列表显示所有员工的所有信息  <code>forEach</code></p>
<p>2). 对员工进行年薪降序列表显示  <code>sort()</code></p>
<p>3). 得到男员工的总月薪: <code>reduce()</code></p>
<p>4). 查找一个月薪只比12000高一点点的员工: <code>find()</code></p>
<p>5). 查找出所有月薪高于12000的员工: <strong>filter()</strong></p>
<p>6). 列表显示所有员工的姓名/性别和年薪: <code>map()</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> employees = [</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">salary</span>: <span class="number">10000</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;B&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">salary</span>: <span class="number">12000</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;C&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">salary</span>: <span class="number">13000</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;D&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">salary</span>: <span class="number">12500</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;E&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">salary</span>: <span class="number">14000</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;F&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">salary</span>: <span class="number">16000</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;G&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span>, <span class="attr">salary</span>: <span class="number">9000</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;H&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">salary</span>: <span class="number">11000</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;I&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span>, <span class="attr">salary</span>: <span class="number">13200</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">name</span>: <span class="string">&#x27;J&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span>, <span class="attr">salary</span>: <span class="number">15000</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//1). </span></span><br><span class="line">employees.forEach(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">//2). </span></span><br><span class="line">employees.sort(<span class="function">(<span class="params">e1, e2</span>) =&gt;</span> e2.salary-e1.salary)</span><br><span class="line"><span class="comment">//3). </span></span><br><span class="line">employees.reduce(<span class="function">(<span class="params">preTotal, e</span>) =&gt;</span> preTotal + (e.sex==<span class="string">&#x27;男&#x27;</span>?e.salary:<span class="number">0</span>), <span class="number">0</span>)</span><br><span class="line"><span class="comment">//4). </span></span><br><span class="line">employees.find(<span class="function"><span class="params">e</span> =&gt;</span> e.salary&gt;<span class="number">1200</span> &amp;&amp; e.salary&lt;<span class="number">1400</span> &amp;&amp; e.sex===<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="comment">//5). </span></span><br><span class="line">employees.filter(<span class="function"><span class="params">e</span> =&gt;</span> e.salary&gt;<span class="number">1200</span>)</span><br><span class="line"><span class="comment">//6). </span></span><br><span class="line">employees.map(<span class="function"><span class="params">e</span> =&gt;</span> (&#123;<span class="string">&#x27;姓名/性别&#x27;</span>: <span class="string">`<span class="subst">$&#123;e.name&#125;</span>/<span class="subst">$&#123;e.sex&#125;</span>`</span>, <span class="string">&#x27;年薪&#x27;</span>: e.salary*<span class="number">12</span>&#125;))</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="57-说说你对cookie的理解-分类-创建-保存-使用"><a href="#57-说说你对cookie的理解-分类-创建-保存-使用" class="headerlink" title="57.说说你对cookie的理解(分类, 创建, 保存, 使用)"></a>57.说说你对cookie的理解(分类, 创建, 保存, 使用)</h2><p><strong>cookie</strong>由<code>key</code>和<code>value</code>组成的文本小数据</p>
<p><strong>分类</strong>: 会话cookie和持久化cookie</p>
<p><strong>由服务器端创建</strong>: <code>res.cookie(key, value, &#123;maxAge: 1000&#125;)</code></p>
<p><strong>由浏览器端保存</strong>: 浏览器接收到新的cookie会自动保存(内存/文件)</p>
<p><strong>使用</strong>: 浏览器发送请求时自动携带对应的cookie, 服务器端通过req读取: <code>req.cookies.key</code></p>
<hr>
<h2 id="58-内存结构图-原型结构图"><a href="#58-内存结构图-原型结构图" class="headerlink" title="58.内存结构图(原型结构图)"></a>58.内存结构图(原型结构图)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> fn1 = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure>

<img src="images/wps1.jpg" alt="img" style="zoom:50%;" />

<hr>
<h2 id="59-说说你对变量提升与函数提升的理解"><a href="#59-说说你对变量提升与函数提升的理解" class="headerlink" title="59.说说你对变量提升与函数提升的理解"></a>59.说说你对变量提升与函数提升的理解</h2><p><strong>变量提升</strong>: 在变量定义语句前就可以读取到变量, 值为undefined</p>
<p><strong>函数提升</strong>: 在函数定义语句前就可以调用函数</p>
<p><strong>原因</strong>: JS引擎在运行全局代码或执行函数前有预处理/解析</p>
<hr>
<h2 id="60-说说原型链的理解"><a href="#60-说说原型链的理解" class="headerlink" title="60.说说原型链的理解"></a>60.说说原型链的理解</h2><p><strong>作用</strong>: 原型链用于查找对象的属性</p>
<p><strong>什么</strong>: 实例对象上都会有一个隐式原型属性(<code>__proto__</code>), 它指向的就是原型对象, 而原型对象也有<code>__proto__</code>属性指向它的原型对象</p>
<p><strong>为什么<code>__proto__</code>指向的是原型对象?</strong></p>
<ul>
<li>   构造函数对象上有显式原型属性(<code>prototype</code>), 它指向的就是原型对象</li>
<li>   实例对象的<code>__proto__</code>属性被赋值为构造函数的prototype属性值</li>
</ul>
<hr>
<h2 id="61-说说你对作用域链的理解"><a href="#61-说说你对作用域链的理解" class="headerlink" title="61.说说你对作用域链的理解"></a>61.说说你对作用域链的理解</h2><ol>
<li><p><strong>作用</strong>: 作用链用来查找变量</p>
</li>
<li><p><strong>什么</strong>: 多个由内向外作用域形成的链</p>
</li>
<li><p><strong>作用域</strong>: 一块代码区域, </p>
<p>​    <strong>分类</strong>：全局作用域和函数/局部作用域, ES6有了块作用域</p>
</li>
</ol>
<hr>
<h2 id="62-说说你对闭包的理解"><a href="#62-说说你对闭包的理解" class="headerlink" title="62.说说你对闭包的理解"></a>62.说说你对闭包的理解</h2><ol>
<li><p><strong>如何产生闭包?</strong></p>
<p>​    2个函数嵌套</p>
<p>   内部函数引用了外部函数内的局部变量</p>
<p>   执行外部函数</p>
</li>
<li><p><strong>是什么?</strong></p>
<p>包含了那个局部变量的容器</p>
<p>它被内部函数对象引用着</p>
</li>
<li><p><strong>作用?</strong></p>
<p>​    延长局部变量的生命周期</p>
<p>   使函数外部可以多次间接操作到函数内部的数据</p>
</li>
<li><p><strong>应用?</strong></p>
<p>循环遍历加监听</p>
<p>IIFE定义模块</p>
<p>jQuery内部</p>
</li>
<li><p><strong>代码演示:</strong></p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         a++</span><br><span class="line">         <span class="built_in">console</span>.log(a)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fn2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> f = fn1()</span><br><span class="line">   f()</span><br><span class="line">   f()</span><br><span class="line">   f = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="63-JS事件循环机制-图"><a href="#63-JS事件循环机制-图" class="headerlink" title="63.JS事件循环机制(图)"></a>63.JS事件循环机制(图)</h2><img src="images/wps2.jpg" alt="img" style="zoom:50%;" />

<hr>
<h2 id="64-比较函数的call-apply-bind"><a href="#64-比较函数的call-apply-bind" class="headerlink" title="64.比较函数的call()/apply()/bind()"></a>64.比较函数的call()/apply()/bind()</h2><ol>
<li><p><code>call(obj, param1, param2)/apply(obj, [[param1, param2])</code></p>
<p>调用/执行函数</p>
<p>只是强制指定函数中的this为第一个参数指定的对象</p>
<p>如果函数执行需要传参数, call是依次传递, apply需要封装成数组传递</p>
</li>
<li><p><code>bind()</code></p>
<p>返回一个新函数, 不会自动执行, 需要手动执行</p>
<p>强制指定函数中的this为第一个参数指定的对象</p>
<p>新函数内部会原样调用原函数</p>
</li>
</ol>
<hr>
<h2 id="65-debug调试"><a href="#65-debug调试" class="headerlink" title="65.debug调试"></a>65.debug调试</h2><ol>
<li><p><strong>调试的目的</strong></p>
<p>​     查找bug: 不断缩小可疑代码的范围</p>
<p>​     查看程序的运行流程(用于熟悉新接手项目的代码)</p>
</li>
<li><p><strong>如何开启调试模式</strong></p>
<p>​     添加语debugger句: 程序运行前     此方式用打包后才运行的项目</p>
<p>​     添加(打)断点: 程序运行前或者过程中   此方式用运行源码js</p>
</li>
<li><p><strong>如何进行调试操作</strong></p>
<p><code>resume</code>: 恢复程序执行(可能执行完或者进入下一个断点处)</p>
<p><code>step ove</code>: 单步跳转, 尝试执行完当前语句, 进入下一条(如果内部有断点, 自动进入内部断点处)</p>
<p><code>step into</code>: 跳入, 进入当前调用函数内部</p>
<p><code>step out</code>: 跳出, 一次性执行完当前函数后面所有语句,并出去</p>
<p><code>deactivate breakpoints</code>: 使所有断点暂时失效     </p>
<p><code>call stack</code>: 显示是程序函数调用的过程<br> <code>scop</code>: 当前执行环境对应的作用域中包含的变量数据<br> <code>breakpoints</code>: 断点列表</p>
</li>
</ol>
<hr>
<h2 id="66-说说你对回调函数的理解"><a href="#66-说说你对回调函数的理解" class="headerlink" title="66.说说你对回调函数的理解"></a>66.说说你对回调函数的理解</h2><ol>
<li><p><strong>什么函数才是回调函数</strong></p>
<p>你定义的</p>
<p>你没有直接调用</p>
<p>它最终执行了</p>
</li>
<li><p><strong>回调函数相关的3个问题</strong></p>
<p>什么时候执行</p>
<p>用来做什么的</p>
<p>函数中的this是谁</p>
</li>
</ol>
<hr>
<h2 id="67-详细说明如何判断函数中的this"><a href="#67-详细说明如何判断函数中的this" class="headerlink" title="67.详细说明如何判断函数中的this"></a>67.详细说明如何判断函数中的this</h2><ol>
<li><p><strong>正常情况</strong>: 执行函数的方式决定了函数中的this</p>
<p><strong>直接调用</strong>: <code>fn()</code>       window</p>
<p><strong>new调用</strong>: <code>new fn()</code>   新创建的对象 </p>
<p><strong>对象调用</strong>: <code>obj.fn()</code>   obj对象</p>
<p><strong>call/apply调用</strong>: <code>fn.call(obj)</code>   第一个参数指定的对象</p>
</li>
<li><p><strong>特别情况</strong>:</p>
<p><strong>bind()返回的函数</strong>: <code>fn2 = fn.bind(obj)</code> fn2()第一个参数指定的对象</p>
<p><strong>箭头函数</strong>: 使用的外部的this(内部没有自己的this) <code>fn = () =&gt; &#123;&#125; fn()</code></p>
<p><strong>回调函数</strong></p>
<p>​      <strong>定时器回调/ajax回调/数组遍历相关方法回调</strong>: window</p>
<p>​      <strong>dom事件监听回调</strong>: dom元素</p>
<p>​      <strong>组件生命周期回调</strong>: 组件对象</p>
</li>
<li><p>在开发我们经常会利用<strong>箭头函数/bind()来改变this的指向</strong></p>
</li>
</ol>
<hr>
<h2 id="68-区别localStorage和sessionStorage-session与cookie"><a href="#68-区别localStorage和sessionStorage-session与cookie" class="headerlink" title="68.区别localStorage和sessionStorage, session与cookie"></a>68.区别localStorage和sessionStorage, session与cookie</h2><ol>
<li><strong>localStorage</strong>: 浏览器端持久化存储, 关闭浏览还存在, 最大5MB(基本没限制了)</li>
<li><strong>sessionStorage</strong>: 浏览器端内存存储, 关闭浏览器不存在</li>
<li><strong>session</strong>: 服务器端创建, 服务器端保存, 依赖于cookie</li>
<li><strong>cookie</strong>: 服务器端创建, 浏览器端保存, 请求携带对应cookie, 长度和数量有限制(4kb)</li>
</ol>
<hr>
<h2 id="69-关于2个引用变量指向同一个对象的2个问题"><a href="#69-关于2个引用变量指向同一个对象的2个问题" class="headerlink" title="69.关于2个引用变量指向同一个对象的2个问题"></a>69.关于2个引用变量指向同一个对象的2个问题</h2><ol>
<li>2个引用变量指向同个对象, 通过一个引用变量改变对象内部的数据, 另一个引用变量看到的新的</li>
<li>2个引用变量指向同个对象, 让一个引用变量指向一个新的对象, 另一个引用变量看到的还是原来的对象</li>
</ol>
<hr>
<h2 id="70-console-log-a-b-的查找流程"><a href="#70-console-log-a-b-的查找流程" class="headerlink" title="70.console.log(a.b)的查找流程"></a>70.console.log(a.b)的查找流程</h2><ol>
<li>先查找a, 沿着作用域链查找, 找不到报错(变量未定义)</li>
<li>找到后查找对象上的b属性, 查找原型链, 如果找不到返回undefined</li>
</ol>
<hr>
<h2 id="71-为什么要深拷贝、浅拷贝？"><a href="#71-为什么要深拷贝、浅拷贝？" class="headerlink" title="71.为什么要深拷贝、浅拷贝？"></a>71.为什么要深拷贝、浅拷贝？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">age</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a.age = <span class="number">2</span> <span class="comment">// 操作a也会影响b</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">//从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="72-手写深度克隆"><a href="#72-手写深度克隆" class="headerlink" title="72.手写深度克隆"></a>72.手写深度克隆</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度克隆：对象/数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化变量，获取目标数据的类型</span></span><br><span class="line">    <span class="keyword">let</span> result, targetClass = getTargetClass(target);</span><br><span class="line">    <span class="comment">// 2. 判断目标的类型</span></span><br><span class="line">    <span class="keyword">if</span>(targetClass === <span class="string">&#x27;Object&#x27;</span>)&#123; <span class="comment">// 对象</span></span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(targetClass === <span class="string">&#x27;Array&#x27;</span>)&#123;  <span class="comment">// 数组</span></span><br><span class="line">        result = [];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 遍历目标数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> target)&#123;</span><br><span class="line">        <span class="comment">// 获取每一项值</span></span><br><span class="line">        <span class="keyword">let</span> item = target[key];</span><br><span class="line">        <span class="comment">// 4. 判断每一项数据的类型</span></span><br><span class="line">        <span class="keyword">if</span>(getTargetClass(item) === <span class="string">&#x27;Object&#x27;</span> || getTargetClass(item) === <span class="string">&#x27;Array&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">// 无论是对象还是数组，都可以result[key]取值</span></span><br><span class="line">            <span class="comment">// item = &#123;name: &#x27;kobe&#x27;&#125;  item[]</span></span><br><span class="line">            result[key] = deepClone(item);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result[key] = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个判断数据类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTargetClass</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>, -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="73-ES6中共有五种针对对象遍历的方法？"><a href="#73-ES6中共有五种针对对象遍历的方法？" class="headerlink" title="73.ES6中共有五种针对对象遍历的方法？"></a>73.ES6中共有五种针对对象遍历的方法？</h2><ol>
<li><code>for in</code><pre><code>for in 循环遍历对象自身的和继承的可枚举的属性（不含Symbol属性）
</code></pre>
</li>
<li><code>Object.keys(obj)</code><br>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）</li>
<li><code>Object.getOwnPropertyNames(obj)</code><br>返回一个数组，包含对象自身的所有属性（不含Symbol属性，但包括不可枚举属性）</li>
<li><code>Object.getOwnPropertySymbols(obj)</code><br>返回一个数组，包含对象自身所有的Symbol属性</li>
<li><code>Reflect.ownKeys(obj)</code><br>返回一个数组，包含对象自身的所有属性，不论属性名是Symbol或字符串，也不管是否可枚举。</li>
</ol>
<hr>
<h2 id="74-什么是同源策略？"><a href="#74-什么是同源策略？" class="headerlink" title="74.什么是同源策略？"></a>74.什么是同源策略？</h2><ol>
<li><strong>同源策略</strong>是由Netscape提出的一个著名的安全策略，现在所有支持JavaScript 的浏览器都会使用这个策略。</li>
<li>Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</li>
<li>所谓<strong>同源</strong>是指：协议，域名（IP），端口必须要完全相同<br>即：<strong>协议、域名（IP）、端口都相同</strong>，才能算是在同一个域里。</li>
</ol>
<hr>
<h2 id="75-非同源受到了哪些限制？"><a href="#75-非同源受到了哪些限制？" class="headerlink" title="75.非同源受到了哪些限制？"></a>75.非同源受到了哪些限制？</h2><ol>
<li>Cookie不能读取；</li>
<li>DOM无法获得；</li>
<li>Ajax请求不能发送</li>
</ol>
<hr>
<h2 id="76-JSONP解决跨域"><a href="#76-JSONP解决跨域" class="headerlink" title="76.JSONP解决跨域"></a>76.JSONP解决跨域</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.前端写法</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//1. 创建一个script标签</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//2. 设置回调函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">window</span>.getData = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="built_in">console</span>.log(data); <span class="comment">//拿到数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//3. 设置script标签src属性，填写跨域请求的地址</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			script.src = <span class="string">&#x27;http://localhost:3000/jsonp?callback=getData&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//4. 将script标签添加到body中生效</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">document</span>.body.appendChild(script);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="comment">//5.不影响整体DOM结构，删除script标签</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">document</span>.body.removeChild(script);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"><span class="comment">//2.后端写法</span></span><br><span class="line">app.get(<span class="string">&#x27;/jsonp&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//解构赋值获取请求参数</span></span><br><span class="line"><span class="keyword">const</span> &#123;callback&#125; = req.query</span><br><span class="line"><span class="comment">//去数据库查找对应数据</span></span><br><span class="line"><span class="keyword">const</span> data = [&#123;<span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&#x27;jerry&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;];</span><br><span class="line">res.send(callback + <span class="string">&#x27;(&#x27;</span> + <span class="built_in">JSON</span>.stringify(data) + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="77-Cors解决跨域？"><a href="#77-Cors解决跨域？" class="headerlink" title="77.Cors解决跨域？"></a>77.Cors解决跨域？</h2><p>以Node为例：<br><code>res.set(&#39;Access-Control-Allow-Origin&#39;, &#39;http://localhost:63342&#39;);</code></p>
<p>存在安全问题<br>以上两种凡是解决跨域， 第三种使用代理工具 反向代理工具</p>
<hr>
<h2 id="78-函数防抖"><a href="#78-函数防抖" class="headerlink" title="78.函数防抖"></a>78.函数防抖</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防抖（一段时间会等，然后带着一起做了）</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> timerId = <span class="literal">null</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">const</span> context = <span class="built_in">this</span></span><br><span class="line">         <span class="keyword">if</span>(timerId)&#123;<span class="built_in">window</span>.clearTimeout(timerId)&#125;</span><br><span class="line">         timerId = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">             fn.apply(context, <span class="built_in">arguments</span>)</span><br><span class="line">             timerId = <span class="literal">null</span></span><br><span class="line">         &#125;,delay)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="79-函数节流"><a href="#79-函数节流" class="headerlink" title="79.函数节流"></a>79.函数节流</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节流（一段时间执行一次之后，就不执行第二次）</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> canUse = <span class="literal">true</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(canUse)&#123;</span><br><span class="line">             fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">             canUse = <span class="literal">false</span></span><br><span class="line">             <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>canUse = <span class="literal">true</span>, delay)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="80-手写ajax"><a href="#80-手写ajax" class="headerlink" title="80.手写ajax"></a>80.手写ajax</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"> request.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/a/b/c?name=ff&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"> request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(request.readyState === <span class="number">4</span> &amp;&amp; request.status === <span class="number">200</span>) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(request.responseText);</span><br><span class="line">   &#125;&#125;;</span><br><span class="line"> request.send();</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试题总结</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>原生JS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何清除浮动？</title>
    <url>/article/b582ade9.html</url>
    <content><![CDATA[<h2 id="本文概述"><a href="#本文概述" class="headerlink" title="本文概述"></a>本文概述</h2><p>本文的框架图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24295319-6b059107f9366a6a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="一、浮动到底是什么？"><a href="#一、浮动到底是什么？" class="headerlink" title="一、浮动到底是什么？"></a>一、浮动到底是什么？</h2><p>W3school中给出的浮动定义为<strong>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</strong>由于浮动框脱离文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-82e1d94c49c8e905?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css浮动"></p>
<h2 id="二、浮动有什么特点？"><a href="#二、浮动有什么特点？" class="headerlink" title="二、浮动有什么特点？"></a>二、浮动有什么特点？</h2><p>浮动的特点，可以用八个字总结：<strong>脱标、贴边、字围和收缩。</strong></p>
<p>为了更好说明，请看下图：<br>当框 1 向左浮动时，它脱离文档流（脱标）并且向左移动（贴边），直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框 2，使框 2 从视图中消失。如果框2中有文字，就会围着框1排开（字围）。</p>
<p>如果把所有三个框都向左浮动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。<br><img src="https://upload-images.jianshu.io/upload_images/24295319-54cbbdffe716eda1?imageMogr2/auto-orient/strip" alt="CSS 浮动实例 - 向左浮动的元素"><br>下面着重讲解下第四个特点–收缩</p>
<p>一个浮动的内联元素（比如span img标签）不需要设置display：block就可以设置宽度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: greenyellow;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    这是一段文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>得到以下的效果：<br><img src="https://upload-images.jianshu.io/upload_images/24295319-ec21eeb7a08a1d75?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>我们都知道div标签是块级元素，会独占一行，然而上面的例子中将div设置为左浮后，其宽度不再是占满一行，而是收紧为内部元素的宽度，这就是浮动第四个特征的含义。</p>
<h2 id="三、浮动有什么缺点？"><a href="#三、浮动有什么缺点？" class="headerlink" title="三、浮动有什么缺点？"></a>三、浮动有什么缺点？</h2><p>先看下面这段代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.parent</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">border</span>: solid <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.child</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.child</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>)&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.child</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>)&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: greenyellow;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们想让父容器包裹着三个浮动元素，然而事与愿违，得到却是这样的结果：<br><img src="https://upload-images.jianshu.io/upload_images/24295319-c67c2da543f13028?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="父容器高度塌陷"></p>
<p>这就是浮动带来副作用—-父容器高度塌陷，于是清理浮动就显着至关重要。</p>
<h2 id="四、如何清理浮动？"><a href="#四、如何清理浮动？" class="headerlink" title="四、如何清理浮动？"></a>四、如何清理浮动？</h2><p><strong>清除浮动不是不用浮动，清除浮动产生的父容器高度塌陷</strong>。</p>
<h3 id="套路1：给浮动元素的父元素添加高度（扩展性不好）"><a href="#套路1：给浮动元素的父元素添加高度（扩展性不好）" class="headerlink" title="套路1：给浮动元素的父元素添加高度（扩展性不好）"></a>套路1：给浮动元素的父元素添加高度（扩展性不好）</h3><p>如果一个元素要浮动，那么它的父元素一定要有高度。高度的盒子，才能关住浮动。可以通过直接给父元素设置height，实际应用中我们不大可能给所有的盒子加高度，不仅麻烦，并且不能适应页面的快速变化；另外一种，父容器的高度可以通过内容撑开（比如img图片），实际当中此方法用的比较多。</p>
<h3 id="套路2：clear-both"><a href="#套路2：clear-both" class="headerlink" title="套路2：clear:both;"></a>套路2：clear:both;</h3><p>在最后一个子元素新添加最后一个冗余元素，然后将其设置clear:both,这样就可以清除浮动。这里强调一点，即<strong>在父级元素末尾添加的元素必须是一个块级元素，否则无法撑起父级元素高度</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#inner</span>&#123;</span><br><span class="line">      <span class="attribute">float</span>: left;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">      <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="套路3：伪元素清除浮动"><a href="#套路3：伪元素清除浮动" class="headerlink" title="套路3：伪元素清除浮动"></a>套路3：伪元素清除浮动</h3><p>上面那种办法固然可以清除浮动，但是我们不想在页面中添加这些没有意义的冗余元素，此时如何清除浮动吗？<br><strong>结合 :after 伪元素和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrap&quot;</span> <span class="attr">class</span>=<span class="string">&quot;clearfix&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#inner</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*开启haslayout*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*ie6 7 不支持伪元素*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">visibility</span>:hidden;//允许浏览器渲染它，但是不显示出来</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>给浮动元素的父容器添加一个clearfix的class，然后给这个class添加一个:after伪元素，实现元素末尾添加一个看不见的块元素来清理浮动。这是通用的清理浮动方案，推荐使用</p>
<h3 id="套路4：给父元素使用overflow-hidden"><a href="#套路4：给父元素使用overflow-hidden" class="headerlink" title="套路4：给父元素使用overflow:hidden;"></a>套路4：给父元素使用overflow:hidden;</h3><p>这种方案让父容器形成了BFC（块级格式上下文），而BFC可以包含浮动，通常用来解决浮动父元素高度坍塌的问题。</p>
<p><strong>BFC的触发方式</strong></p>
<p>我们可以给父元素添加以下属性来触发BFC：</p>
<ul>
<li>  float 为 left | right</li>
<li>  overflow 为 hidden | auto | scorll</li>
<li>  display 为 table-cell | table-caption | inline-block</li>
<li>  position 为 absolute | fixed</li>
</ul>
<p>这里可以给父元素设置overflow:auto，但是为了兼容IE最好使用overflow:hidden。</p>
<p><strong>但这种办法有个缺陷：如果有内容出了盒子，用这种方法就会把多的部分裁切掉，所以这时候不能使用。</strong></p>
<p><strong>BFC的主要特征:</strong></p>
<ul>
<li><p>  BFC容器是一个隔离的容器，和其他元素互不干扰；所以我们可以用触发两个元素的BFC来解决垂直边距折叠问题。</p>
</li>
<li><p>  BFC不会重叠浮动元素</p>
</li>
<li><p>  BFC可以包含浮动,这可以清除浮动。</p>
</li>
</ul>
<h3 id="套路5：br标签清浮动"><a href="#套路5：br标签清浮动" class="headerlink" title="套路5：br标签清浮动"></a>套路5：br标签清浮动</h3><p><strong>br标签存在一个属性：clear。这个属性就是能够清除浮动的利器，在br标签中设置属性clear，并赋值all。即能清除掉浮动</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> <span class="attr">clear</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#inner</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如需前端交流请以以下方式联系。</p>
<blockquote>
<p>QQ:2567046155<br>Q群:110156046<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>知识点归纳</category>
      </categories>
      <tags>
        <tag>清除浮动</tag>
        <tag>H5布局</tag>
      </tags>
  </entry>
</search>
